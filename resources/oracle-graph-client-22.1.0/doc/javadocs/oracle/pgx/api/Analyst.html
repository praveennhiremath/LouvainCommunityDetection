<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_221) on Fri Jan 14 16:41:17 UTC 2022 -->
<title>Analyst (Oracle Graph Java API Reference for Property Graph Release 22.1 (F51971-01))</title>
<meta name="date" content="2022-01-14">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Analyst (Oracle Graph Java API Reference for Property Graph Release 22.1 (F51971-01))";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":10,"i52":10,"i53":10,"i54":10,"i55":10,"i56":10,"i57":10,"i58":10,"i59":10,"i60":10,"i61":10,"i62":10,"i63":10,"i64":10,"i65":10,"i66":10,"i67":10,"i68":10,"i69":10,"i70":10,"i71":10,"i72":10,"i73":10,"i74":10,"i75":10,"i76":10,"i77":10,"i78":10,"i79":10,"i80":10,"i81":10,"i82":10,"i83":10,"i84":10,"i85":10,"i86":10,"i87":10,"i88":10,"i89":10,"i90":10,"i91":10,"i92":10,"i93":10,"i94":10,"i95":10,"i96":10,"i97":10,"i98":10,"i99":10,"i100":10,"i101":10,"i102":10,"i103":10,"i104":10,"i105":10,"i106":10,"i107":10,"i108":10,"i109":10,"i110":10,"i111":10,"i112":10,"i113":10,"i114":10,"i115":10,"i116":10,"i117":10,"i118":10,"i119":10,"i120":10,"i121":10,"i122":10,"i123":10,"i124":10,"i125":10,"i126":10,"i127":10,"i128":10,"i129":10,"i130":10,"i131":10,"i132":10,"i133":10,"i134":10,"i135":10,"i136":10,"i137":10,"i138":10,"i139":10,"i140":10,"i141":10,"i142":10,"i143":10,"i144":10,"i145":10,"i146":10,"i147":10,"i148":10,"i149":10,"i150":10,"i151":10,"i152":10,"i153":10,"i154":10,"i155":10,"i156":10,"i157":10,"i158":10,"i159":10,"i160":10,"i161":10,"i162":10,"i163":10,"i164":10,"i165":10,"i166":10,"i167":10,"i168":10,"i169":10,"i170":10,"i171":10,"i172":10,"i173":10,"i174":10,"i175":10,"i176":10,"i177":10,"i178":10,"i179":10,"i180":10,"i181":10,"i182":10,"i183":10,"i184":10,"i185":10,"i186":10,"i187":10,"i188":10,"i189":10,"i190":10,"i191":10,"i192":10,"i193":10,"i194":10,"i195":10,"i196":10,"i197":10,"i198":10,"i199":10,"i200":10,"i201":10,"i202":10,"i203":10,"i204":10,"i205":10,"i206":10,"i207":10,"i208":10,"i209":10,"i210":10,"i211":10,"i212":10,"i213":10,"i214":10,"i215":10,"i216":10,"i217":10,"i218":10,"i219":10,"i220":10,"i221":10,"i222":10,"i223":10,"i224":10,"i225":10,"i226":10,"i227":10,"i228":10,"i229":10,"i230":10,"i231":10,"i232":10,"i233":10,"i234":10,"i235":10,"i236":10,"i237":10,"i238":10,"i239":10,"i240":10,"i241":10,"i242":10,"i243":10,"i244":10,"i245":10,"i246":10,"i247":10,"i248":10,"i249":10,"i250":10,"i251":10,"i252":10,"i253":10,"i254":10,"i255":10,"i256":10,"i257":10,"i258":10,"i259":10,"i260":10,"i261":10,"i262":10,"i263":10,"i264":10,"i265":10,"i266":10,"i267":10,"i268":10,"i269":10,"i270":10,"i271":10,"i272":10,"i273":10,"i274":10,"i275":10,"i276":10,"i277":10,"i278":10,"i279":10,"i280":10,"i281":10,"i282":10,"i283":10,"i284":10,"i285":10,"i286":10,"i287":10,"i288":10,"i289":10,"i290":10,"i291":10,"i292":10,"i293":10,"i294":10,"i295":10,"i296":10,"i297":10,"i298":10,"i299":10,"i300":10,"i301":10,"i302":10,"i303":10,"i304":10,"i305":10,"i306":10,"i307":10,"i308":10,"i309":10,"i310":10,"i311":10,"i312":10,"i313":10,"i314":10,"i315":10,"i316":10,"i317":10,"i318":10,"i319":10,"i320":10,"i321":10,"i322":10,"i323":10,"i324":10,"i325":10,"i326":10,"i327":10,"i328":10,"i329":10,"i330":10,"i331":10,"i332":10,"i333":10,"i334":10,"i335":10,"i336":10,"i337":10,"i338":10,"i339":10,"i340":10,"i341":10,"i342":10,"i343":10,"i344":10,"i345":10,"i346":10,"i347":10,"i348":10,"i349":10,"i350":10,"i351":10,"i352":10,"i353":10,"i354":10,"i355":10,"i356":10,"i357":10,"i358":10,"i359":10,"i360":10,"i361":10,"i362":10,"i363":10,"i364":10,"i365":10,"i366":10,"i367":10,"i368":10,"i369":10,"i370":10,"i371":10,"i372":10,"i373":10,"i374":10,"i375":10,"i376":10,"i377":10,"i378":10,"i379":10,"i380":10,"i381":10,"i382":10,"i383":10,"i384":10,"i385":10,"i386":10,"i387":10,"i388":10,"i389":10,"i390":10,"i391":10,"i392":10,"i393":10,"i394":10,"i395":10,"i396":10,"i397":10,"i398":10,"i399":10,"i400":10,"i401":10,"i402":10,"i403":10,"i404":10,"i405":10,"i406":10,"i407":10,"i408":10,"i409":10,"i410":10,"i411":10,"i412":10,"i413":10,"i414":10,"i415":10,"i416":10,"i417":10,"i418":10,"i419":10,"i420":10,"i421":10,"i422":10,"i423":10,"i424":10,"i425":10,"i426":10,"i427":10,"i428":10,"i429":10,"i430":10,"i431":10,"i432":10,"i433":10,"i434":10,"i435":10,"i436":10,"i437":10,"i438":10,"i439":10,"i440":10,"i441":10,"i442":10,"i443":10,"i444":10,"i445":10,"i446":10,"i447":10,"i448":10,"i449":10,"i450":10,"i451":10,"i452":10,"i453":10,"i454":10,"i455":10,"i456":10,"i457":10,"i458":10,"i459":10,"i460":10,"i461":10,"i462":10,"i463":10,"i464":10,"i465":10,"i466":10,"i467":10,"i468":10,"i469":10,"i470":10,"i471":10,"i472":10,"i473":10,"i474":10,"i475":10,"i476":10,"i477":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Analyst.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><b>Oracle&reg; Graph Java API Reference for Property Graph<br/>Release 22.1</b> <br/>F51971-01</div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?oracle/pgx/api/Analyst.html" target="_top">Frames</a></li>
<li><a href="Analyst.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">oracle.pgx.api</div>
<h2 title="Class Analyst" class="title">Class Analyst</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>oracle.pgx.api.internal.ApiObject</li>
<li>
<ul class="inheritance">
<li><a href="../../../oracle/pgx/api/Destroyable.html" title="class in oracle.pgx.api">oracle.pgx.api.Destroyable</a></li>
<li>
<ul class="inheritance">
<li>oracle.pgx.api.Analyst</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.lang.AutoCloseable</dd>
</dl>
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><a href="../../../oracle/pgx/api/NamedArgumentAnalyst.html" title="class in oracle.pgx.api">NamedArgumentAnalyst</a></dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">Analyst</span>
extends <a href="../../../oracle/pgx/api/Destroyable.html" title="class in oracle.pgx.api">Destroyable</a></pre>
<div class="block">The Analyst gives access to all built-in algorithms of PGX. Unlike other classes inside this package, the Analyst is
 not stateless. It creates session-bound transient data to hold the result of algorithms and keeps track of them. Once
 <a href="../../../oracle/pgx/api/Destroyable.html#destroy--"><code>Destroyable.destroy()</code></a> is invoked, all transient data returned by the Analyst gets freed and cannot be used anymore.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#adamicAdarCounting-oracle.pgx.api.PgxGraph-">adamicAdarCounting</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">The adamic-adar index compares the amount of neighbors shared between vertices, this measure can be used with communities.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#adamicAdarCounting-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">adamicAdarCounting</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;aa)</code>
<div class="block">The adamic-adar index compares the amount of neighbors shared between vertices, this measure can be used with communities.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#adamicAdarCountingAsync-oracle.pgx.api.PgxGraph-">adamicAdarCountingAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">The adamic-adar index compares the amount of neighbors shared between vertices, this measure can be used with communities.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#adamicAdarCountingAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">adamicAdarCountingAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;aa)</code>
<div class="block">The adamic-adar index compares the amount of neighbors shared between vertices, this measure can be used with communities.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;org.apache.commons.lang3.tuple.Triple&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSet.html" title="class in oracle.pgx.api">EdgeSet</a>,<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#allReachableVerticesEdges-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-">allReachableVerticesEdges</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                         int&nbsp;k)</code>
<div class="block">Finds all the vertices and edges on a path between the src and target of length smaller or equal to k.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;org.apache.commons.lang3.tuple.Triple&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSet.html" title="class in oracle.pgx.api">EdgeSet</a>,<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#allReachableVerticesEdgesAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-">allReachableVerticesEdgesAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                              <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                              <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                              int&nbsp;k)</code>
<div class="block">Finds all the vertices and edges on a path between the src and target of length smaller or equal to k.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;org.apache.commons.lang3.tuple.Triple&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSet.html" title="class in oracle.pgx.api">EdgeSet</a>,<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#allReachableVerticesEdgesFiltered-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.filter.EdgeFilter-">allReachableVerticesEdgesFiltered</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                 int&nbsp;k,
                                 <a href="../../../oracle/pgx/api/filter/EdgeFilter.html" title="class in oracle.pgx.api.filter">EdgeFilter</a>&nbsp;filter)</code>
<div class="block">Finds all the vertices and edges on a path between the src and target of length smaller or equal to k.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;org.apache.commons.lang3.tuple.Triple&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSet.html" title="class in oracle.pgx.api">EdgeSet</a>,<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#allReachableVerticesEdgesFilteredAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.filter.EdgeFilter-">allReachableVerticesEdgesFilteredAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                      <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                      <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                      int&nbsp;k,
                                      <a href="../../../oracle/pgx/api/filter/EdgeFilter.html" title="class in oracle.pgx.api.filter">EdgeFilter</a>&nbsp;filter)</code>
<div class="block">Finds all the vertices and edges on a path between the src and target of length smaller or equal to k.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#approximateVertexBetweennessCentrality-oracle.pgx.api.PgxGraph-int-">approximateVertexBetweennessCentrality</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                      int&nbsp;k)</code>
<div class="block">Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#approximateVertexBetweennessCentrality-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-">approximateVertexBetweennessCentrality</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                      int&nbsp;k,
                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;bc)</code>
<div class="block">Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#approximateVertexBetweennessCentralityAsync-oracle.pgx.api.PgxGraph-int-">approximateVertexBetweennessCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                           int&nbsp;k)</code>
<div class="block">Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#approximateVertexBetweennessCentralityAsync-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-">approximateVertexBetweennessCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                           int&nbsp;k,
                                           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;bc)</code>
<div class="block">Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#approximateVertexBetweennessCentralityFromSeeds-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex...-">approximateVertexBetweennessCentralityFromSeeds</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                               <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;...&nbsp;seeds)</code>
<div class="block">Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#approximateVertexBetweennessCentralityFromSeeds-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.PgxVertex...-">approximateVertexBetweennessCentralityFromSeeds</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;bc,
                                               <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;...&nbsp;seeds)</code>
<div class="block">Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#approximateVertexBetweennessCentralityFromSeedsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex...-">approximateVertexBetweennessCentralityFromSeedsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;...&nbsp;seeds)</code>
<div class="block">Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#approximateVertexBetweennessCentralityFromSeedsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.PgxVertex...-">approximateVertexBetweennessCentralityFromSeedsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;bc,
                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;...&nbsp;seeds)</code>
<div class="block">Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Boolean&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#bipartiteCheck-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">bipartiteCheck</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Boolean&gt;&nbsp;isLeft)</code>
<div class="block">Bipartite check verifies whether are graph is a bipartite graph.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Boolean&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#bipartiteCheckAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">bipartiteCheckAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Boolean&gt;&nbsp;isLeft)</code>
<div class="block">Bipartite check verifies whether are graph is a bipartite graph.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#center-oracle.pgx.api.PgxGraph-">center</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#center-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">center</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
      <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;center)</code>
<div class="block">Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#centerAsync-oracle.pgx.api.PgxGraph-">centerAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#centerAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">centerAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;center)</code>
<div class="block">Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#closenessCentralityDoubleLength-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">closenessCentralityDoubleLength</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                               <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</code>
<div class="block">Closenness centrality measures the centrality of the vertices based on weighted distances, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#closenessCentralityDoubleLength-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">closenessCentralityDoubleLength</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                               <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;cc)</code>
<div class="block">Closenness centrality measures the centrality of the vertices based on weighted distances, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#closenessCentralityDoubleLengthAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">closenessCentralityDoubleLengthAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                    <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</code>
<div class="block">Closenness centrality measures the centrality of the vertices based on weighted distances, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#closenessCentralityDoubleLengthAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">closenessCentralityDoubleLengthAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                    <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;cc)</code>
<div class="block">Closenness centrality measures the centrality of the vertices based on weighted distances, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#closenessCentralityUnitLength-oracle.pgx.api.PgxGraph-">closenessCentralityUnitLength</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Closenness centrality measures the centrality of the vertices based on distances, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#closenessCentralityUnitLength-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">closenessCentralityUnitLength</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;cc)</code>
<div class="block">Closenness centrality measures the centrality of the vertices based on distances, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#closenessCentralityUnitLengthAsync-oracle.pgx.api.PgxGraph-">closenessCentralityUnitLengthAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Closenness centrality measures the centrality of the vertices based on distances, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#closenessCentralityUnitLengthAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">closenessCentralityUnitLengthAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;cc)</code>
<div class="block">Closenness centrality measures the centrality of the vertices based on distances, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesConductanceMinimization-oracle.pgx.api.PgxGraph-">communitiesConductanceMinimization</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Soman and Narang can find communities in a graph taking weighted edges into account</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesConductanceMinimization-oracle.pgx.api.PgxGraph-int-">communitiesConductanceMinimization</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                  int&nbsp;maxIterations)</code>
<div class="block">Soman and Narang can find communities in a graph taking weighted edges into account</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesConductanceMinimization-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-">communitiesConductanceMinimization</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                  int&nbsp;maxIterations,
                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</code>
<div class="block">Soman and Narang can find communities in a graph taking weighted edges into account</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesConductanceMinimization-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">communitiesConductanceMinimization</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</code>
<div class="block">Soman and Narang can find communities in a graph taking weighted edges into account</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesConductanceMinimizationAsync-oracle.pgx.api.PgxGraph-">communitiesConductanceMinimizationAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Soman and Narang can find communities in a graph taking weighted edges into account</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesConductanceMinimizationAsync-oracle.pgx.api.PgxGraph-int-">communitiesConductanceMinimizationAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                       int&nbsp;max)</code>
<div class="block">Soman and Narang can find communities in a graph taking weighted edges into account</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesConductanceMinimizationAsync-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-">communitiesConductanceMinimizationAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                       int&nbsp;maxIterations,
                                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</code>
<div class="block">Soman and Narang can find communities in a graph taking weighted edges into account</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesConductanceMinimizationAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">communitiesConductanceMinimizationAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</code>
<div class="block">Soman and Narang can find communities in a graph taking weighted edges into account</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesInfomap-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-">communitiesInfomap</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Infomap can find high quality communities in a graph.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesInfomap-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-double-double-int-">communitiesInfomap</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                  double&nbsp;tau,
                  double&nbsp;tol,
                  int&nbsp;maxIter)</code>
<div class="block">Infomap can find high quality communities in a graph.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesInfomap-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-double-double-int-oracle.pgx.api.VertexProperty-">communitiesInfomap</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                  double&nbsp;tau,
                  double&nbsp;tol,
                  int&nbsp;maxIter,
                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;module)</code>
<div class="block">Infomap can find high quality communities in a graph.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesInfomap-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">communitiesInfomap</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;module)</code>
<div class="block">Infomap can find high quality communities in a graph.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesInfomapAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-">communitiesInfomapAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Infomap can find high quality communities in a graph.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesInfomapAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-double-double-int-">communitiesInfomapAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                       double&nbsp;tau,
                       double&nbsp;tol,
                       int&nbsp;maxIter)</code>
<div class="block">Infomap can find high quality communities in a graph.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesInfomapAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-double-double-int-oracle.pgx.api.VertexProperty-">communitiesInfomapAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                       double&nbsp;tau,
                       double&nbsp;tol,
                       int&nbsp;maxIter,
                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;module)</code>
<div class="block">Infomap can find high quality communities in a graph.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesInfomapAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">communitiesInfomapAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;module)</code>
<div class="block">Infomap can find high quality communities in a graph.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesLabelPropagation-oracle.pgx.api.PgxGraph-">communitiesLabelPropagation</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Label propagation can find communities in a graph relatively fast</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesLabelPropagation-oracle.pgx.api.PgxGraph-int-">communitiesLabelPropagation</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                           int&nbsp;maxIterations)</code>
<div class="block">Label propagation can find communities in a graph relatively fast</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesLabelPropagation-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-">communitiesLabelPropagation</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                           int&nbsp;maxIterations,
                           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</code>
<div class="block">Label propagation can find communities in a graph relatively fast</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesLabelPropagation-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">communitiesLabelPropagation</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitonDistribution)</code>
<div class="block">Label propagation can find communities in a graph relatively fast</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesLabelPropagationAsync-oracle.pgx.api.PgxGraph-">communitiesLabelPropagationAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Label propagation can find communities in a graph relatively fast</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesLabelPropagationAsync-oracle.pgx.api.PgxGraph-int-">communitiesLabelPropagationAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                int&nbsp;maxIterations)</code>
<div class="block">Label propagation can find communities in a graph relatively fast</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesLabelPropagationAsync-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-">communitiesLabelPropagationAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                int&nbsp;maxIterations,
                                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</code>
<div class="block">Label propagation can find communities in a graph relatively fast</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#communitiesLabelPropagationAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">communitiesLabelPropagationAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</code>
<div class="block">Label propagation can find communities in a graph relatively fast</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;,<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#computeHighDegreeVertices-oracle.pgx.api.PgxGraph-int-">computeHighDegreeVertices</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         int&nbsp;k)</code>
<div class="block">Computes the k vertices with the highest degrees in the graph.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;,<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#computeHighDegreeVertices-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-">computeHighDegreeVertices</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         int&nbsp;k,
                         <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                         <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices)</code>
<div class="block">Computes the k vertices with the highest degrees in the graph.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;,<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#computeHighDegreeVerticesAsync-oracle.pgx.api.PgxGraph-int-">computeHighDegreeVerticesAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                              int&nbsp;k)</code>
<div class="block">Computes the k vertices with the highest degrees in the graph.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;,<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#computeHighDegreeVerticesAsync-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-">computeHighDegreeVerticesAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                              int&nbsp;k,
                              <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                              <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices)</code>
<div class="block">Computes the k vertices with the highest degrees in the graph.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#conductance-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-long-">conductance</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
           long&nbsp;partitionIndex)</code>
<div class="block">Conductance assesses the quality of a partition in a graph</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#conductance-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-long-oracle.pgx.api.Scalar-">conductance</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
           long&nbsp;partitionIndex,
           <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;conductance)</code>
<div class="block">Conductance assesses the quality of a partition in a graph</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#conductanceAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-long-">conductanceAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                long&nbsp;partitionIndex)</code>
<div class="block">Conductance assesses the quality of a partition in a graph</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#conductanceAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-long-oracle.pgx.api.Scalar-">conductanceAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                long&nbsp;partitionIndex,
                <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;conductance)</code>
<div class="block">Conductance assesses the quality of a partition in a graph</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#countTriangles-oracle.pgx.api.PgxGraph-boolean-">countTriangles</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
              boolean&nbsp;sortVerticesByDegree)</code>
<div class="block">triangle counting gives an overview of the amount of connections between vertices in neighborhoods</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#countTrianglesAsync-oracle.pgx.api.PgxGraph-boolean-">countTrianglesAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   boolean&nbsp;sortVerticesByDegree)</code>
<div class="block">triangle counting gives an overview of the amount of connections between vertices in neighborhoods</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#createDistanceIndex-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-">createDistanceIndex</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                   <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices)</code>
<div class="block">Computes an index with distances to each high-degree vertex.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#createDistanceIndex-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">createDistanceIndex</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                   <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index)</code>
<div class="block">Computes an index with distances to each high-degree vertex.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#createDistanceIndexAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-">createDistanceIndexAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                        <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                        <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices)</code>
<div class="block">Computes an index with distances to each high-degree vertex.</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#createDistanceIndexAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">createDistanceIndexAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                        <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                        <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index)</code>
<div class="block">Computes an index with distances to each high-degree vertex.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/mllib/DeepWalkModelBuilder.html" title="class in oracle.pgx.api.mllib">DeepWalkModelBuilder</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#deepWalkModelBuilder--">deepWalkModelBuilder</a></span>()</code>
<div class="block">Builder for Deepwalk model</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#degreeCentrality-oracle.pgx.api.PgxGraph-">degreeCentrality</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#degreeCentrality-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">degreeCentrality</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;dc)</code>
<div class="block">Degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#degreeCentralityAsync-oracle.pgx.api.PgxGraph-">degreeCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#degreeCentralityAsync-oracle.pgx.api.PgxGraph-java.lang.String-">degreeCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     java.lang.String&nbsp;propertyName)</code>&nbsp;</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#degreeCentralityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">degreeCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;dc)</code>
<div class="block">Degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;java.lang.Void&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#destroyAsync--">destroyAsync</a></span>()</code>
<div class="block">Requests destruction of this object.</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#diameter-oracle.pgx.api.PgxGraph-">diameter</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Diameter/radius gives an overview of the distances in a graph</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#diameter-oracle.pgx.api.PgxGraph-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">diameter</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
        <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;&nbsp;diameter,
        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;eccentricity)</code>
<div class="block">Diameter/radius gives an overview of the distances in a graph</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#diameterAsync-oracle.pgx.api.PgxGraph-">diameterAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Diameter/radius gives an overview of the distances in a graph</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#diameterAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">diameterAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
             <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;&nbsp;diameter,
             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;eccentricity)</code>
<div class="block">Diameter/radius gives an overview of the distances in a graph</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#eigenvectorCentrality-oracle.pgx.api.PgxGraph-">eigenvectorCentrality</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#eigenvectorCentrality-oracle.pgx.api.PgxGraph-int-double-boolean-boolean-">eigenvectorCentrality</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     int&nbsp;max,
                     double&nbsp;maxDiff,
                     boolean&nbsp;useL2Norm,
                     boolean&nbsp;useInEdge)</code>
<div class="block">Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#eigenvectorCentrality-oracle.pgx.api.PgxGraph-int-double-boolean-boolean-oracle.pgx.api.VertexProperty-">eigenvectorCentrality</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     int&nbsp;max,
                     double&nbsp;maxDiff,
                     boolean&nbsp;useL2Norm,
                     boolean&nbsp;useInEdge,
                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;ec)</code>
<div class="block">Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#eigenvectorCentrality-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">eigenvectorCentrality</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;ec)</code>
<div class="block">Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#eigenvectorCentralityAsync-oracle.pgx.api.PgxGraph-">eigenvectorCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#eigenvectorCentralityAsync-oracle.pgx.api.PgxGraph-int-double-boolean-boolean-">eigenvectorCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                          int&nbsp;max,
                          double&nbsp;maxDiff,
                          boolean&nbsp;useL2Norm,
                          boolean&nbsp;useInEdge)</code>
<div class="block">Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#eigenvectorCentralityAsync-oracle.pgx.api.PgxGraph-int-double-boolean-boolean-oracle.pgx.api.VertexProperty-">eigenvectorCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                          int&nbsp;max,
                          double&nbsp;maxDiff,
                          boolean&nbsp;useL2Norm,
                          boolean&nbsp;useInEdge,
                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;ec)</code>
<div class="block">Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#eigenvectorCentralityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">eigenvectorCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;ec)</code>
<div class="block">Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;org.apache.commons.lang3.tuple.Triple&lt;<a href="../../../oracle/pgx/api/ScalarSequence.html" title="class in oracle.pgx.api">ScalarSequence</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#enumerateSimplePaths-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.VertexSet-oracle.pgx.api.EdgeSet-oracle.pgx.api.PgxMap-">enumerateSimplePaths</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                    int&nbsp;k,
                    <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&nbsp;verticesOnPath,
                    <a href="../../../oracle/pgx/api/EdgeSet.html" title="class in oracle.pgx.api">EdgeSet</a>&nbsp;edgesOnPath,
                    <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&nbsp;dist)</code>
<div class="block">Enumerate all simple paths between the source and destination vertex</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;org.apache.commons.lang3.tuple.Triple&lt;<a href="../../../oracle/pgx/api/ScalarSequence.html" title="class in oracle.pgx.api">ScalarSequence</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#enumerateSimplePathsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.VertexSet-oracle.pgx.api.EdgeSet-oracle.pgx.api.PgxMap-">enumerateSimplePathsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                         int&nbsp;k,
                         <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&nbsp;verticesOnPath,
                         <a href="../../../oracle/pgx/api/EdgeSet.html" title="class in oracle.pgx.api">EdgeSet</a>&nbsp;edgesOnPath,
                         <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&nbsp;dist)</code>
<div class="block">Enumerate all simple paths between the source and destination vertex</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#fattestPath-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.EdgeProperty-">fattestPath</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           ID&nbsp;rootId,
           <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;capacity)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#fattestPath-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-"><code>fattestPath(PgxGraph, PgxVertex, EdgeProperty)</code></a> taking a vertex ID instead of a
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#fattestPath-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">fattestPath</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           ID&nbsp;rootId,
           <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;capacity,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#fattestPath-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-"><code>fattestPath(PgxGraph, PgxVertex, EdgeProperty, VertexProperty,
 VertexProperty, VertexProperty)</code></a> taking a vertex ID instead of a
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#fattestPath-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">fattestPath</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;capacity)</code>
<div class="block">Fattest path is a fast algorithm for finding a shortest path adding constraints for flowing related matters</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#fattestPath-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">fattestPath</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;capacity,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Fattest path is a fast algorithm for finding a shortest path adding constraints for flowing related matters</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#fattestPathAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">fattestPathAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;capacity)</code>
<div class="block">Fattest path is a fast algorithm for finding a shortest path adding constraints for flowing related matters</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#fattestPathAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">fattestPathAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;capacity,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Fattest path is a fast algorithm for finding a shortest path adding constraints for flowing related matters</div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfs-oracle.pgx.api.PgxGraph-ID-">filteredBfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           ID&nbsp;root)</code>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-"><code>filteredBfs(PgxGraph, PgxVertex)</code></a>
 taking a vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfs-oracle.pgx.api.PgxGraph-ID-int-">filteredBfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           ID&nbsp;root,
           int&nbsp;maxDepth)</code>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-"><code>filteredBfs(PgxGraph, PgxVertex, int)</code></a>
 taking a vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">filteredBfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-">filteredBfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           int&nbsp;maxDepth)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-">filteredBfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-">filteredBfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
           boolean&nbsp;initWithInf)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-">filteredBfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
           boolean&nbsp;initWithInf,
           int&nbsp;maxDepth)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">filteredBfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
           boolean&nbsp;initWithInf,
           int&nbsp;maxDepth,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">filteredBfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
           boolean&nbsp;initWithInf,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-int-">filteredBfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
           int&nbsp;maxDepth)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">filteredBfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-">filteredBfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                int&nbsp;maxDepth)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i107" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-">filteredBfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i108" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-">filteredBfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                boolean&nbsp;initWithInf)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i109" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-">filteredBfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                boolean&nbsp;initWithInf,
                int&nbsp;maxDepth)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i110" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">filteredBfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                boolean&nbsp;initWithInf,
                int&nbsp;maxDepth,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i111" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">filteredBfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                boolean&nbsp;initWithInf,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i112" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-int-">filteredBfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                int&nbsp;maxDepth)</code>
<div class="block">A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i113" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfs-oracle.pgx.api.PgxGraph-ID-">filteredDfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           ID&nbsp;root)</code>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-"><code>filteredDfs(PgxGraph, PgxVertex)</code></a>
 taking a vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i114" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfs-oracle.pgx.api.PgxGraph-ID-int-">filteredDfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           ID&nbsp;root,
           int&nbsp;maxDepth)</code>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-"><code>filteredDfs(PgxGraph, PgxVertex, int)</code></a>
 taking a vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i115" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">filteredDfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i116" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-">filteredDfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           int&nbsp;maxDepth)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i117" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-">filteredDfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i118" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-">filteredDfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
           boolean&nbsp;initWithInf)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i119" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-">filteredDfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
           boolean&nbsp;initWithInf,
           int&nbsp;maxDepth)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i120" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">filteredDfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
           boolean&nbsp;initWithInf,
           int&nbsp;maxDepth,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i121" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">filteredDfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
           boolean&nbsp;initWithInf,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i122" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-int-">filteredDfs</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
           <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
           int&nbsp;maxDepth)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i123" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">filteredDfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i124" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-">filteredDfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                int&nbsp;maxDepth)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i125" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-">filteredDfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i126" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-">filteredDfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                boolean&nbsp;initWithInf)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i127" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-">filteredDfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                boolean&nbsp;initWithInf,
                int&nbsp;maxDepth)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i128" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">filteredDfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                boolean&nbsp;initWithInf,
                int&nbsp;maxDepth,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i129" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">filteredDfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                boolean&nbsp;initWithInf,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i130" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-int-">filteredDfsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                int&nbsp;maxDepth)</code>
<div class="block">A Depth-First Search implementation with an option to filter edges during the traversal of the graph.</div>
</td>
</tr>
<tr id="i131" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#findCycle-oracle.pgx.api.PgxGraph-">findCycle</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Find cycle looks for any loop in the graph.</div>
</td>
</tr>
<tr id="i132" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#findCycle-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">findCycle</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src)</code>
<div class="block">Find cycle looks for any loop in the graph.</div>
</td>
</tr>
<tr id="i133" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#findCycle-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">findCycle</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
         <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;nodeSeq,
         <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;edgeSeq)</code>
<div class="block">Find cycle looks for any loop in the graph.</div>
</td>
</tr>
<tr id="i134" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#findCycle-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">findCycle</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
         <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;nodeSeq,
         <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;edgeSeq)</code>
<div class="block">Find cycle looks for any loop in the graph.</div>
</td>
</tr>
<tr id="i135" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#findCycleAsync-oracle.pgx.api.PgxGraph-">findCycleAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Find cycle looks for any loop in the graph.</div>
</td>
</tr>
<tr id="i136" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#findCycleAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">findCycleAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
              <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src)</code>
<div class="block">Find cycle looks for any loop in the graph.</div>
</td>
</tr>
<tr id="i137" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#findCycleAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">findCycleAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
              <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
              <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;nodeSeq,
              <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;edgeSeq)</code>
<div class="block">Find cycle looks for any loop in the graph.</div>
</td>
</tr>
<tr id="i138" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#findCycleAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">findCycleAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
              <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;nodeSeq,
              <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;edgeSeq)</code>
<div class="block">Find cycle looks for any loop in the graph.</div>
</td>
</tr>
<tr id="i139" class="rowColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/PgxSession.html" title="class in oracle.pgx.api">PgxSession</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#getSession--">getSession</a></span>()</code>
<div class="block">Gets the session.</div>
</td>
</tr>
<tr id="i140" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/mllib/GraphWiseConvLayerConfigBuilder.html" title="class in oracle.pgx.api.mllib">GraphWiseConvLayerConfigBuilder</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#graphWiseConvLayerConfigBuilder--">graphWiseConvLayerConfigBuilder</a></span>()</code>
<div class="block">Return a GraphWiseLayerConfigBuilder used to create a GraphWiseLayerConfig</div>
</td>
</tr>
<tr id="i141" class="rowColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/mllib/GraphWiseDgiLayerConfigBuilder.html" title="class in oracle.pgx.api.mllib">GraphWiseDgiLayerConfigBuilder</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#graphWiseDgiLayerConfigBuilder--">graphWiseDgiLayerConfigBuilder</a></span>()</code>
<div class="block">Return a GraphWiseDgiLayerConfigBuilder used to create a GraphWiseDgiLayerConfig</div>
</td>
</tr>
<tr id="i142" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/mllib/GraphWisePredictionLayerConfigBuilder.html" title="class in oracle.pgx.api.mllib">GraphWisePredictionLayerConfigBuilder</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#graphWisePredictionLayerConfigBuilder--">graphWisePredictionLayerConfigBuilder</a></span>()</code>
<div class="block">Return a GraphWisePredictionLayerConfigBuilder used to create a GraphWiseLayerConfig</div>
</td>
</tr>
<tr id="i143" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#hits-oracle.pgx.api.PgxGraph-">hits</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures</div>
</td>
</tr>
<tr id="i144" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#hits-oracle.pgx.api.PgxGraph-int-">hits</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
    int&nbsp;max)</code>
<div class="block">HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures</div>
</td>
</tr>
<tr id="i145" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#hits-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">hits</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
    int&nbsp;max,
    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;auth,
    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;hubs)</code>
<div class="block">HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures</div>
</td>
</tr>
<tr id="i146" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#hits-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">hits</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;auth,
    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;hubs)</code>
<div class="block">HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures</div>
</td>
</tr>
<tr id="i147" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#hitsAsync-oracle.pgx.api.PgxGraph-">hitsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures</div>
</td>
</tr>
<tr id="i148" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#hitsAsync-oracle.pgx.api.PgxGraph-int-">hitsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
         int&nbsp;max)</code>
<div class="block">HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures</div>
</td>
</tr>
<tr id="i149" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#hitsAsync-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">hitsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
         int&nbsp;max,
         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;auth,
         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;hubs)</code>
<div class="block">HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures</div>
</td>
</tr>
<tr id="i150" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#hitsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">hitsAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;auth,
         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;hubs)</code>
<div class="block">HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures</div>
</td>
</tr>
<tr id="i151" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#inDegreeCentrality-oracle.pgx.api.PgxGraph-">inDegreeCentrality</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">In-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood</div>
</td>
</tr>
<tr id="i152" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#inDegreeCentrality-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">inDegreeCentrality</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;dc)</code>
<div class="block">In-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood</div>
</td>
</tr>
<tr id="i153" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#inDegreeCentralityAsync-oracle.pgx.api.PgxGraph-">inDegreeCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">In-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood</div>
</td>
</tr>
<tr id="i154" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#inDegreeCentralityAsync-oracle.pgx.api.PgxGraph-java.lang.String-">inDegreeCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                       java.lang.String&nbsp;propertyName)</code>&nbsp;</td>
</tr>
<tr id="i155" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#inDegreeCentralityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">inDegreeCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;dc)</code>
<div class="block">In-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood</div>
</td>
</tr>
<tr id="i156" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#inDegreeDistribution-oracle.pgx.api.PgxGraph-">inDegreeDistribution</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">In-degree distribution gives information about the incoming flows in a graph</div>
</td>
</tr>
<tr id="i157" class="rowColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#inDegreeDistribution-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-">inDegreeDistribution</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&nbsp;distribution)</code>
<div class="block">In-degree distribution gives information about the incoming flows in a graph</div>
</td>
</tr>
<tr id="i158" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#inDegreeDistributionAsync-oracle.pgx.api.PgxGraph-">inDegreeDistributionAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">In-degree distribution gives information about the incoming flows in a graph</div>
</td>
</tr>
<tr id="i159" class="rowColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#inDegreeDistributionAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-">inDegreeDistributionAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&nbsp;distribution)</code>
<div class="block">In-degree distribution gives information about the incoming flows in a graph</div>
</td>
</tr>
<tr id="i160" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#kcore-oracle.pgx.api.PgxGraph-">kcore</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">k-core decomposes a graph into layers revealing subgraphs with particular properties</div>
</td>
</tr>
<tr id="i161" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#kcore-oracle.pgx.api.PgxGraph-int-int-">kcore</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
     int&nbsp;minCore,
     int&nbsp;maxCore)</code>
<div class="block">k-core decomposes a graph into layers revealing subgraphs with particular properties</div>
</td>
</tr>
<tr id="i162" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#kcore-oracle.pgx.api.PgxGraph-int-int-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">kcore</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
     int&nbsp;minCore,
     int&nbsp;maxCore,
     <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;&nbsp;maxKCore,
     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;kcore)</code>
<div class="block">k-core decomposes a graph into layers revealing subgraphs with particular properties</div>
</td>
</tr>
<tr id="i163" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#kcore-oracle.pgx.api.PgxGraph-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">kcore</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
     <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;&nbsp;maxKCore,
     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;kcore)</code>
<div class="block">k-core decomposes a graph into layers revealing subgraphs with particular properties</div>
</td>
</tr>
<tr id="i164" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#kcoreAsync-oracle.pgx.api.PgxGraph-">kcoreAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">k-core decomposes a graph into layers revealing subgraphs with particular properties</div>
</td>
</tr>
<tr id="i165" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#kcoreAsync-oracle.pgx.api.PgxGraph-int-int-">kcoreAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
          int&nbsp;minCore,
          int&nbsp;maxCore)</code>
<div class="block">k-core decomposes a graph into layers revealing subgraphs with particular properties</div>
</td>
</tr>
<tr id="i166" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#kcoreAsync-oracle.pgx.api.PgxGraph-int-int-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">kcoreAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
          int&nbsp;minCore,
          int&nbsp;maxCore,
          <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;&nbsp;maxKCore,
          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;kcore)</code>
<div class="block">k-core decomposes a graph into layers revealing subgraphs with particular properties</div>
</td>
</tr>
<tr id="i167" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#kcoreAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">kcoreAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
          <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;&nbsp;maxKCore,
          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;kcore)</code>
<div class="block">k-core decomposes a graph into layers revealing subgraphs with particular properties</div>
</td>
</tr>
<tr id="i168" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#limitedShortestPathHopDist-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">limitedShortestPathHopDist</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                          int&nbsp;maxHops,
                          <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                          <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index)</code>
<div class="block">Computes the k-hop limited shortest path between two vertices.</div>
</td>
</tr>
<tr id="i169" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#limitedShortestPathHopDist-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">limitedShortestPathHopDist</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                          int&nbsp;maxHops,
                          <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                          <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index,
                          <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;pathVertices,
                          <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;pathEdges)</code>
<div class="block">Computes the k-hop limited shortest path between two vertices.</div>
</td>
</tr>
<tr id="i170" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#limitedShortestPathHopDistAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">limitedShortestPathHopDistAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                               <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                               <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                               int&nbsp;maxHops,
                               <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                               <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index)</code>
<div class="block">Computes the k-hop limited shortest path between two vertices.</div>
</td>
</tr>
<tr id="i171" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#limitedShortestPathHopDistAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">limitedShortestPathHopDistAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                               <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                               <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                               int&nbsp;maxHops,
                               <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                               <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index,
                               <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;pathVertices,
                               <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;pathEdges)</code>
<div class="block">Computes the k-hop limited shortest path between two vertices.</div>
</td>
</tr>
<tr id="i172" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#limitedShortestPathHopDistFiltered-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-oracle.pgx.api.filter.EdgeFilter-">limitedShortestPathHopDistFiltered</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                  int&nbsp;maxHops,
                                  <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                  <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index,
                                  <a href="../../../oracle/pgx/api/filter/EdgeFilter.html" title="class in oracle.pgx.api.filter">EdgeFilter</a>&nbsp;filter)</code>
<div class="block">Computes the k-hop limited shortest path between two vertices.</div>
</td>
</tr>
<tr id="i173" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#limitedShortestPathHopDistFiltered-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-oracle.pgx.api.filter.EdgeFilter-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">limitedShortestPathHopDistFiltered</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                  int&nbsp;maxHops,
                                  <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                  <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index,
                                  <a href="../../../oracle/pgx/api/filter/EdgeFilter.html" title="class in oracle.pgx.api.filter">EdgeFilter</a>&nbsp;filter,
                                  <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;pathVertices,
                                  <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;pathEdges)</code>
<div class="block">Computes the k-hop limited shortest path between two vertices.</div>
</td>
</tr>
<tr id="i174" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#limitedShortestPathHopDistFilteredAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-oracle.pgx.api.filter.EdgeFilter-">limitedShortestPathHopDistFilteredAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                       <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                       <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                       int&nbsp;maxHops,
                                       <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                       <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index,
                                       <a href="../../../oracle/pgx/api/filter/EdgeFilter.html" title="class in oracle.pgx.api.filter">EdgeFilter</a>&nbsp;filter)</code>
<div class="block">Computes the k-hop limited shortest path between two vertices.</div>
</td>
</tr>
<tr id="i175" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#limitedShortestPathHopDistFilteredAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-oracle.pgx.api.filter.EdgeFilter-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">limitedShortestPathHopDistFilteredAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                       <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                       <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                       int&nbsp;maxHops,
                                       <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                       <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index,
                                       <a href="../../../oracle/pgx/api/filter/EdgeFilter.html" title="class in oracle.pgx.api.filter">EdgeFilter</a>&nbsp;filter,
                                       <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;pathVertices,
                                       <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;pathEdges)</code>
<div class="block">Computes the k-hop limited shortest path between two vertices.</div>
</td>
</tr>
<tr id="i176" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib">GenericModelLoader</a>&lt;<a href="../../../oracle/pgx/api/mllib/DeepWalkModel.html" title="class in oracle.pgx.api.mllib">DeepWalkModel</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#loadDeepWalkModel--">loadDeepWalkModel</a></span>()</code>
<div class="block">Returns <a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib"><code>GenericModelLoader</code></a> to configure how to load a DeepWalk model and then trigger it.</div>
</td>
</tr>
<tr id="i177" class="rowColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/mllib/DeepWalkModel.html" title="class in oracle.pgx.api.mllib">DeepWalkModel</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#loadDeepWalkModel-java.lang.String-java.lang.String-">loadDeepWalkModel</a></span>(java.lang.String&nbsp;path,
                 java.lang.String&nbsp;key)</code>
<div class="block">Loads an encrypted Deepwalk model</div>
</td>
</tr>
<tr id="i178" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib">GenericModelLoader</a>&lt;<a href="../../../oracle/pgx/api/mllib/Pg2vecModel.html" title="class in oracle.pgx.api.mllib">Pg2vecModel</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#loadPg2vecModel--">loadPg2vecModel</a></span>()</code>
<div class="block">Returns <a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib"><code>GenericModelLoader</code></a> to configure how to load a Pg2vec model and then trigger it.</div>
</td>
</tr>
<tr id="i179" class="rowColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/mllib/Pg2vecModel.html" title="class in oracle.pgx.api.mllib">Pg2vecModel</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#loadPg2vecModel-java.lang.String-java.lang.String-">loadPg2vecModel</a></span>(java.lang.String&nbsp;path,
               java.lang.String&nbsp;key)</code>
<div class="block">Loads an encrypted pg2vec model</div>
</td>
</tr>
<tr id="i180" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib">GenericModelLoader</a>&lt;<a href="../../../oracle/pgx/api/mllib/SupervisedGraphWiseModel.html" title="class in oracle.pgx.api.mllib">SupervisedGraphWiseModel</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#loadSupervisedGraphWiseModel--">loadSupervisedGraphWiseModel</a></span>()</code>
<div class="block">Returns <a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib"><code>GenericModelLoader</code></a> to configure how to load a SupervisedGraphWiseModel model and then trigger it.</div>
</td>
</tr>
<tr id="i181" class="rowColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/mllib/SupervisedGraphWiseModel.html" title="class in oracle.pgx.api.mllib">SupervisedGraphWiseModel</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#loadSupervisedGraphWiseModel-java.lang.String-java.lang.String-">loadSupervisedGraphWiseModel</a></span>(java.lang.String&nbsp;path,
                            java.lang.String&nbsp;key)</code>
<div class="block">Loads an encrypted SupervisedGraphWise model</div>
</td>
</tr>
<tr id="i182" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib">GenericModelLoader</a>&lt;<a href="../../../oracle/pgx/api/mllib/UnsupervisedGraphWiseModel.html" title="class in oracle.pgx.api.mllib">UnsupervisedGraphWiseModel</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#loadUnsupervisedGraphWiseModel--">loadUnsupervisedGraphWiseModel</a></span>()</code>
<div class="block">Returns <a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib"><code>GenericModelLoader</code></a> to configure how to load a UnsupervisedGraphWise model and then trigger it.</div>
</td>
</tr>
<tr id="i183" class="rowColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/mllib/UnsupervisedGraphWiseModel.html" title="class in oracle.pgx.api.mllib">UnsupervisedGraphWiseModel</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#loadUnsupervisedGraphWiseModel-java.lang.String-java.lang.String-">loadUnsupervisedGraphWiseModel</a></span>(java.lang.String&nbsp;path,
                              java.lang.String&nbsp;key)</code>
<div class="block">Loads an encrypted UnsupervisedGraphWise model</div>
</td>
</tr>
<tr id="i184" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#localClusteringCoefficient-oracle.pgx.api.PgxGraph-">localClusteringCoefficient</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">LCC gives information about potential clustering options in a graph</div>
</td>
</tr>
<tr id="i185" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#localClusteringCoefficient-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">localClusteringCoefficient</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;lcc)</code>
<div class="block">LCC gives information about potential clustering options in a graph</div>
</td>
</tr>
<tr id="i186" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#localClusteringCoefficientAsync-oracle.pgx.api.PgxGraph-">localClusteringCoefficientAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">LCC gives information about potential clustering options in a graph</div>
</td>
</tr>
<tr id="i187" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#localClusteringCoefficientAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">localClusteringCoefficientAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;lcc)</code>
<div class="block">LCC gives information about potential clustering options in a graph</div>
</td>
</tr>
<tr id="i188" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#louvain-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">louvain</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Louvain can detect communities in a large graph relatively fast.</div>
</td>
</tr>
<tr id="i189" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#louvain-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-int-">louvain</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
       int&nbsp;maxIter)</code>
<div class="block">Louvain can detect communities in a large graph relatively fast.</div>
</td>
</tr>
<tr id="i190" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#louvain-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-int-int-double-oracle.pgx.api.VertexProperty-">louvain</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
       int&nbsp;maxIter,
       int&nbsp;nbrPass,
       double&nbsp;tol,
       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;community)</code>
<div class="block">Louvain can detect communities in a large graph relatively fast.</div>
</td>
</tr>
<tr id="i191" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#louvainAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">louvainAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Louvain can detect communities in a large graph relatively fast.</div>
</td>
</tr>
<tr id="i192" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#louvainAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-int-">louvainAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
            int&nbsp;maxIter)</code>
<div class="block">Louvain can detect communities in a large graph relatively fast.</div>
</td>
</tr>
<tr id="i193" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#louvainAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-int-int-double-oracle.pgx.api.VertexProperty-">louvainAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
            int&nbsp;maxIter,
            int&nbsp;nbrPass,
            double&nbsp;tol,
            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;community)</code>
<div class="block">Louvain can detect communities in a large graph relatively fast.</div>
</td>
</tr>
<tr id="i194" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#matrixFactorizationGradientDescent-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-">matrixFactorizationGradientDescent</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Matrix factorization can be used as a recommendation algorithm for bipartite graphs</div>
</td>
</tr>
<tr id="i195" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#matrixFactorizationGradientDescent-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-double-double-double-int-int-">matrixFactorizationGradientDescent</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                  double&nbsp;learningRate,
                                  double&nbsp;changePerStep,
                                  double&nbsp;lambda,
                                  int&nbsp;maxStep,
                                  int&nbsp;vectorLength)</code>
<div class="block">Matrix factorization can be used as a recommendation algorithm for bipartite graphs</div>
</td>
</tr>
<tr id="i196" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#matrixFactorizationGradientDescent-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-double-double-double-int-int-oracle.pgx.api.VertexProperty-">matrixFactorizationGradientDescent</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                  double&nbsp;learningRate,
                                  double&nbsp;changePerStep,
                                  double&nbsp;lambda,
                                  int&nbsp;maxStep,
                                  int&nbsp;vectorLength,
                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Double&gt;&gt;&nbsp;features)</code>
<div class="block">Matrix factorization can be used as a recommendation algorithm for bipartite graphs</div>
</td>
</tr>
<tr id="i197" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#matrixFactorizationGradientDescent-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">matrixFactorizationGradientDescent</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Double&gt;&gt;&nbsp;features)</code>
<div class="block">Matrix factorization can be used as a recommendation algorithm for bipartite graphs</div>
</td>
</tr>
<tr id="i198" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#matrixFactorizationGradientDescentAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-">matrixFactorizationGradientDescentAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Matrix factorization can be used as a recommendation algorithm for bipartite graphs</div>
</td>
</tr>
<tr id="i199" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#matrixFactorizationGradientDescentAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-double-double-double-int-int-">matrixFactorizationGradientDescentAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                       double&nbsp;learningRate,
                                       double&nbsp;changePerStep,
                                       double&nbsp;lambda,
                                       int&nbsp;maxStep,
                                       int&nbsp;vectorLength)</code>
<div class="block">Matrix factorization can be used as a recommendation algorithm for bipartite graphs</div>
</td>
</tr>
<tr id="i200" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#matrixFactorizationGradientDescentAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-double-double-double-int-int-oracle.pgx.api.VertexProperty-">matrixFactorizationGradientDescentAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                       double&nbsp;learningRate,
                                       double&nbsp;changePerStep,
                                       double&nbsp;lambda,
                                       int&nbsp;maxStep,
                                       int&nbsp;vectorLength,
                                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Double&gt;&gt;&nbsp;features)</code>
<div class="block">Matrix factorization can be used as a recommendation algorithm for bipartite graphs</div>
</td>
</tr>
<tr id="i201" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#matrixFactorizationGradientDescentAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">matrixFactorizationGradientDescentAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Double&gt;&gt;&nbsp;features)</code>
<div class="block">Matrix factorization can be used as a recommendation algorithm for bipartite graphs</div>
</td>
</tr>
<tr id="i202" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#matrixFactorizationRecommendations-oracle.pgx.api.BipartiteGraph-ID-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">matrixFactorizationRecommendations</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                  ID&nbsp;user,
                                  int&nbsp;vectorLength,
                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Double&gt;&gt;&nbsp;feature,
                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;estimatedRating)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#matrixFactorizationRecommendations-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-"><code>matrixFactorizationRecommendations(BipartiteGraph, PgxVertex, int,
 VertexProperty, VertexProperty)</code></a> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i203" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#matrixFactorizationRecommendations-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">matrixFactorizationRecommendations</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;user,
                                  int&nbsp;vectorLength,
                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Double&gt;&gt;&nbsp;feature,
                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;estimatedRating)</code>
<div class="block">Estimate rating can be used as a prediction algorithm for bipartite graphs</div>
</td>
</tr>
<tr id="i204" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#matrixFactorizationRecommendationsAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">matrixFactorizationRecommendationsAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                       <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;user,
                                       int&nbsp;vectorLength,
                                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Double&gt;&gt;&nbsp;feature,
                                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;estimatedRating)</code>
<div class="block">Estimate rating can be used as a prediction algorithm for bipartite graphs</div>
</td>
</tr>
<tr id="i205" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#outDegreeCentrality-oracle.pgx.api.PgxGraph-">outDegreeCentrality</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Out-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood</div>
</td>
</tr>
<tr id="i206" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#outDegreeCentrality-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">outDegreeCentrality</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;dc)</code>
<div class="block">Out-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood</div>
</td>
</tr>
<tr id="i207" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#outDegreeCentralityAsync-oracle.pgx.api.PgxGraph-">outDegreeCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Out-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood</div>
</td>
</tr>
<tr id="i208" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#outDegreeCentralityAsync-oracle.pgx.api.PgxGraph-java.lang.String-">outDegreeCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                        java.lang.String&nbsp;propertyName)</code>&nbsp;</td>
</tr>
<tr id="i209" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#outDegreeCentralityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">outDegreeCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;dc)</code>
<div class="block">Out-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood</div>
</td>
</tr>
<tr id="i210" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#outDegreeDistribution-oracle.pgx.api.PgxGraph-">outDegreeDistribution</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Out-degree distribution gives information about the outgoing flows in a graph</div>
</td>
</tr>
<tr id="i211" class="rowColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#outDegreeDistribution-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-">outDegreeDistribution</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&nbsp;distribution)</code>
<div class="block">Out-degree distribution gives information about the outgoing flows in a graph</div>
</td>
</tr>
<tr id="i212" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#outDegreeDistributionAsync-oracle.pgx.api.PgxGraph-">outDegreeDistributionAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Out-degree distribution gives information about the outgoing flows in a graph</div>
</td>
</tr>
<tr id="i213" class="rowColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#outDegreeDistributionAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-">outDegreeDistributionAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                          <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&nbsp;distribution)</code>
<div class="block">Out-degree distribution gives information about the outgoing flows in a graph</div>
</td>
</tr>
<tr id="i214" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerank-oracle.pgx.api.PgxGraph-">pagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i215" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerank-oracle.pgx.api.PgxGraph-boolean-">pagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
        boolean&nbsp;norm)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i216" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerank-oracle.pgx.api.PgxGraph-boolean-oracle.pgx.api.VertexProperty-">pagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
        boolean&nbsp;norm,
        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i217" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerank-oracle.pgx.api.PgxGraph-double-double-int-">pagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
        double&nbsp;e,
        double&nbsp;d,
        int&nbsp;max)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i218" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerank-oracle.pgx.api.PgxGraph-double-double-int-boolean-">pagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
        double&nbsp;e,
        double&nbsp;d,
        int&nbsp;max,
        boolean&nbsp;norm)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i219" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerank-oracle.pgx.api.PgxGraph-double-double-int-boolean-oracle.pgx.api.VertexProperty-">pagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
        double&nbsp;e,
        double&nbsp;d,
        int&nbsp;max,
        boolean&nbsp;norm,
        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i220" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerank-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.VertexProperty-">pagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
        double&nbsp;e,
        double&nbsp;d,
        int&nbsp;max,
        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i221" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">pagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i222" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankApproximate-oracle.pgx.api.PgxGraph-">pagerankApproximate</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Faster, but less accurate than pagerank.</div>
</td>
</tr>
<tr id="i223" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankApproximate-oracle.pgx.api.PgxGraph-double-double-int-">pagerankApproximate</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   double&nbsp;e,
                   double&nbsp;d,
                   int&nbsp;max)</code>
<div class="block">Faster, but less accurate than pagerank.</div>
</td>
</tr>
<tr id="i224" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankApproximate-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.VertexProperty-">pagerankApproximate</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   double&nbsp;e,
                   double&nbsp;d,
                   int&nbsp;max,
                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Faster, but less accurate than pagerank.</div>
</td>
</tr>
<tr id="i225" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankApproximate-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">pagerankApproximate</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Faster, but less accurate than pagerank.</div>
</td>
</tr>
<tr id="i226" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankApproximateAsync-oracle.pgx.api.PgxGraph-">pagerankApproximateAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Faster, but less accurate than pagerank.</div>
</td>
</tr>
<tr id="i227" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankApproximateAsync-oracle.pgx.api.PgxGraph-double-double-int-">pagerankApproximateAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                        double&nbsp;e,
                        double&nbsp;d,
                        int&nbsp;max)</code>
<div class="block">Faster, but less accurate than pagerank.</div>
</td>
</tr>
<tr id="i228" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankApproximateAsync-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.VertexProperty-">pagerankApproximateAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                        double&nbsp;e,
                        double&nbsp;d,
                        int&nbsp;max,
                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Faster, but less accurate than pagerank.</div>
</td>
</tr>
<tr id="i229" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankApproximateAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">pagerankApproximateAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Faster, but less accurate than pagerank.</div>
</td>
</tr>
<tr id="i230" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankAsync-oracle.pgx.api.PgxGraph-">pagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i231" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankAsync-oracle.pgx.api.PgxGraph-boolean-">pagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
             boolean&nbsp;norm)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i232" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankAsync-oracle.pgx.api.PgxGraph-boolean-oracle.pgx.api.VertexProperty-">pagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
             boolean&nbsp;norm,
             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i233" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-">pagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
             double&nbsp;e,
             double&nbsp;d,
             int&nbsp;max)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i234" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-boolean-">pagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
             double&nbsp;e,
             double&nbsp;d,
             int&nbsp;max,
             boolean&nbsp;norm)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i235" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-boolean-oracle.pgx.api.VertexProperty-">pagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
             double&nbsp;e,
             double&nbsp;d,
             int&nbsp;max,
             boolean&nbsp;norm,
             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i236" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.VertexProperty-">pagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
             double&nbsp;e,
             double&nbsp;d,
             int&nbsp;max,
             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i237" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">pagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank computes ranking scores based on the edges in a graph.</div>
</td>
</tr>
<tr id="i238" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;,<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#partitionConductance-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-">partitionConductance</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition)</code>
<div class="block">Partition conductance assesses the quality of many partitions in a graph</div>
</td>
</tr>
<tr id="i239" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;,<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#partitionConductance-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-oracle.pgx.api.Scalar-oracle.pgx.api.Scalar-">partitionConductance</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                    <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;avgConductance,
                    <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;minConductance)</code>
<div class="block">Partition conductance assesses the quality of many partitions in a graph</div>
</td>
</tr>
<tr id="i240" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;,<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#partitionConductanceAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-">partitionConductanceAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition)</code>
<div class="block">Partition conductance assesses the quality of many partitions in a graph</div>
</td>
</tr>
<tr id="i241" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;,<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#partitionConductanceAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-oracle.pgx.api.Scalar-oracle.pgx.api.Scalar-">partitionConductanceAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                         <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;avgConductance,
                         <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;minConductance)</code>
<div class="block">Partition conductance assesses the quality of many partitions in a graph</div>
</td>
</tr>
<tr id="i242" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#partitionModularity-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-">partitionModularity</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition)</code>
<div class="block">Modularity summarizes information about the quality of components in a graph</div>
</td>
</tr>
<tr id="i243" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#partitionModularity-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-oracle.pgx.api.Scalar-">partitionModularity</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                   <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;modularity)</code>
<div class="block">Modularity summarizes information about the quality of components in a graph</div>
</td>
</tr>
<tr id="i244" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#partitionModularityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-">partitionModularityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                        <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition)</code>
<div class="block">Modularity summarizes information about the quality of components in a graph</div>
</td>
</tr>
<tr id="i245" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#partitionModularityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-oracle.pgx.api.Scalar-">partitionModularityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                        <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                        <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;modularity)</code>
<div class="block">Modularity summarizes information about the quality of components in a graph</div>
</td>
</tr>
<tr id="i246" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#partitionModularityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-java.lang.String-">partitionModularityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                        <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                        java.lang.String&nbsp;modularityName)</code>&nbsp;</td>
</tr>
<tr id="i247" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#periphery-oracle.pgx.api.PgxGraph-">periphery</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph</div>
</td>
</tr>
<tr id="i248" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#periphery-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">periphery</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
         <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;periphery)</code>
<div class="block">Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph</div>
</td>
</tr>
<tr id="i249" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#peripheryAsync-oracle.pgx.api.PgxGraph-">peripheryAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph</div>
</td>
</tr>
<tr id="i250" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#peripheryAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">peripheryAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
              <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;periphery)</code>
<div class="block">Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph</div>
</td>
</tr>
<tr id="i251" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    ID&nbsp;vertexId,
                    java.math.BigDecimal&nbsp;e,
                    java.math.BigDecimal&nbsp;d,
                    int&nbsp;max)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-java.math.BigDecimal-java.math.BigDecimal-int-"><code>personalizedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int,)</code></a>
 taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i252" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-boolean-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    ID&nbsp;vertexId,
                    java.math.BigDecimal&nbsp;e,
                    java.math.BigDecimal&nbsp;d,
                    int&nbsp;max,
                    boolean&nbsp;norm)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-java.math.BigDecimal-java.math.BigDecimal-int-boolean-"><code>personalizedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int,
 boolean)</code></a> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i253" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-boolean-oracle.pgx.api.VertexProperty-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    ID&nbsp;vertexId,
                    java.math.BigDecimal&nbsp;e,
                    java.math.BigDecimal&nbsp;d,
                    int&nbsp;max,
                    boolean&nbsp;norm,
                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Convenience wrapper around
 <code>#personalizedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int, boolean,
 VertexProperty<ID, Double>)</code> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i254" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-oracle.pgx.api.VertexProperty-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    ID&nbsp;vertexId,
                    java.math.BigDecimal&nbsp;e,
                    java.math.BigDecimal&nbsp;d,
                    int&nbsp;max,
                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Convenience wrapper around <code>#personalizedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int,
 VertexProperty<ID, Double>)</code> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i255" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i256" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                    boolean&nbsp;norm)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i257" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-oracle.pgx.api.VertexProperty-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                    boolean&nbsp;norm,
                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i258" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                    double&nbsp;e,
                    double&nbsp;d,
                    int&nbsp;max)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i259" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                    double&nbsp;e,
                    double&nbsp;d,
                    int&nbsp;max,
                    boolean&nbsp;norm)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i260" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-oracle.pgx.api.VertexProperty-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                    double&nbsp;e,
                    double&nbsp;d,
                    int&nbsp;max,
                    boolean&nbsp;norm,
                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i261" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-oracle.pgx.api.VertexProperty-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                    double&nbsp;e,
                    double&nbsp;d,
                    int&nbsp;max,
                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i262" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i263" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i264" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                    boolean&nbsp;norm)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i265" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-oracle.pgx.api.VertexProperty-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                    boolean&nbsp;norm,
                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i266" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                    double&nbsp;e,
                    double&nbsp;d,
                    int&nbsp;max)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i267" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                    double&nbsp;e,
                    double&nbsp;d,
                    int&nbsp;max,
                    boolean&nbsp;norm)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i268" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-oracle.pgx.api.VertexProperty-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                    double&nbsp;e,
                    double&nbsp;d,
                    int&nbsp;max,
                    boolean&nbsp;norm,
                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i269" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-oracle.pgx.api.VertexProperty-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                    double&nbsp;e,
                    double&nbsp;d,
                    int&nbsp;max,
                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i270" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">personalizedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i271" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i272" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                         boolean&nbsp;norm)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i273" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-oracle.pgx.api.VertexProperty-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                         boolean&nbsp;norm,
                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i274" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                         double&nbsp;e,
                         double&nbsp;d,
                         int&nbsp;max)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i275" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                         double&nbsp;e,
                         double&nbsp;d,
                         int&nbsp;max,
                         boolean&nbsp;norm)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i276" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-oracle.pgx.api.VertexProperty-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                         double&nbsp;e,
                         double&nbsp;d,
                         int&nbsp;max,
                         boolean&nbsp;norm,
                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i277" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-oracle.pgx.api.VertexProperty-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                         double&nbsp;e,
                         double&nbsp;d,
                         int&nbsp;max,
                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i278" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a vertex of interest.</div>
</td>
</tr>
<tr id="i279" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i280" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                         boolean&nbsp;norm)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i281" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-oracle.pgx.api.VertexProperty-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                         boolean&nbsp;norm,
                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i282" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                         double&nbsp;e,
                         double&nbsp;d,
                         int&nbsp;max)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i283" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                         double&nbsp;e,
                         double&nbsp;d,
                         int&nbsp;max,
                         boolean&nbsp;norm)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i284" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-oracle.pgx.api.VertexProperty-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                         double&nbsp;e,
                         double&nbsp;d,
                         int&nbsp;max,
                         boolean&nbsp;norm,
                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i285" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-oracle.pgx.api.VertexProperty-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                         double&nbsp;e,
                         double&nbsp;d,
                         int&nbsp;max,
                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i286" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">personalizedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized PageRank for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i287" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsa-oracle.pgx.api.BipartiteGraph-ID-java.math.BigDecimal-int-java.math.BigDecimal-">personalizedSalsa</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                 ID&nbsp;v,
                 java.math.BigDecimal&nbsp;d,
                 int&nbsp;maxIterations,
                 java.math.BigDecimal&nbsp;maxDiff)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-java.math.BigDecimal-int-java.math.BigDecimal-"><code>personalizedSalsa(BipartiteGraph, PgxVertex, BigDecimal, int, BigDecimal)</code></a>
 taking a vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i288" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsa-oracle.pgx.api.BipartiteGraph-ID-java.math.BigDecimal-int-java.math.BigDecimal-oracle.pgx.api.VertexProperty-">personalizedSalsa</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                 ID&nbsp;v,
                 java.math.BigDecimal&nbsp;d,
                 int&nbsp;maxIterations,
                 java.math.BigDecimal&nbsp;maxDiff,
                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</code>
<div class="block">Convenience wrapper around
 <code>#personalizedSalsa(BipartiteGraph, PgxVertex, BigDecimal, int, BigDecimal, VertexProperty<ID, Double>)</code>
 taking a vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i289" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-">personalizedSalsa</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v)</code>
<div class="block">Personalized salsa for a vertex of interest.</div>
</td>
</tr>
<tr id="i290" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-double-int-double-">personalizedSalsa</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                 double&nbsp;d,
                 int&nbsp;maxIter,
                 double&nbsp;maxDiff)</code>
<div class="block">Personalized salsa for a vertex of interest.</div>
</td>
</tr>
<tr id="i291" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-double-int-double-oracle.pgx.api.VertexProperty-">personalizedSalsa</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                 double&nbsp;d,
                 int&nbsp;maxIter,
                 double&nbsp;maxDiff,
                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</code>
<div class="block">Personalized salsa for a vertex of interest.</div>
</td>
</tr>
<tr id="i292" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-">personalizedSalsa</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</code>
<div class="block">Personalized salsa for a vertex of interest.</div>
</td>
</tr>
<tr id="i293" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-">personalizedSalsa</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices)</code>
<div class="block">Personalized salsa for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i294" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-double-int-double-">personalizedSalsa</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                 double&nbsp;d,
                 int&nbsp;maxIter,
                 double&nbsp;maxDiff)</code>
<div class="block">Personalized salsa for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i295" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-double-int-double-oracle.pgx.api.VertexProperty-">personalizedSalsa</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                 double&nbsp;d,
                 int&nbsp;maxIter,
                 double&nbsp;maxDiff,
                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</code>
<div class="block">Personalized salsa for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i296" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">personalizedSalsa</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</code>
<div class="block">Personalized salsa for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i297" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-">personalizedSalsaAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                      <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v)</code>
<div class="block">Personalized salsa for a vertex of interest.</div>
</td>
</tr>
<tr id="i298" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-double-int-double-">personalizedSalsaAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                      <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                      double&nbsp;d,
                      int&nbsp;maxIter,
                      double&nbsp;maxDiff)</code>
<div class="block">Personalized salsa for a vertex of interest.</div>
</td>
</tr>
<tr id="i299" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-double-int-double-oracle.pgx.api.VertexProperty-">personalizedSalsaAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                      <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                      double&nbsp;d,
                      int&nbsp;maxIter,
                      double&nbsp;maxDiff,
                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</code>
<div class="block">Personalized salsa for a vertex of interest.</div>
</td>
</tr>
<tr id="i300" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-">personalizedSalsaAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                      <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</code>
<div class="block">Personalized salsa for a vertex of interest.</div>
</td>
</tr>
<tr id="i301" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-">personalizedSalsaAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                      <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices)</code>
<div class="block">Personalized salsa for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i302" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-double-int-double-">personalizedSalsaAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                      <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                      double&nbsp;d,
                      int&nbsp;maxIter,
                      double&nbsp;maxDiff)</code>
<div class="block">Personalized salsa for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i303" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-double-int-double-oracle.pgx.api.VertexProperty-">personalizedSalsaAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                      <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                      double&nbsp;d,
                      int&nbsp;maxIter,
                      double&nbsp;maxDiff,
                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</code>
<div class="block">Personalized salsa for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i304" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">personalizedSalsaAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                      <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</code>
<div class="block">Personalized salsa for a set of vertices of interest.</div>
</td>
</tr>
<tr id="i305" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-boolean-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            ID&nbsp;vertexId,
                            java.math.BigDecimal&nbsp;e,
                            java.math.BigDecimal&nbsp;d,
                            int&nbsp;max,
                            boolean&nbsp;norm,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-java.math.BigDecimal-java.math.BigDecimal-int-boolean-oracle.pgx.api.EdgeProperty-"><code>personalizedWeightedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int,
 boolean, EdgeProperty)</code></a> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i306" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            ID&nbsp;vertexId,
                            java.math.BigDecimal&nbsp;e,
                            java.math.BigDecimal&nbsp;d,
                            int&nbsp;max,
                            boolean&nbsp;norm,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Convenience wrapper around
 <code>#personalizedWeightedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int, boolean, EdgeProperty,
 VertexProperty<ID, Double>)</code> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i307" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            ID&nbsp;vertexId,
                            java.math.BigDecimal&nbsp;e,
                            java.math.BigDecimal&nbsp;d,
                            int&nbsp;max,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-java.math.BigDecimal-java.math.BigDecimal-int-oracle.pgx.api.EdgeProperty-"><code>personalizedWeightedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int,
 EdgeProperty)</code></a> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i308" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            ID&nbsp;vertexId,
                            java.math.BigDecimal&nbsp;e,
                            java.math.BigDecimal&nbsp;d,
                            int&nbsp;max,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Convenience wrapper around
 <code>#personalizedWeightedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int, EdgeProperty,
 VertexProperty<ID, Double>)</code> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i309" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                            boolean&nbsp;norm,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i310" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                            boolean&nbsp;norm,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i311" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                            double&nbsp;e,
                            double&nbsp;d,
                            int&nbsp;max,
                            boolean&nbsp;norm,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i312" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                            double&nbsp;e,
                            double&nbsp;d,
                            int&nbsp;max,
                            boolean&nbsp;norm,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i313" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                            double&nbsp;e,
                            double&nbsp;d,
                            int&nbsp;max,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i314" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                            double&nbsp;e,
                            double&nbsp;d,
                            int&nbsp;max,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i315" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i316" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i317" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                            boolean&nbsp;norm,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i318" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                            boolean&nbsp;norm,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i319" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                            double&nbsp;e,
                            double&nbsp;d,
                            int&nbsp;max,
                            boolean&nbsp;norm,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i320" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                            double&nbsp;e,
                            double&nbsp;d,
                            int&nbsp;max,
                            boolean&nbsp;norm,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i321" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                            double&nbsp;e,
                            double&nbsp;d,
                            int&nbsp;max,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i322" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                            double&nbsp;e,
                            double&nbsp;d,
                            int&nbsp;max,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i323" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i324" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i325" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                 boolean&nbsp;norm,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i326" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                 boolean&nbsp;norm,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i327" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                 double&nbsp;e,
                                 double&nbsp;d,
                                 int&nbsp;max,
                                 boolean&nbsp;norm,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i328" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                 double&nbsp;e,
                                 double&nbsp;d,
                                 int&nbsp;max,
                                 boolean&nbsp;norm,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i329" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                 double&nbsp;e,
                                 double&nbsp;d,
                                 int&nbsp;max,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i330" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                 double&nbsp;e,
                                 double&nbsp;d,
                                 int&nbsp;max,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i331" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i332" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized weighted pagerank for a vertex and weighted edges.</div>
</td>
</tr>
<tr id="i333" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                 boolean&nbsp;norm,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i334" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                 boolean&nbsp;norm,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i335" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                 double&nbsp;e,
                                 double&nbsp;d,
                                 int&nbsp;max,
                                 boolean&nbsp;norm,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i336" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                 double&nbsp;e,
                                 double&nbsp;d,
                                 int&nbsp;max,
                                 boolean&nbsp;norm,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i337" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                 double&nbsp;e,
                                 double&nbsp;d,
                                 int&nbsp;max,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i338" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                 double&nbsp;e,
                                 double&nbsp;d,
                                 int&nbsp;max,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i339" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.EdgeProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i340" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">personalizedWeightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">Personalized pagerank for a set of vertices and weighted edges.</div>
</td>
</tr>
<tr id="i341" class="rowColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/mllib/Pg2vecModelBuilder.html" title="class in oracle.pgx.api.mllib">Pg2vecModelBuilder</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#pg2vecModelBuilder--">pg2vecModelBuilder</a></span>()</code>
<div class="block">Builds a pg2vec model</div>
</td>
</tr>
<tr id="i342" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Boolean&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#prim-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">prim</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
    <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">prim reveals tree structures with shortest paths in a graph</div>
</td>
</tr>
<tr id="i343" class="rowColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Boolean&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#prim-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.EdgeProperty-">prim</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
    <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
    <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Boolean&gt;&nbsp;mst)</code>
<div class="block">prim reveals tree structures with shortest paths in a graph</div>
</td>
</tr>
<tr id="i344" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Boolean&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#prim-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-java.lang.String-">prim</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
    <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
    java.lang.String&nbsp;mstName)</code>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#prim-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-java.lang.String-"><code>prim(PgxGraph, EdgeProperty, String)</code></a></div>
</td>
</tr>
<tr id="i345" class="rowColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Boolean&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#primAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">primAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
         <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">prim reveals tree structures with shortest paths in a graph</div>
</td>
</tr>
<tr id="i346" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Boolean&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#primAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.EdgeProperty-">primAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
         <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
         <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Boolean&gt;&nbsp;mst)</code>
<div class="block">prim reveals tree structures with shortest paths in a graph</div>
</td>
</tr>
<tr id="i347" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#radius-oracle.pgx.api.PgxGraph-">radius</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Diameter/radius gives an overview of the distances in a graph</div>
</td>
</tr>
<tr id="i348" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#radius-oracle.pgx.api.PgxGraph-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">radius</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
      <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;&nbsp;radius,
      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;eccentricity)</code>
<div class="block">Diameter/radius gives an overview of the distances in a graph</div>
</td>
</tr>
<tr id="i349" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#radiusAsync-oracle.pgx.api.PgxGraph-">radiusAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Diameter/radius gives an overview of the distances in a graph</div>
</td>
</tr>
<tr id="i350" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#radiusAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">radiusAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;&nbsp;radius,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;eccentricity)</code>
<div class="block">Diameter/radius gives an overview of the distances in a graph</div>
</td>
</tr>
<tr id="i351" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#randomWalkWithRestart-oracle.pgx.api.PgxGraph-ID-int-java.math.BigDecimal-oracle.pgx.api.PgxMap-">randomWalkWithRestart</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     ID&nbsp;source,
                     int&nbsp;length,
                     java.math.BigDecimal&nbsp;resetProb,
                     <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&nbsp;visitCount)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#randomWalkWithRestart-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-double-oracle.pgx.api.PgxMap-"><code>randomWalkWithRestart(PgxGraph, PgxVertex, int, double,
 PgxMap)</code></a> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i352" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#randomWalkWithRestart-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-double-oracle.pgx.api.PgxMap-">randomWalkWithRestart</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;source,
                     int&nbsp;length,
                     double&nbsp;resetProb,
                     <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&nbsp;visitCount)</code>
<div class="block">random walk with restart does the what its name says, it can find approximate stationary distributions</div>
</td>
</tr>
<tr id="i353" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#randomWalkWithRestartAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-double-oracle.pgx.api.PgxMap-">randomWalkWithRestartAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;source,
                          int&nbsp;length,
                          double&nbsp;resetProb,
                          <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&nbsp;visitCount)</code>
<div class="block">random walk with restart does the what its name says, it can find approximate stationary distributions</div>
</td>
</tr>
<tr id="i354" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;java.lang.Integer</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#reachability-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-boolean-">reachability</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;source,
            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dest,
            int&nbsp;maxHops,
            boolean&nbsp;ignoreEdgeDirection)</code>
<div class="block">Reachability is a fast way to check if two vertices are reachable from each other.</div>
</td>
</tr>
<tr id="i355" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#reachabilityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-boolean-">reachabilityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;source,
                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dest,
                 int&nbsp;maxHops,
                 boolean&nbsp;ignoreEdgeDirection)</code>
<div class="block">Reachability is a fast way to check if two vertices are reachable from each other.</div>
</td>
</tr>
<tr id="i356" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#salsa-oracle.pgx.api.BipartiteGraph-">salsa</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph)</code>
<div class="block">SALSA computes ranking scores.</div>
</td>
</tr>
<tr id="i357" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#salsa-oracle.pgx.api.BipartiteGraph-double-int-">salsa</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
     double&nbsp;maxDiff,
     int&nbsp;maxIter)</code>
<div class="block">SALSA computes ranking scores.</div>
</td>
</tr>
<tr id="i358" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#salsa-oracle.pgx.api.BipartiteGraph-double-int-oracle.pgx.api.VertexProperty-">salsa</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
     double&nbsp;maxDiff,
     int&nbsp;maxIter,
     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</code>
<div class="block">SALSA computes ranking scores.</div>
</td>
</tr>
<tr id="i359" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#salsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexProperty-">salsa</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</code>
<div class="block">SALSA computes ranking scores.</div>
</td>
</tr>
<tr id="i360" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#salsaAsync-oracle.pgx.api.BipartiteGraph-">salsaAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph)</code>
<div class="block">SALSA computes ranking scores.</div>
</td>
</tr>
<tr id="i361" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#salsaAsync-oracle.pgx.api.BipartiteGraph-double-int-">salsaAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
          double&nbsp;maxDiff,
          int&nbsp;maxIter)</code>
<div class="block">SALSA computes ranking scores.</div>
</td>
</tr>
<tr id="i362" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#salsaAsync-oracle.pgx.api.BipartiteGraph-double-int-oracle.pgx.api.VertexProperty-">salsaAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
          double&nbsp;maxDiff,
          int&nbsp;maxIter,
          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</code>
<div class="block">SALSA computes ranking scores.</div>
</td>
</tr>
<tr id="i363" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#salsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexProperty-">salsaAsync</a></span>(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</code>
<div class="block">SALSA computes ranking scores.</div>
</td>
</tr>
<tr id="i364" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#sccKosaraju-oracle.pgx.api.PgxGraph-">sccKosaraju</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Kosaraju finds strongly connected components in a graph</div>
</td>
</tr>
<tr id="i365" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#sccKosaraju-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">sccKosaraju</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</code>
<div class="block">Kosaraju finds strongly connected components in a graph</div>
</td>
</tr>
<tr id="i366" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#sccKosarajuAsync-oracle.pgx.api.PgxGraph-">sccKosarajuAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Kosaraju finds strongly connected components in a graph</div>
</td>
</tr>
<tr id="i367" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#sccKosarajuAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">sccKosarajuAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</code>
<div class="block">Kosaraju finds strongly connected components in a graph</div>
</td>
</tr>
<tr id="i368" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#sccTarjan-oracle.pgx.api.PgxGraph-">sccTarjan</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Tarjan finds strongly connected components in a graph</div>
</td>
</tr>
<tr id="i369" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#sccTarjan-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">sccTarjan</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</code>
<div class="block">Tarjan finds strongly connected components in a graph</div>
</td>
</tr>
<tr id="i370" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#sccTarjanAsync-oracle.pgx.api.PgxGraph-">sccTarjanAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Tarjan finds strongly connected components in a graph</div>
</td>
</tr>
<tr id="i371" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#sccTarjanAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">sccTarjanAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitonDistribution)</code>
<div class="block">Tarjan finds strongly connected components in a graph</div>
</td>
</tr>
<tr id="i372" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFord-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.EdgeProperty-">shortestPathBellmanFord</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                       ID&nbsp;srcId,
                       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFord-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-"><code>shortestPathBellmanFord(PgxGraph, PgxVertex, EdgeProperty)</code></a> taking a vertex ID
 instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i373" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFord-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathBellmanFord</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                       ID&nbsp;srcId,
                       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFord-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-"><code>shortestPathBellmanFord(PgxGraph, PgxVertex, EdgeProperty, VertexProperty,
 VertexProperty, VertexProperty)</code></a> taking a vertex ID
 instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i374" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFord-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">shortestPathBellmanFord</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                       <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</code>
<div class="block">Bellman-ford finds multiple shortest paths at the same time</div>
</td>
</tr>
<tr id="i375" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFord-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathBellmanFord</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                       <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                       <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Bellman-ford finds multiple shortest paths at the same time</div>
</td>
</tr>
<tr id="i376" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFordAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">shortestPathBellmanFordAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</code>
<div class="block">Bellman-ford finds multiple shortest paths at the same time</div>
</td>
</tr>
<tr id="i377" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFordAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathBellmanFordAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Bellman-ford finds multiple shortest paths at the same time</div>
</td>
</tr>
<tr id="i378" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFordReverse-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.EdgeProperty-">shortestPathBellmanFordReverse</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                              ID&nbsp;srcId,
                              <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFordReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-"><code>shortestPathBellmanFordReverse(PgxGraph, PgxVertex, EdgeProperty)</code></a> taking a
 vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i379" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFordReverse-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathBellmanFordReverse</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                              ID&nbsp;srcId,
                              <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFordReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-"><code>shortestPathBellmanFordReverse(PgxGraph, PgxVertex, EdgeProperty,
 VertexProperty, VertexProperty, VertexProperty)</code></a> taking a
 vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i380" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFordReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">shortestPathBellmanFordReverse</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                              <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                              <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</code>
<div class="block">Reversed bellman-ford finds multiple shortest paths at the same time</div>
</td>
</tr>
<tr id="i381" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFordReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathBellmanFordReverse</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                              <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                              <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Reversed bellman-ford finds multiple shortest paths at the same time</div>
</td>
</tr>
<tr id="i382" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFordReverseAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">shortestPathBellmanFordReverseAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                   <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                   <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</code>
<div class="block">Reversed bellman-ford finds multiple shortest paths at the same time</div>
</td>
</tr>
<tr id="i383" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFordReverseAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathBellmanFordReverseAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                   <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                   <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Reversed bellman-ford finds multiple shortest paths at the same time</div>
</td>
</tr>
<tr id="i384" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstra-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-">shortestPathDijkstra</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    ID&nbsp;srcId,
                    ID&nbsp;dstId,
                    <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-"><code>shortestPathDijkstra(PgxGraph, PgxVertex, PgxVertex, EdgeProperty)</code></a> taking
 vertex IDs instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i385" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstra-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathDijkstra</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    ID&nbsp;srcId,
                    ID&nbsp;dstId,
                    <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-"><code>shortestPathDijkstra(PgxGraph, PgxVertex, PgxVertex, EdgeProperty)</code></a> taking
 vertex IDs instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i386" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">shortestPathDijkstra</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                    <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</code>
<div class="block">Dijkstra is a fast algorithm for finding a shortest path in a graph</div>
</td>
</tr>
<tr id="i387" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathDijkstra</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                    <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Dijkstra is a fast algorithm for finding a shortest path in a graph</div>
</td>
</tr>
<tr id="i388" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstraAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">shortestPathDijkstraAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                         <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</code>
<div class="block">Dijkstra is a fast algorithm for finding a shortest path in a graph</div>
</td>
</tr>
<tr id="i389" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstraAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathDijkstraAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                         <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Dijkstra is a fast algorithm for finding a shortest path in a graph</div>
</td>
</tr>
<tr id="i390" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstraBidirectional-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-">shortestPathDijkstraBidirectional</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 ID&nbsp;srcId,
                                 ID&nbsp;dstId,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-"><code>shortestPathDijkstraBidirectional(PgxGraph, PgxVertex, PgxVertex, EdgeProperty)</code></a>
 taking vertex IDs instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i391" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstraBidirectional-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathDijkstraBidirectional</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 ID&nbsp;srcId,
                                 ID&nbsp;dstId,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-"><code>shortestPathDijkstraBidirectional(PgxGraph, PgxVertex, PgxVertex, EdgeProperty)</code></a>
 taking vertex IDs instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i392" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">shortestPathDijkstraBidirectional</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</code>
<div class="block">Bidirectional dijkstra is a fast algorithm for finding a shortest path in a graph</div>
</td>
</tr>
<tr id="i393" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathDijkstraBidirectional</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Bidirectional dijkstra is a fast algorithm for finding a shortest path in a graph</div>
</td>
</tr>
<tr id="i394" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstraBidirectionalAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">shortestPathDijkstraBidirectionalAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                      <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                      <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                      <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</code>
<div class="block">Bidirectional dijkstra is a fast algorithm for finding a shortest path in a graph</div>
</td>
</tr>
<tr id="i395" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstraBidirectionalAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-java.lang.String-java.lang.String-">shortestPathDijkstraBidirectionalAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                      <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                      <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                      <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                      java.lang.String&nbsp;parentName,
                                      java.lang.String&nbsp;parentEdgeName)</code>&nbsp;</td>
</tr>
<tr id="i396" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstraBidirectionalAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathDijkstraBidirectionalAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                      <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                      <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                      <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Bidirectional dijkstra is a fast algorithm for finding a shortest path in a graph</div>
</td>
</tr>
<tr id="i397" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstra-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-">shortestPathFilteredDijkstra</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            ID&nbsp;srcId,
                            ID&nbsp;dstId,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                            <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr)</code>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-"><code>shortestPathFilteredDijkstra(PgxGraph, PgxVertex, PgxVertex, EdgeProperty, GraphFilter)</code></a> taking vertex IDs
 instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i398" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstra-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathFilteredDijkstra</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            ID&nbsp;srcId,
                            ID&nbsp;dstId,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                            <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-"><code>shortestPathFilteredDijkstra(PgxGraph, PgxVertex, PgxVertex, EdgeProperty, GraphFilter)</code></a> taking vertex IDs
 instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i399" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-">shortestPathFilteredDijkstra</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                            <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr)</code>
<div class="block">Filtered Dijkstra is a fast algorithm for finding a shortest path while also filtering edges</div>
</td>
</tr>
<tr id="i400" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathFilteredDijkstra</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                            <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Filtered Dijkstra is a fast algorithm for finding a shortest path while also filtering edges</div>
</td>
</tr>
<tr id="i401" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstraAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-">shortestPathFilteredDijkstraAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                 <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr)</code>
<div class="block">Filtered Dijkstra is a fast algorithm for finding a shortest path while also filtering edges</div>
</td>
</tr>
<tr id="i402" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstraAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathFilteredDijkstraAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                 <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr,
                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Filtered Dijkstra is a fast algorithm for finding a shortest path while also filtering edges</div>
</td>
</tr>
<tr id="i403" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstraBidirectional-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-">shortestPathFilteredDijkstraBidirectional</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                         ID&nbsp;srcId,
                                         ID&nbsp;dstId,
                                         <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                         <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr)</code>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-"><code>shortestPathFilteredDijkstraBidirectional(PgxGraph, PgxVertex, PgxVertex, EdgeProperty, GraphFilter)</code></a>
 taking vertex IDs instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i404" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstraBidirectional-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathFilteredDijkstraBidirectional</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                         ID&nbsp;srcId,
                                         ID&nbsp;dstId,
                                         <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                         <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr,
                                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-"><code>shortestPathFilteredDijkstraBidirectional(PgxGraph, PgxVertex, PgxVertex, EdgeProperty, GraphFilter)</code></a>
 taking vertex IDs instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i405" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-">shortestPathFilteredDijkstraBidirectional</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                         <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                         <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr)</code>
<div class="block">Bidirectional dijkstra is a fast algorithm for finding a shortest path while also filtering edges</div>
</td>
</tr>
<tr id="i406" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathFilteredDijkstraBidirectional</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                         <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                         <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                         <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr,
                                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Bidirectional dijkstra is a fast algorithm for finding a shortest path while also filtering edges</div>
</td>
</tr>
<tr id="i407" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstraBidirectionalAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-">shortestPathFilteredDijkstraBidirectionalAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                              <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                              <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                              <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                              <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr)</code>
<div class="block">Bidirectional dijkstra is a fast algorithm for finding a shortest path while also filtering edges</div>
</td>
</tr>
<tr id="i408" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstraBidirectionalAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-java.lang.String-java.lang.String-">shortestPathFilteredDijkstraBidirectionalAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                              <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                              <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                              <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                              <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr,
                                              java.lang.String&nbsp;parentName,
                                              java.lang.String&nbsp;parentEdgeName)</code>&nbsp;</td>
</tr>
<tr id="i409" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstraBidirectionalAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathFilteredDijkstraBidirectionalAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                              <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                              <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                              <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                              <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr,
                                              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Bidirectional dijkstra is a fast algorithm for finding a shortest path while also filtering edges</div>
</td>
</tr>
<tr id="i410" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDist-oracle.pgx.api.PgxGraph-ID-">shortestPathHopDist</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   ID&nbsp;srcId)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDist-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-"><code>shortestPathHopDist(PgxGraph, PgxVertex)</code></a> taking a vertex ID instead of
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i411" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDist-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathHopDist</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   ID&nbsp;srcId,
                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDist-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-"><code>shortestPathHopDist(PgxGraph, PgxVertex, VertexProperty, VertexProperty,
 VertexProperty)</code></a> taking a vertex ID instead of
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i412" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDist-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">shortestPathHopDist</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src)</code>
<div class="block">Hop distance can give a relatively fast insight on the distances in a graph</div>
</td>
</tr>
<tr id="i413" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDist-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathHopDist</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Hop distance can give a relatively fast insight on the distances in a graph</div>
</td>
</tr>
<tr id="i414" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDistAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">shortestPathHopDistAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                        <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src)</code>
<div class="block">Hop distance can give a relatively fast insight on the distances in a graph</div>
</td>
</tr>
<tr id="i415" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDistAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathHopDistAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                        <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Hop distance can give a relatively fast insight on the distances in a graph</div>
</td>
</tr>
<tr id="i416" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDistReverse-oracle.pgx.api.PgxGraph-ID-">shortestPathHopDistReverse</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                          ID&nbsp;srcId)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDistReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-"><code>shortestPathHopDistReverse(PgxGraph, PgxVertex)</code></a> taking a vertex ID instead of
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i417" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDistReverse-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathHopDistReverse</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                          ID&nbsp;srcId,
                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDistReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-"><code>shortestPathHopDistReverse(PgxGraph, PgxVertex, VertexProperty, VertexProperty,
 VertexProperty)</code></a> taking a vertex ID instead of
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i418" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDistReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">shortestPathHopDistReverse</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src)</code>
<div class="block">Backwards hop distance can give a relatively fast insight on the distances in a graph</div>
</td>
</tr>
<tr id="i419" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDistReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathHopDistReverse</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Backwards hop distance can give a relatively fast insight on the distances in a graph</div>
</td>
</tr>
<tr id="i420" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDistReverseAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">shortestPathHopDistReverseAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                               <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src)</code>
<div class="block">Backwards hop distance can give a relatively fast insight on the distances in a graph</div>
</td>
</tr>
<tr id="i421" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDistReverseAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">shortestPathHopDistReverseAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                               <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</code>
<div class="block">Backwards hop distance can give a relatively fast insight on the distances in a graph</div>
</td>
</tr>
<tr id="i422" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/mllib/SupervisedGraphWiseModelBuilder.html" title="class in oracle.pgx.api.mllib">SupervisedGraphWiseModelBuilder</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#supervisedGraphWiseModelBuilder--">supervisedGraphWiseModelBuilder</a></span>()</code>
<div class="block">Return a SupervisedGraphWise model builder that can be used to set the configuration of the model and then create
 it.</div>
</td>
</tr>
<tr id="i423" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#topologicalSchedule-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">topologicalSchedule</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;source)</code>
<div class="block">Topological schedule gives an order of visit for the reachable vertices from the source</div>
</td>
</tr>
<tr id="i424" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#topologicalSchedule-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">topologicalSchedule</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                   <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;source,
                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;topoSched)</code>
<div class="block">Topological sort gives an order of visit for vertices in directed acyclic graphs</div>
</td>
</tr>
<tr id="i425" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#topologicalScheduleAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">topologicalScheduleAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                        <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;source)</code>
<div class="block">Topological schedule gives an order of visit for the reachable vertices from the source</div>
</td>
</tr>
<tr id="i426" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#topologicalScheduleAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">topologicalScheduleAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                        <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;source,
                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;topoSched)</code>
<div class="block">Topological schedule gives an order of visit for the reachable vertices from the source</div>
</td>
</tr>
<tr id="i427" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#topologicalSort-oracle.pgx.api.PgxGraph-">topologicalSort</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Topological sort gives an order of visit for vertices in directed acyclic graphs</div>
</td>
</tr>
<tr id="i428" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#topologicalSort-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">topologicalSort</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;topoSort)</code>
<div class="block">Topological sort gives an order of visit for vertices in directed acyclic graphs</div>
</td>
</tr>
<tr id="i429" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#topologicalSortAsync-oracle.pgx.api.PgxGraph-">topologicalSortAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Topological sort gives an order of visit for vertices in directed acyclic graphs</div>
</td>
</tr>
<tr id="i430" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#topologicalSortAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">topologicalSortAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;topoSort)</code>
<div class="block">Topological sort gives an order of visit for vertices in directed acyclic graphs</div>
</td>
</tr>
<tr id="i431" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#toString--">toString</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i432" class="altColor">
<td class="colFirst"><code><a href="../../../oracle/pgx/api/mllib/UnsupervisedGraphWiseModelBuilder.html" title="class in oracle.pgx.api.mllib">UnsupervisedGraphWiseModelBuilder</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#unsupervisedGraphWiseModelBuilder--">unsupervisedGraphWiseModelBuilder</a></span>()</code>
<div class="block">Return a UnsupervisedGraphWise model builder that can be used to set the configuration of the model and then create
 it.</div>
</td>
</tr>
<tr id="i433" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#vertexBetweennessCentrality-oracle.pgx.api.PgxGraph-">vertexBetweennessCentrality</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Betweenness centrality measures the centrality of the vertices to identify important vertices for the flow of information</div>
</td>
</tr>
<tr id="i434" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#vertexBetweennessCentrality-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">vertexBetweennessCentrality</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;bc)</code>
<div class="block">Betweenness centrality measures the centrality of the vertices to identify important vertices for the flow of information</div>
</td>
</tr>
<tr id="i435" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#vertexBetweennessCentralityAsync-oracle.pgx.api.PgxGraph-">vertexBetweennessCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Betweenness centrality measures the centrality of the vertices to identify important vertices for the flow of information</div>
</td>
</tr>
<tr id="i436" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#vertexBetweennessCentralityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">vertexBetweennessCentralityAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;bc)</code>
<div class="block">Betweenness centrality measures the centrality of the vertices to identify important vertices for the flow of information</div>
</td>
</tr>
<tr id="i437" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#wcc-oracle.pgx.api.PgxGraph-">wcc</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Identifying weakly connected components can be useful for clustering graph data</div>
</td>
</tr>
<tr id="i438" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#wcc-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">wcc</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</code>
<div class="block">Identifying weakly connected components can be useful for clustering graph data</div>
</td>
</tr>
<tr id="i439" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#wccAsync-oracle.pgx.api.PgxGraph-">wccAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</code>
<div class="block">Identifying weakly connected components can be useful for clustering graph data</div>
</td>
</tr>
<tr id="i440" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#wccAsync-oracle.pgx.api.PgxGraph-java.lang.String-">wccAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
        java.lang.String&nbsp;partitonDistributionName)</code>&nbsp;</td>
</tr>
<tr id="i441" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#wccAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">wccAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</code>
<div class="block">Identifying weakly connected components can be useful for clustering graph data</div>
</td>
</tr>
<tr id="i442" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerank-oracle.pgx.api.PgxGraph-boolean-oracle.pgx.api.EdgeProperty-">weightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                boolean&nbsp;norm,
                <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i443" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerank-oracle.pgx.api.PgxGraph-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">weightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                boolean&nbsp;norm,
                <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i444" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerank-oracle.pgx.api.PgxGraph-double-double-int-boolean-oracle.pgx.api.EdgeProperty-">weightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                double&nbsp;e,
                double&nbsp;d,
                int&nbsp;max,
                boolean&nbsp;norm,
                <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i445" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerank-oracle.pgx.api.PgxGraph-double-double-int-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">weightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                double&nbsp;e,
                double&nbsp;d,
                int&nbsp;max,
                boolean&nbsp;norm,
                <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i446" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerank-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.EdgeProperty-">weightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                double&nbsp;e,
                double&nbsp;d,
                int&nbsp;max,
                <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i447" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerank-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">weightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                double&nbsp;e,
                double&nbsp;d,
                int&nbsp;max,
                <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i448" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">weightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i449" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">weightedPagerank</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i450" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerankAsync-oracle.pgx.api.PgxGraph-boolean-oracle.pgx.api.EdgeProperty-">weightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     boolean&nbsp;norm,
                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i451" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerankAsync-oracle.pgx.api.PgxGraph-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">weightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     boolean&nbsp;norm,
                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i452" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-boolean-oracle.pgx.api.EdgeProperty-">weightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     double&nbsp;e,
                     double&nbsp;d,
                     int&nbsp;max,
                     boolean&nbsp;norm,
                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i453" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">weightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     double&nbsp;e,
                     double&nbsp;d,
                     int&nbsp;max,
                     boolean&nbsp;norm,
                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i454" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.EdgeProperty-">weightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     double&nbsp;e,
                     double&nbsp;d,
                     int&nbsp;max,
                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i455" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">weightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     double&nbsp;e,
                     double&nbsp;d,
                     int&nbsp;max,
                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i456" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">weightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i457" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#weightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">weightedPagerankAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</code>
<div class="block">PageRank on weighted edges.</div>
</td>
</tr>
<tr id="i458" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-ID-int-">whomToFollow</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            ID&nbsp;vertexId,
            int&nbsp;topK)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-"><code>whomToFollow(PgxGraph, PgxVertex, int)</code></a> taking a vertex ID instead of a
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i459" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-ID-int-int-">whomToFollow</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            ID&nbsp;vertexId,
            int&nbsp;topK,
            int&nbsp;sizeCircleOfTrust)</code>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-"><code>whomToFollow(PgxGraph, PgxVertex, int, int)</code></a> taking a vertex ID instead of a
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i460" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-ID-int-int-int-java.math.BigDecimal-java.math.BigDecimal-int-java.math.BigDecimal-">whomToFollow</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            ID&nbsp;vertexId,
            int&nbsp;topK,
            int&nbsp;sizeCircleOfTrust,
            int&nbsp;maxIter,
            java.math.BigDecimal&nbsp;tol,
            java.math.BigDecimal&nbsp;dampingFactor,
            int&nbsp;salsaMaxIter,
            java.math.BigDecimal&nbsp;salsaTol)</code>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-int-java.math.BigDecimal-java.math.BigDecimal-int-java.math.BigDecimal-"><code>whomToFollow(PgxGraph, PgxVertex, int, int, int, BigDecimal, BigDecimal, int, BigDecimal)</code></a>
 taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i461" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-ID-int-int-int-java.math.BigDecimal-java.math.BigDecimal-int-java.math.BigDecimal-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">whomToFollow</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            ID&nbsp;vertexId,
            int&nbsp;topK,
            int&nbsp;sizeCircleOfTrust,
            int&nbsp;maxIter,
            java.math.BigDecimal&nbsp;tol,
            java.math.BigDecimal&nbsp;dampingFactor,
            int&nbsp;salsaMaxIter,
            java.math.BigDecimal&nbsp;salsaTol,
            <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
            <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)</code>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-int-java.math.BigDecimal-java.math.BigDecimal-int-java.math.BigDecimal-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-"><code>whomToFollow(PgxGraph, PgxVertex, int, int, int, BigDecimal, BigDecimal, int, BigDecimal, VertexSequence,
 VertexSequence)</code></a>
 taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
</td>
</tr>
<tr id="i462" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">whomToFollow</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
<tr id="i463" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-">whomToFollow</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
            int&nbsp;topK)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
<tr id="i464" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-">whomToFollow</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
            int&nbsp;topK,
            int&nbsp;sizeCircleOfTrust)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
<tr id="i465" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-int-double-double-int-double-">whomToFollow</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
            int&nbsp;topK,
            int&nbsp;sizeCircleOfTrust,
            int&nbsp;maxIter,
            double&nbsp;tol,
            double&nbsp;dampingFactor,
            int&nbsp;salsaMaxIter,
            double&nbsp;salsaTol)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
<tr id="i466" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-int-double-double-int-double-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">whomToFollow</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
            int&nbsp;topK,
            int&nbsp;sizeCircleOfTrust,
            int&nbsp;maxIter,
            double&nbsp;tol,
            double&nbsp;dampingFactor,
            int&nbsp;salsaMaxIter,
            double&nbsp;salsaTol,
            <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
            <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
<tr id="i467" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">whomToFollow</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
            int&nbsp;topK,
            int&nbsp;sizeCircleOfTrust,
            <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
            <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
<tr id="i468" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">whomToFollow</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
            int&nbsp;topK,
            <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
            <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
<tr id="i469" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">whomToFollow</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
            <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
            <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
            <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
<tr id="i470" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">whomToFollowAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
<tr id="i471" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-">whomToFollowAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                 int&nbsp;topK)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
<tr id="i472" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-">whomToFollowAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                 int&nbsp;topK,
                 int&nbsp;sizeCircleOfTrust)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
<tr id="i473" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-int-double-double-int-double-">whomToFollowAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                 int&nbsp;topK,
                 int&nbsp;sizeCircleOfTrust,
                 int&nbsp;maxIter,
                 double&nbsp;tol,
                 double&nbsp;dampingFactor,
                 int&nbsp;salsaMaxIter,
                 double&nbsp;salsaTol)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
<tr id="i474" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-int-double-double-int-double-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">whomToFollowAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                 int&nbsp;topK,
                 int&nbsp;sizeCircleOfTrust,
                 int&nbsp;maxIter,
                 double&nbsp;tol,
                 double&nbsp;dampingFactor,
                 int&nbsp;salsaMaxIter,
                 double&nbsp;salsaTol,
                 <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
                 <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
<tr id="i475" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">whomToFollowAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                 int&nbsp;topK,
                 int&nbsp;sizeCircleOfTrust,
                 <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
                 <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
<tr id="i476" class="altColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">whomToFollowAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                 int&nbsp;topK,
                 <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
                 <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
<tr id="i477" class="rowColor">
<td class="colFirst"><code>&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../oracle/pgx/api/Analyst.html#whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">whomToFollowAsync</a></span>(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                 <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
                 <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)</code>
<div class="block">WTF is a recommendation algorithm.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.oracle.pgx.api.Destroyable">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;oracle.pgx.api.<a href="../../../oracle/pgx/api/Destroyable.html" title="class in oracle.pgx.api">Destroyable</a></h3>
<code><a href="../../../oracle/pgx/api/Destroyable.html#close--">close</a>, <a href="../../../oracle/pgx/api/Destroyable.html#destroy--">destroy</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="adamicAdarCounting-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>adamicAdarCounting</h4>
<pre>public&nbsp;&lt;V&gt;&nbsp;<a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;adamicAdarCounting(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                      throws java.util.concurrent.ExecutionException,
                                                             java.lang.InterruptedException</pre>
<div class="block"><p>The adamic-adar index compares the amount of neighbors shared between vertices, this measure can be used with communities.
</p>
      <h2>Definition</h2>
      <p>The Adamic-Adar index is meant for undirected graphs, since it is computed using the degree of the shared neighbors by two vertices in the graph. This implementation computes the index for every pair of vertices connected by an edge and associates it with that edge.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(E) with E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The Adamic-Adar index can be used to find correlations between groups of people in social networks, thus characterize communities and also infer potential new links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>edge property holding the Adamic-Adar index of each edge in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; adamicAdar = analyst.adamicAdarCounting(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + adamicAdar.getName() + " MATCH (x) ORDER BY x." + adamicAdar.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://www.cs.cornell.edu/home/kleinber/link-pred.pdf">The Link Prediction Problem for Social Networks.</a></dd>
</dl>
</li>
</ul>
<a name="adamicAdarCounting-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>adamicAdarCounting</h4>
<pre>public&nbsp;&lt;V&gt;&nbsp;<a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;adamicAdarCounting(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;aa)
                                                      throws java.util.concurrent.ExecutionException,
                                                             java.lang.InterruptedException</pre>
<div class="block"><p>The adamic-adar index compares the amount of neighbors shared between vertices, this measure can be used with communities.
</p>
      <h2>Definition</h2>
      <p>The Adamic-Adar index is meant for undirected graphs, since it is computed using the degree of the shared neighbors by two vertices in the graph. This implementation computes the index for every pair of vertices connected by an edge and associates it with that edge.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(E) with E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The Adamic-Adar index can be used to find correlations between groups of people in social networks, thus characterize communities and also infer potential new links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>aa</code> - (out argument)
    edge property holding the Adamic-Adar index of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>edge property holding the Adamic-Adar index of each edge in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; aa = graph.createEdgeProperty(PropertyType.DOUBLE);
 EdgeProperty&lt;Double&gt; adamicAdar = analyst.adamicAdarCounting(graph, aa);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + adamicAdar.getName() + " MATCH (x) ORDER BY x." + adamicAdar.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://www.cs.cornell.edu/home/kleinber/link-pred.pdf">The Link Prediction Problem for Social Networks.</a></dd>
</dl>
</li>
</ul>
<a name="adamicAdarCountingAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>adamicAdarCountingAsync</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&gt;&nbsp;adamicAdarCountingAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>The adamic-adar index compares the amount of neighbors shared between vertices, this measure can be used with communities.
</p>
      <h2>Definition</h2>
      <p>The Adamic-Adar index is meant for undirected graphs, since it is computed using the degree of the shared neighbors by two vertices in the graph. This implementation computes the index for every pair of vertices connected by an edge and associates it with that edge.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(E) with E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The Adamic-Adar index can be used to find correlations between groups of people in social networks, thus characterize communities and also infer potential new links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>edge property holding the Adamic-Adar index of each edge in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;EdgeProperty&lt;Double&gt;&gt; promise = analyst.adamicAdarCountingAsync(graph);
 promise.thenCompose(adamicAdar -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + adamicAdar.getName() + " MATCH (x) ORDER BY x." + adamicAdar.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://www.cs.cornell.edu/home/kleinber/link-pred.pdf">The Link Prediction Problem for Social Networks.</a></dd>
</dl>
</li>
</ul>
<a name="adamicAdarCountingAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>adamicAdarCountingAsync</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&gt;&nbsp;adamicAdarCountingAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                         <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;aa)</pre>
<div class="block"><p>The adamic-adar index compares the amount of neighbors shared between vertices, this measure can be used with communities.
</p>
      <h2>Definition</h2>
      <p>The Adamic-Adar index is meant for undirected graphs, since it is computed using the degree of the shared neighbors by two vertices in the graph. This implementation computes the index for every pair of vertices connected by an edge and associates it with that edge.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(E) with E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The Adamic-Adar index can be used to find correlations between groups of people in social networks, thus characterize communities and also infer potential new links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>aa</code> - (out argument)
    edge property holding the Adamic-Adar index of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>edge property holding the Adamic-Adar index of each edge in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; aa = graph.createEdgeProperty(PropertyType.DOUBLE);
 PgxFuture&lt;EdgeProperty&lt;Double&gt;&gt; promise = analyst.adamicAdarCountingAsync(graph, aa);
 promise.thenCompose(adamicAdar -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + adamicAdar.getName() + " MATCH (x) ORDER BY x." + adamicAdar.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://www.cs.cornell.edu/home/kleinber/link-pred.pdf">The Link Prediction Problem for Social Networks.</a></dd>
</dl>
</li>
</ul>
<a name="allReachableVerticesEdges-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allReachableVerticesEdges</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;org.apache.commons.lang3.tuple.Triple&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSet.html" title="class in oracle.pgx.api">EdgeSet</a>,<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&gt;&nbsp;allReachableVerticesEdges(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                                           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                                                                                           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                                                                                           int&nbsp;k)
                                                                                                                                    throws java.util.concurrent.ExecutionException,
                                                                                                                                           java.lang.InterruptedException</pre>
<div class="block"><p>Finds all the vertices and edges on a path between the src and target of length smaller or equal to k.
</p>
      <h2>Definition</h2>
      <p>Finds all the vertices and edges on a path between the src and target of length smaller or equal to k.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex.</dd>
<dd><code>dst</code> - the destination vertex.</dd>
<dd><code>k</code> - the dimension of the distances property; i.e. number of high-degree vertices.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>Triple</code> containing a vertex-set with the vertices on the path, an edge-set with the edges on
 the path and a map containing the distances from the source vertex for each vertex on the path</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="allReachableVerticesEdgesAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allReachableVerticesEdgesAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;org.apache.commons.lang3.tuple.Triple&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSet.html" title="class in oracle.pgx.api">EdgeSet</a>,<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&gt;&gt;&nbsp;allReachableVerticesEdgesAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                                                           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                                                                                                           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                                                                                                           int&nbsp;k)</pre>
<div class="block"><p>Finds all the vertices and edges on a path between the src and target of length smaller or equal to k.
</p>
      <h2>Definition</h2>
      <p>Finds all the vertices and edges on a path between the src and target of length smaller or equal to k.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex.</dd>
<dd><code>dst</code> - the destination vertex.</dd>
<dd><code>k</code> - the dimension of the distances property; i.e. number of high-degree vertices.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>Triple</code> containing a vertex-set with the vertices on the path, an edge-set with the edges on
 the path and a map containing the distances from the source vertex for each vertex on the path</dd>
</dl>
</li>
</ul>
<a name="allReachableVerticesEdgesFiltered-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.filter.EdgeFilter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allReachableVerticesEdgesFiltered</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;org.apache.commons.lang3.tuple.Triple&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSet.html" title="class in oracle.pgx.api">EdgeSet</a>,<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&gt;&nbsp;allReachableVerticesEdgesFiltered(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                                                   <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                                                                                                   <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                                                                                                   int&nbsp;k,
                                                                                                                                                   <a href="../../../oracle/pgx/api/filter/EdgeFilter.html" title="class in oracle.pgx.api.filter">EdgeFilter</a>&nbsp;filter)
                                                                                                                                            throws java.util.concurrent.ExecutionException,
                                                                                                                                                   java.lang.InterruptedException</pre>
<div class="block"><p>Finds all the vertices and edges on a path between the src and target of length smaller or equal to k.
</p>
      <h2>Definition</h2>
      <p>Finds all the vertices and edges on a path between the src and target of length smaller or equal to k.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex.</dd>
<dd><code>dst</code> - the destination vertex.</dd>
<dd><code>k</code> - the dimension of the distances property; i.e. number of high-degree vertices.</dd>
<dd><code>filter</code> - the filter to be used on edges when searching for a path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>Triple</code> containing a vertex-set with the vertices on the path, an edge-set with the edges on
 the path and a map containing the distances from the source vertex for each vertex on the path</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="allReachableVerticesEdgesFilteredAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.filter.EdgeFilter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allReachableVerticesEdgesFilteredAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;org.apache.commons.lang3.tuple.Triple&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSet.html" title="class in oracle.pgx.api">EdgeSet</a>,<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&gt;&gt;&nbsp;allReachableVerticesEdgesFilteredAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                                                                   <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                                                                                                                   <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                                                                                                                   int&nbsp;k,
                                                                                                                                                                   <a href="../../../oracle/pgx/api/filter/EdgeFilter.html" title="class in oracle.pgx.api.filter">EdgeFilter</a>&nbsp;filter)</pre>
<div class="block"><p>Finds all the vertices and edges on a path between the src and target of length smaller or equal to k.
</p>
      <h2>Definition</h2>
      <p>Finds all the vertices and edges on a path between the src and target of length smaller or equal to k.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex.</dd>
<dd><code>dst</code> - the destination vertex.</dd>
<dd><code>k</code> - the dimension of the distances property; i.e. number of high-degree vertices.</dd>
<dd><code>filter</code> - the filter to be used on edges when searching for a path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>Triple</code> containing a vertex-set with the vertices on the path, an edge-set with the edges on
 the path and a map containing the distances from the source vertex for each vertex on the path</dd>
</dl>
</li>
</ul>
<a name="approximateVertexBetweennessCentrality-oracle.pgx.api.PgxGraph-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>approximateVertexBetweennessCentrality</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;approximateVertexBetweennessCentrality(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                       int&nbsp;k)
                                                                                throws java.util.concurrent.ExecutionException,
                                                                                       java.lang.InterruptedException</pre>
<div class="block"><p>Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information
</p>
      <h2>Definition</h2>
      <p>This variant of betweenness centrality approximates the centrality of the vertices by just using k random vertices as starting points for the BFS traversals of the graph, instead of computing the exact value by using all the vertices in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in BFS method for the graph traversals. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from betweenness centrality can be used to identify vertices in a graph that are vital for the flow of information within it, making it a good option for applications in social networks and problems modelling flows of any kind.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>k</code> - number of random vertices to be used to compute the approximated betweenness centrality coeficients.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the betweenness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; betweenness = analyst.approximateVertexBetweennessCentrality(graph, 100);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + betweenness.getName() + " MATCH (x) ORDER BY x." + betweenness.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="approximateVertexBetweennessCentrality-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>approximateVertexBetweennessCentrality</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;approximateVertexBetweennessCentrality(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                       int&nbsp;k,
                                                                                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;bc)
                                                                                throws java.util.concurrent.ExecutionException,
                                                                                       java.lang.InterruptedException</pre>
<div class="block"><p>Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information
</p>
      <h2>Definition</h2>
      <p>This variant of betweenness centrality approximates the centrality of the vertices by just using k random vertices as starting points for the BFS traversals of the graph, instead of computing the exact value by using all the vertices in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in BFS method for the graph traversals. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from betweenness centrality can be used to identify vertices in a graph that are vital for the flow of information within it, making it a good option for applications in social networks and problems modelling flows of any kind.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>k</code> - number of random vertices to be used to compute the approximated betweenness centrality coeficients.</dd>
<dd><code>bc</code> - (out argument)
    vertex property holding the betweenness centrality value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the betweenness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; bc = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; betweenness = analyst.approximateVertexBetweennessCentrality(graph, 100, bc);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + betweenness.getName() + " MATCH (x) ORDER BY x." + betweenness.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="approximateVertexBetweennessCentralityAsync-oracle.pgx.api.PgxGraph-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>approximateVertexBetweennessCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;approximateVertexBetweennessCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                       int&nbsp;k)</pre>
<div class="block"><p>Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information
</p>
      <h2>Definition</h2>
      <p>This variant of betweenness centrality approximates the centrality of the vertices by just using k random vertices as starting points for the BFS traversals of the graph, instead of computing the exact value by using all the vertices in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in BFS method for the graph traversals. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from betweenness centrality can be used to identify vertices in a graph that are vital for the flow of information within it, making it a good option for applications in social networks and problems modelling flows of any kind.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>k</code> - number of random vertices to be used to compute the approximated betweenness centrality coeficients.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the betweenness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.approximateVertexBetweennessCentralityAsync(
   graph, 100);
 promise.thenCompose(betweenness -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + betweenness.getName() + " MATCH (x) ORDER BY x." + betweenness.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="approximateVertexBetweennessCentralityAsync-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>approximateVertexBetweennessCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;approximateVertexBetweennessCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                       int&nbsp;k,
                                                                                                       <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;bc)</pre>
<div class="block"><p>Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information
</p>
      <h2>Definition</h2>
      <p>This variant of betweenness centrality approximates the centrality of the vertices by just using k random vertices as starting points for the BFS traversals of the graph, instead of computing the exact value by using all the vertices in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in BFS method for the graph traversals. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from betweenness centrality can be used to identify vertices in a graph that are vital for the flow of information within it, making it a good option for applications in social networks and problems modelling flows of any kind.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>k</code> - number of random vertices to be used to compute the approximated betweenness centrality coeficients.</dd>
<dd><code>bc</code> - (out argument)
    vertex property holding the betweenness centrality value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the betweenness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; bc = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.approximateVertexBetweennessCentralityAsync(
   graph, 100, bc);
 promise.thenCompose(betweenness -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + betweenness.getName() + " MATCH (x) ORDER BY x." + betweenness.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="approximateVertexBetweennessCentralityFromSeeds-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>approximateVertexBetweennessCentralityFromSeeds</h4>
<pre>@SafeVarargs
public final&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;approximateVertexBetweennessCentralityFromSeeds(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                   <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;...&nbsp;seeds)
                                                                                                            throws java.util.concurrent.ExecutionException,
                                                                                                                   java.lang.InterruptedException</pre>
<div class="block"><p>Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information
</p>
      <h2>Definition</h2>
      <p>This variant of betweenness centrality approximates the centrality of the vertices by just using the vertices from the given sequence as starting points for the BFS traversals of the graph, instead of computing the exact value by using all the vertices in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in BFS method for the graph traversals. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from betweenness centrality can be used to identify vertices in a graph that are vital for the flow of information within it, making it a good option for applications in social networks and problems modelling flows of any kind.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>seeds</code> - the (unique) chosen nodes to be used to compute the approximated betweenness centrality coeficients.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the betweenness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; betweenness =
   analyst.approximateVertexBetweennessCentralityFromSeeds(graph, vertex);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + betweenness.getName() + " MATCH (x) ORDER BY x." + betweenness.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="approximateVertexBetweennessCentralityFromSeeds-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.PgxVertex...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>approximateVertexBetweennessCentralityFromSeeds</h4>
<pre>@SafeVarargs
public final&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;approximateVertexBetweennessCentralityFromSeeds(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;bc,
                                                                                                                   <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;...&nbsp;seeds)
                                                                                                            throws java.util.concurrent.ExecutionException,
                                                                                                                   java.lang.InterruptedException</pre>
<div class="block"><p>Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information
</p>
      <h2>Definition</h2>
      <p>This variant of betweenness centrality approximates the centrality of the vertices by just using the vertices from the given sequence as starting points for the BFS traversals of the graph, instead of computing the exact value by using all the vertices in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in BFS method for the graph traversals. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from betweenness centrality can be used to identify vertices in a graph that are vital for the flow of information within it, making it a good option for applications in social networks and problems modelling flows of any kind.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>bc</code> - (out argument)
    vertex property holding the betweenness centrality value for each vertex.</dd>
<dd><code>seeds</code> - the (unique) chosen nodes to be used to compute the approximated betweenness centrality coeficients.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the betweenness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; bc = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; betweenness =
   analyst.approximateVertexBetweennessCentralityFromSeeds(graph, bc, vertex);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + betweenness.getName() + " MATCH (x) ORDER BY x." + betweenness.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="approximateVertexBetweennessCentralityFromSeedsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>approximateVertexBetweennessCentralityFromSeedsAsync</h4>
<pre>@SafeVarargs
public final&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;approximateVertexBetweennessCentralityFromSeedsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                                   <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;...&nbsp;seeds)</pre>
<div class="block"><p>Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information
</p>
      <h2>Definition</h2>
      <p>This variant of betweenness centrality approximates the centrality of the vertices by just using the vertices from the given sequence as starting points for the BFS traversals of the graph, instead of computing the exact value by using all the vertices in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in BFS method for the graph traversals. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from betweenness centrality can be used to identify vertices in a graph that are vital for the flow of information within it, making it a good option for applications in social networks and problems modelling flows of any kind.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>seeds</code> - the (unique) chosen nodes to be used to compute the approximated betweenness centrality coeficients.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the betweenness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; v1 = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; v2 = graph.getVertex(333);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.approximateVertexBetweennessCentralityFromSeedsAsync(
   graph, v1, v2);
 promise.thenCompose(betweenness -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + betweenness.getName() + " MATCH (x) ORDER BY x." + betweenness.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="approximateVertexBetweennessCentralityFromSeedsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.PgxVertex...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>approximateVertexBetweennessCentralityFromSeedsAsync</h4>
<pre>@SafeVarargs
public final&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;approximateVertexBetweennessCentralityFromSeedsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;bc,
                                                                                                                                   <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;...&nbsp;seeds)</pre>
<div class="block"><p>Faster, but less accurate than betweenness centrality, it identifies important vertices for the flow of information
</p>
      <h2>Definition</h2>
      <p>This variant of betweenness centrality approximates the centrality of the vertices by just using the vertices from the given sequence as starting points for the BFS traversals of the graph, instead of computing the exact value by using all the vertices in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in BFS method for the graph traversals. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from betweenness centrality can be used to identify vertices in a graph that are vital for the flow of information within it, making it a good option for applications in social networks and problems modelling flows of any kind.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>bc</code> - (out argument)
    vertex property holding the betweenness centrality value for each vertex.</dd>
<dd><code>seeds</code> - the (unique) chosen nodes to be used to compute the approximated betweenness centrality coeficients.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the betweenness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; bc = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxVertex&lt;Integer&gt; v1 = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; v2 = graph.getVertex(333);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.approximateVertexBetweennessCentralityFromSeedsAsync(
   graph, bc, v1, v2);
 promise.thenCompose(betweenness -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + betweenness.getName() + " MATCH (x) ORDER BY x." + betweenness.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="bipartiteCheck-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bipartiteCheck</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Boolean&gt;&nbsp;bipartiteCheck(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Boolean&gt;&nbsp;isLeft)
                                                         throws java.util.concurrent.ExecutionException,
                                                                java.lang.InterruptedException</pre>
<div class="block"><p>Bipartite check verifies whether are graph is a bipartite graph.
</p>
      <h2>Definition</h2>
      <p>This algorithm checks whether the given directed graph is bipartite. It assumes that all the edges are going in the same direction since the method relies on BFS traversals of the graph. If the graph is bipartite the algorithm will return the side of each vertex in the graph with the is_left vertex property.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in BFS method for the graph traversals.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Checking whether a graph is a bipartite one is important since some other graph algorithms rely on this particular condition.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>isLeft</code> - vertex property holding the side of each vertex in a bipartite graph (true for left, false for right).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the side of each vertex in a bipartite graph (true for left, false for right).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Boolean&gt; isLeft = graph.createVertexProperty(PropertyType.BOOLEAN);
 VertexProperty&lt;Integer, Boolean&gt; bipartite = analyst.BipartiteCheck(graph, isLeft);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Bipartite_graph">Bipartite Graph.</a></dd>
</dl>
</li>
</ul>
<a name="bipartiteCheckAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bipartiteCheckAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Boolean&gt;&gt;&nbsp;bipartiteCheckAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Boolean&gt;&nbsp;isLeft)</pre>
<div class="block"><p>Bipartite check verifies whether are graph is a bipartite graph.
</p>
      <h2>Definition</h2>
      <p>This algorithm checks whether the given directed graph is bipartite. It assumes that all the edges are going in the same direction since the method relies on BFS traversals of the graph. If the graph is bipartite the algorithm will return the side of each vertex in the graph with the is_left vertex property.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in BFS method for the graph traversals.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Checking whether a graph is a bipartite one is important since some other graph algorithms rely on this particular condition.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>isLeft</code> - vertex property holding the side of each vertex in a bipartite graph (true for left, false for right).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the side of each vertex in a bipartite graph (true for left, false for right).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Boolean&gt; isLeft = graph.createVertexProperty(PropertyType.BOOLEAN);
 PgxFuture&lt;VertexProperty&lt;Integer, Boolean&gt;&gt; promise = analyst.BipartiteCheck(graph, isLeft);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Bipartite_graph">Bipartite Graph.</a></dd>
</dl>
</li>
</ul>
<a name="center-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>center</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;center(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                          throws java.util.concurrent.ExecutionException,
                                 java.lang.InterruptedException</pre>
<div class="block"><p>Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The periphery of a graph is the set of vertices that have an eccentricity value equal to the diameter of the graph. Similarly, the center is comprised by the set of vertices with eccentricity equal to the radius of the graph. The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortests paths to any other vertex in the graph. This algorithm will return the set of vertices from the periphery or the center of the graph, depending on the request. The algorithm will return a set with all the vertices for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex set holding the vertices from the periphery or center of the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; center = analyst.center(graph);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="center-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>center</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;center(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                 <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;center)
                          throws java.util.concurrent.ExecutionException,
                                 java.lang.InterruptedException</pre>
<div class="block"><p>Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The periphery of a graph is the set of vertices that have an eccentricity value equal to the diameter of the graph. Similarly, the center is comprised by the set of vertices with eccentricity equal to the radius of the graph. The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortests paths to any other vertex in the graph. This algorithm will return the set of vertices from the periphery or the center of the graph, depending on the request. The algorithm will return a set with all the vertices for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>center</code> - (out argument) vertex set holding the vertices from the periphery or center of the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex set holding the vertices from the periphery or center of the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.createVertexSet();
 VertexSet&lt;Integer&gt; center = analyst.center(graph, vertices);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="centerAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>centerAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;&nbsp;centerAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The periphery of a graph is the set of vertices that have an eccentricity value equal to the diameter of the graph. Similarly, the center is comprised by the set of vertices with eccentricity equal to the radius of the graph. The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortests paths to any other vertex in the graph. This algorithm will return the set of vertices from the periphery or the center of the graph, depending on the request. The algorithm will return a set with all the vertices for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex set holding the vertices from the periphery or center of the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexSet&lt;Integer&gt;&gt; promise = analyst.centerAsync(graph);
 promise.thenAccept(center -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="centerAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>centerAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;&nbsp;centerAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                 <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;center)</pre>
<div class="block"><p>Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The periphery of a graph is the set of vertices that have an eccentricity value equal to the diameter of the graph. Similarly, the center is comprised by the set of vertices with eccentricity equal to the radius of the graph. The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortests paths to any other vertex in the graph. This algorithm will return the set of vertices from the periphery or the center of the graph, depending on the request. The algorithm will return a set with all the vertices for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>center</code> - (out argument) vertex set holding the vertices from the periphery or center of the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex set holding the vertices from the periphery or center of the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.createVertexSet();
 PgxFuture&lt;VertexSet&lt;Integer&gt;&gt; promise = analyst.centerAsync(graph, vertices);
 promise.thenAccept(center -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="closenessCentralityDoubleLength-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closenessCentralityDoubleLength</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;closenessCentralityDoubleLength(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)
                                                                         throws java.util.concurrent.ExecutionException,
                                                                                java.lang.InterruptedException</pre>
<div class="block"><p>Closenness centrality measures the centrality of the vertices based on weighted distances, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>This variant of Closeness Centrality takes into account the weights from the edges when computing the reciprocal of the sum of all the distances from the possible shortests paths starting from the vertex V, for every vertex in the graph. The weights of the edges must be positive values greater than 0.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of is more expensive to compute than the normal closeness centrality because of the inclusion of the weights in the edges which influence the selection of edges for the shortest paths. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E * d) with E = number of edges, V = number of vertices, d = diameter of the graph</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from closeness centrality can be used to identify vertices in a graph that are close and well connected to other vertices, hence it can be used in many applications for social networks when looking for vertices to spread information in a fast way.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>cost</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the closeness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; closeness = analyst.closenessCentralityDoubleLength(graph, cost);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + closeness.getName() + " MATCH (x) ORDER BY x." + closeness.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="closenessCentralityDoubleLength-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closenessCentralityDoubleLength</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;closenessCentralityDoubleLength(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                                                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;cc)
                                                                         throws java.util.concurrent.ExecutionException,
                                                                                java.lang.InterruptedException</pre>
<div class="block"><p>Closenness centrality measures the centrality of the vertices based on weighted distances, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>This variant of Closeness Centrality takes into account the weights from the edges when computing the reciprocal of the sum of all the distances from the possible shortests paths starting from the vertex V, for every vertex in the graph. The weights of the edges must be positive values greater than 0.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of is more expensive to compute than the normal closeness centrality because of the inclusion of the weights in the edges which influence the selection of edges for the shortest paths. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E * d) with E = number of edges, V = number of vertices, d = diameter of the graph</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from closeness centrality can be used to identify vertices in a graph that are close and well connected to other vertices, hence it can be used in many applications for social networks when looking for vertices to spread information in a fast way.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>cost</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>cc</code> - (out argument)
    vertex property holding the closeness centrality value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the closeness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; cc = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; closeness = analyst.closenessCentralityDoubleLength(graph, cost, cc);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + closeness.getName() + " MATCH (x) ORDER BY x." + closeness.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="closenessCentralityDoubleLengthAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closenessCentralityDoubleLengthAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;closenessCentralityDoubleLengthAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</pre>
<div class="block"><p>Closenness centrality measures the centrality of the vertices based on weighted distances, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>This variant of Closeness Centrality takes into account the weights from the edges when computing the reciprocal of the sum of all the distances from the possible shortests paths starting from the vertex V, for every vertex in the graph. The weights of the edges must be positive values greater than 0.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of is more expensive to compute than the normal closeness centrality because of the inclusion of the weights in the edges which influence the selection of edges for the shortest paths. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E * d) with E = number of edges, V = number of vertices, d = diameter of the graph</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from closeness centrality can be used to identify vertices in a graph that are close and well connected to other vertices, hence it can be used in many applications for social networks when looking for vertices to spread information in a fast way.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>cost</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the closeness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.closenessCentralityDoubleLengthAsync(graph, cost);
 promise.thenCompose(closeness -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + closeness.getName() + " MATCH (x) ORDER BY x." + closeness.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="closenessCentralityDoubleLengthAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closenessCentralityDoubleLengthAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;closenessCentralityDoubleLengthAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                                                                <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;cc)</pre>
<div class="block"><p>Closenness centrality measures the centrality of the vertices based on weighted distances, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>This variant of Closeness Centrality takes into account the weights from the edges when computing the reciprocal of the sum of all the distances from the possible shortests paths starting from the vertex V, for every vertex in the graph. The weights of the edges must be positive values greater than 0.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of is more expensive to compute than the normal closeness centrality because of the inclusion of the weights in the edges which influence the selection of edges for the shortest paths. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E * d) with E = number of edges, V = number of vertices, d = diameter of the graph</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from closeness centrality can be used to identify vertices in a graph that are close and well connected to other vertices, hence it can be used in many applications for social networks when looking for vertices to spread information in a fast way.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>cost</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>cc</code> - (out argument)
    vertex property holding the closeness centrality value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the closeness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; cc = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.closenessCentralityDoubleLengthAsync(graph, cost, cc);
 promise.thenCompose(closeness -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + closeness.getName() + " MATCH (x) ORDER BY x." + closeness.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="closenessCentralityUnitLength-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closenessCentralityUnitLength</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;closenessCentralityUnitLength(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                                       throws java.util.concurrent.ExecutionException,
                                                                              java.lang.InterruptedException</pre>
<div class="block"><p>Closenness centrality measures the centrality of the vertices based on distances, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>The Closeness Centrality of a node V is the reciprocal of the sum of all the distances from the possible shortests paths starting from V. Thus the higher the centrality value of V, the closer it is to all the other vertices in the graph. This implementation is meant for undirected graphs.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from closeness centrality can be used to identify vertices in a graph that are close and well connected to other vertices, hence it can be used in many applications for social networks when looking for vertices to spread information in a fast way.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>node property holding the closeness centrality value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; closeness = analyst.closenessCentralityUnitLength(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + closeness.getName() + " MATCH (x) ORDER BY x." + closeness.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="closenessCentralityUnitLength-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closenessCentralityUnitLength</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;closenessCentralityUnitLength(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;cc)
                                                                       throws java.util.concurrent.ExecutionException,
                                                                              java.lang.InterruptedException</pre>
<div class="block"><p>Closenness centrality measures the centrality of the vertices based on distances, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>The Closeness Centrality of a node V is the reciprocal of the sum of all the distances from the possible shortests paths starting from V. Thus the higher the centrality value of V, the closer it is to all the other vertices in the graph. This implementation is meant for undirected graphs.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from closeness centrality can be used to identify vertices in a graph that are close and well connected to other vertices, hence it can be used in many applications for social networks when looking for vertices to spread information in a fast way.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>cc</code> - (out argument)
    node property holding the closeness centrality value for each node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>node property holding the closeness centrality value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; cc = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; closeness = analyst.closenessCentralityUnitLength(graph, cc);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + closeness.getName() + " MATCH (x) ORDER BY x." + closeness.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="closenessCentralityUnitLengthAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closenessCentralityUnitLengthAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;closenessCentralityUnitLengthAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Closenness centrality measures the centrality of the vertices based on distances, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>The Closeness Centrality of a node V is the reciprocal of the sum of all the distances from the possible shortests paths starting from V. Thus the higher the centrality value of V, the closer it is to all the other vertices in the graph. This implementation is meant for undirected graphs.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from closeness centrality can be used to identify vertices in a graph that are close and well connected to other vertices, hence it can be used in many applications for social networks when looking for vertices to spread information in a fast way.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>node property holding the closeness centrality value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.closenessCentralityUnitLengthAsync(graph);
 promise.thenCompose(closeness -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + closeness.getName() + " MATCH (x) ORDER BY x." + closeness.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="closenessCentralityUnitLengthAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closenessCentralityUnitLengthAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;closenessCentralityUnitLengthAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;cc)</pre>
<div class="block"><p>Closenness centrality measures the centrality of the vertices based on distances, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>The Closeness Centrality of a node V is the reciprocal of the sum of all the distances from the possible shortests paths starting from V. Thus the higher the centrality value of V, the closer it is to all the other vertices in the graph. This implementation is meant for undirected graphs.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from closeness centrality can be used to identify vertices in a graph that are close and well connected to other vertices, hence it can be used in many applications for social networks when looking for vertices to spread information in a fast way.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>cc</code> - (out argument)
    node property holding the closeness centrality value for each node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>node property holding the closeness centrality value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; cc = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.closenessCentralityUnitLengthAsync(graph, cc);
 promise.thenCompose(closeness -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + closeness.getName() + " MATCH (x) ORDER BY x." + closeness.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="communitiesConductanceMinimization-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesConductanceMinimization</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;communitiesConductanceMinimization(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                      throws java.util.concurrent.ExecutionException,
                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Soman and Narang can find communities in a graph taking weighted edges into account
</p>
      <h2>Definition</h2>
      <p>The algorithm proposed by Soman and Narang to find community structures in a graph can be regarded as a variant of the label propagation algorithm, since it takes into account weights over the edges when looking for the community assignments. This implementation generates the weight of the edges by using the triangles in the graph, and just like label propagation, it assigns a unique community label to each vertex in the graph at the beginning, which is then updated on each iteration by looking and choosing the most frequent label from the labels of their neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. Also note that there is a possibility of constant vertex swapping. For example, if you have two vertices A and B in your graph. It can happen that A will acquire the community of B but at the same time B will acquire the community of A. That is why you should set a maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(5 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; conductance = analyst.communitiesConductanceMinimization(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="communitiesConductanceMinimization-oracle.pgx.api.PgxGraph-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesConductanceMinimization</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;communitiesConductanceMinimization(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                             int&nbsp;maxIterations)
                                                      throws java.util.concurrent.ExecutionException,
                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Soman and Narang can find communities in a graph taking weighted edges into account
</p>
      <h2>Definition</h2>
      <p>The algorithm proposed by Soman and Narang to find community structures in a graph can be regarded as a variant of the label propagation algorithm, since it takes into account weights over the edges when looking for the community assignments. This implementation generates the weight of the edges by using the triangles in the graph, and just like label propagation, it assigns a unique community label to each vertex in the graph at the beginning, which is then updated on each iteration by looking and choosing the most frequent label from the labels of their neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. Also note that there is a possibility of constant vertex swapping. For example, if you have two vertices A and B in your graph. It can happen that A will acquire the community of B but at the same time B will acquire the community of A. That is why you should set a maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(5 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>maxIterations</code> - maximum number of iterations that will be performed. For most graphs, a maximum of 100 iterations should be enough.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; conductance = analyst.communitiesConductanceMinimization(graph, 100);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="communitiesConductanceMinimization-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesConductanceMinimization</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;communitiesConductanceMinimization(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                             int&nbsp;maxIterations,
                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)
                                                      throws java.util.concurrent.ExecutionException,
                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Soman and Narang can find communities in a graph taking weighted edges into account
</p>
      <h2>Definition</h2>
      <p>The algorithm proposed by Soman and Narang to find community structures in a graph can be regarded as a variant of the label propagation algorithm, since it takes into account weights over the edges when looking for the community assignments. This implementation generates the weight of the edges by using the triangles in the graph, and just like label propagation, it assigns a unique community label to each vertex in the graph at the beginning, which is then updated on each iteration by looking and choosing the most frequent label from the labels of their neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. Also note that there is a possibility of constant vertex swapping. For example, if you have two vertices A and B in your graph. It can happen that A will acquire the community of B but at the same time B will acquire the community of A. That is why you should set a maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(5 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>maxIterations</code> - maximum number of iterations that will be performed. For most graphs, a maximum of 100 iterations should be enough.</dd>
<dd><code>partitionDistribution</code> - vertex property holding the label of the community assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Long&gt; pd = graph.createVertexProperty(PropertyType.LONG);
 Partition&lt;Integer&gt; conductance = analyst.communitiesConductanceMinimization(graph, 100, pd);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="communitiesConductanceMinimization-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesConductanceMinimization</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;communitiesConductanceMinimization(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)
                                                      throws java.util.concurrent.ExecutionException,
                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Soman and Narang can find communities in a graph taking weighted edges into account
</p>
      <h2>Definition</h2>
      <p>The algorithm proposed by Soman and Narang to find community structures in a graph can be regarded as a variant of the label propagation algorithm, since it takes into account weights over the edges when looking for the community assignments. This implementation generates the weight of the edges by using the triangles in the graph, and just like label propagation, it assigns a unique community label to each vertex in the graph at the beginning, which is then updated on each iteration by looking and choosing the most frequent label from the labels of their neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. Also note that there is a possibility of constant vertex swapping. For example, if you have two vertices A and B in your graph. It can happen that A will acquire the community of B but at the same time B will acquire the community of A. That is why you should set a maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(5 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partitionDistribution</code> - vertex property holding the label of the community assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Long&gt; pd = graph.createVertexProperty(PropertyType.LONG);
 Partition&lt;Integer&gt; conductance = analyst.communitiesConductanceMinimization(graph, pd);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="communitiesConductanceMinimizationAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesConductanceMinimizationAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;communitiesConductanceMinimizationAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Soman and Narang can find communities in a graph taking weighted edges into account
</p>
      <h2>Definition</h2>
      <p>The algorithm proposed by Soman and Narang to find community structures in a graph can be regarded as a variant of the label propagation algorithm, since it takes into account weights over the edges when looking for the community assignments. This implementation generates the weight of the edges by using the triangles in the graph, and just like label propagation, it assigns a unique community label to each vertex in the graph at the beginning, which is then updated on each iteration by looking and choosing the most frequent label from the labels of their neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. Also note that there is a possibility of constant vertex swapping. For example, if you have two vertices A and B in your graph. It can happen that A will acquire the community of B but at the same time B will acquire the community of A. That is why you should set a maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(5 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.communitiesConductanceMinimizationAsync(graph);
 promise.thenCompose(conductance -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="communitiesConductanceMinimizationAsync-oracle.pgx.api.PgxGraph-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesConductanceMinimizationAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;communitiesConductanceMinimizationAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             int&nbsp;max)</pre>
<div class="block"><p>Soman and Narang can find communities in a graph taking weighted edges into account
</p>
      <h2>Definition</h2>
      <p>The algorithm proposed by Soman and Narang to find community structures in a graph can be regarded as a variant of the label propagation algorithm, since it takes into account weights over the edges when looking for the community assignments. This implementation generates the weight of the edges by using the triangles in the graph, and just like label propagation, it assigns a unique community label to each vertex in the graph at the beginning, which is then updated on each iteration by looking and choosing the most frequent label from the labels of their neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. Also note that there is a possibility of constant vertex swapping. For example, if you have two vertices A and B in your graph. It can happen that A will acquire the community of B but at the same time B will acquire the community of A. That is why you should set a maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(5 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed. For most graphs, a maximum of 100 iterations should be enough.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.communitiesConductanceMinimizationAsync(graph, 100);
 promise.thenCompose(conductance -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="communitiesConductanceMinimizationAsync-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesConductanceMinimizationAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;communitiesConductanceMinimizationAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             int&nbsp;maxIterations,
                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</pre>
<div class="block"><p>Soman and Narang can find communities in a graph taking weighted edges into account
</p>
      <h2>Definition</h2>
      <p>The algorithm proposed by Soman and Narang to find community structures in a graph can be regarded as a variant of the label propagation algorithm, since it takes into account weights over the edges when looking for the community assignments. This implementation generates the weight of the edges by using the triangles in the graph, and just like label propagation, it assigns a unique community label to each vertex in the graph at the beginning, which is then updated on each iteration by looking and choosing the most frequent label from the labels of their neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. Also note that there is a possibility of constant vertex swapping. For example, if you have two vertices A and B in your graph. It can happen that A will acquire the community of B but at the same time B will acquire the community of A. That is why you should set a maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(5 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>maxIterations</code> - maximum number of iterations that will be performed. For most graphs, a maximum of 100 iterations should be enough.</dd>
<dd><code>partitionDistribution</code> - vertex property holding the label of the community assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Long&gt; pd = graph.createVertexProperty(PropertyType.LONG);
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.communitiesConductanceMinimizationAsync(graph, 100, pd);
 promise.thenCompose(conductance -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="communitiesConductanceMinimizationAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesConductanceMinimizationAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;communitiesConductanceMinimizationAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</pre>
<div class="block"><p>Soman and Narang can find communities in a graph taking weighted edges into account
</p>
      <h2>Definition</h2>
      <p>The algorithm proposed by Soman and Narang to find community structures in a graph can be regarded as a variant of the label propagation algorithm, since it takes into account weights over the edges when looking for the community assignments. This implementation generates the weight of the edges by using the triangles in the graph, and just like label propagation, it assigns a unique community label to each vertex in the graph at the beginning, which is then updated on each iteration by looking and choosing the most frequent label from the labels of their neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. Also note that there is a possibility of constant vertex swapping. For example, if you have two vertices A and B in your graph. It can happen that A will acquire the community of B but at the same time B will acquire the community of A. That is why you should set a maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(5 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partitionDistribution</code> - vertex property holding the label of the community assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Long&gt; pd = graph.createVertexProperty(PropertyType.LONG);
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.communitiesConductanceMinimizationAsync(graph, pd);
 promise.thenCompose(conductance -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="communitiesInfomap-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesInfomap</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;communitiesInfomap(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                      throws java.util.concurrent.ExecutionException,
                                             java.lang.InterruptedException</pre>
<div class="block"><p>Infomap can find high quality communities in a graph.
</p>
      <h2>Definition</h2>
      <p>Infomap is a robust algorithm designed to find community structures in a graph that requires some pre-processing steps. This implementation needs a reciprocated or an undirected graph, as well as the ranking score from the normalized weighted version of the Pagerank algorithm. It will assign a unique module (or community) label to each vertex in the graph based on their Pagerank score, edge weights and the labels of their neighbors. It is an iterative algorithm that updates the labels of the vertices in random order on each iteration using the previous factors, converging once there are no further changes in the vertex labels, or once the maximum number of iterations is reached. The algorithm is non-deterministic because of the random order for visiting and updating the vertex labels, thus the communities found might be different each time the algorithm is run.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O((k ^ 2) * E) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(10 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the undirected graph.</dd>
<dd><code>rank</code> - vertex property holding the normalized (weighted) PageRank value for each vertex (a value between 0 and 1).</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; weight = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = analyst.weightedPagerank(graph, 1e-16, 0.85, 1000, true, weight);
 VertexProperty&lt;Integer, Long&gt; module = graph.createVertexProperty(PropertyType.LONG);
 Partition&lt;Integer&gt; promise = analyst.communitiesInfomap(graph, rank, weight);
 first_component = promise.getPartitionByIndex(0)
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="communitiesInfomap-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesInfomap</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;communitiesInfomap(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                             double&nbsp;tau,
                                             double&nbsp;tol,
                                             int&nbsp;maxIter)
                                      throws java.util.concurrent.ExecutionException,
                                             java.lang.InterruptedException</pre>
<div class="block"><p>Infomap can find high quality communities in a graph.
</p>
      <h2>Definition</h2>
      <p>Infomap is a robust algorithm designed to find community structures in a graph that requires some pre-processing steps. This implementation needs a reciprocated or an undirected graph, as well as the ranking score from the normalized weighted version of the Pagerank algorithm. It will assign a unique module (or community) label to each vertex in the graph based on their Pagerank score, edge weights and the labels of their neighbors. It is an iterative algorithm that updates the labels of the vertices in random order on each iteration using the previous factors, converging once there are no further changes in the vertex labels, or once the maximum number of iterations is reached. The algorithm is non-deterministic because of the random order for visiting and updating the vertex labels, thus the communities found might be different each time the algorithm is run.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O((k ^ 2) * E) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(10 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the undirected graph.</dd>
<dd><code>rank</code> - vertex property holding the normalized (weighted) PageRank value for each vertex (a value between 0 and 1).</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>tau</code> - damping factor.</dd>
<dd><code>tol</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; weight = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = analyst.weightedPagerank(graph, 1e-16, 0.85, 1000, true, weight);
 VertexProperty&lt;Integer, Long&gt; module = graph.createVertexProperty(PropertyType.LONG);
 Partition&lt;Integer&gt; promise = analyst.communitiesInfomap(graph, rank, weight, 0.15, 0.0001, 10);
 first_component = promise.getPartitionByIndex(0)
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="communitiesInfomap-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-double-double-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesInfomap</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;communitiesInfomap(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                             double&nbsp;tau,
                                             double&nbsp;tol,
                                             int&nbsp;maxIter,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;module)
                                      throws java.util.concurrent.ExecutionException,
                                             java.lang.InterruptedException</pre>
<div class="block"><p>Infomap can find high quality communities in a graph.
</p>
      <h2>Definition</h2>
      <p>Infomap is a robust algorithm designed to find community structures in a graph that requires some pre-processing steps. This implementation needs a reciprocated or an undirected graph, as well as the ranking score from the normalized weighted version of the Pagerank algorithm. It will assign a unique module (or community) label to each vertex in the graph based on their Pagerank score, edge weights and the labels of their neighbors. It is an iterative algorithm that updates the labels of the vertices in random order on each iteration using the previous factors, converging once there are no further changes in the vertex labels, or once the maximum number of iterations is reached. The algorithm is non-deterministic because of the random order for visiting and updating the vertex labels, thus the communities found might be different each time the algorithm is run.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O((k ^ 2) * E) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(10 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the undirected graph.</dd>
<dd><code>rank</code> - vertex property holding the normalized (weighted) PageRank value for each vertex (a value between 0 and 1).</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>tau</code> - damping factor.</dd>
<dd><code>tol</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dd><code>module</code> - vertex property holding the label of the community assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; weight = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = analyst.weightedPagerank(graph, 1e-16, 0.85, 1000, true, weight);
 VertexProperty&lt;Integer, Long&gt; module = graph.createVertexProperty(PropertyType.LONG);
 Partition&lt;Integer&gt; promise = analyst.communitiesInfomap(graph, rank, weight, 0.15, 0.0001, 10, module);
 first_component = promise.getPartitionByIndex(0)
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="communitiesInfomap-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesInfomap</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;communitiesInfomap(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;module)
                                      throws java.util.concurrent.ExecutionException,
                                             java.lang.InterruptedException</pre>
<div class="block"><p>Infomap can find high quality communities in a graph.
</p>
      <h2>Definition</h2>
      <p>Infomap is a robust algorithm designed to find community structures in a graph that requires some pre-processing steps. This implementation needs a reciprocated or an undirected graph, as well as the ranking score from the normalized weighted version of the Pagerank algorithm. It will assign a unique module (or community) label to each vertex in the graph based on their Pagerank score, edge weights and the labels of their neighbors. It is an iterative algorithm that updates the labels of the vertices in random order on each iteration using the previous factors, converging once there are no further changes in the vertex labels, or once the maximum number of iterations is reached. The algorithm is non-deterministic because of the random order for visiting and updating the vertex labels, thus the communities found might be different each time the algorithm is run.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O((k ^ 2) * E) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(10 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the undirected graph.</dd>
<dd><code>rank</code> - vertex property holding the normalized (weighted) PageRank value for each vertex (a value between 0 and 1).</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>module</code> - vertex property holding the label of the community assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; weight = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = analyst.weightedPagerank(graph, 1e-16, 0.85, 1000, true, weight);
 VertexProperty&lt;Integer, Long&gt; module = graph.createVertexProperty(PropertyType.LONG);
 Partition&lt;Integer&gt; promise = analyst.communitiesInfomap(graph, rank, weight, module);
 first_component = promise.getPartitionByIndex(0)
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="communitiesInfomapAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesInfomapAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;communitiesInfomapAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>Infomap can find high quality communities in a graph.
</p>
      <h2>Definition</h2>
      <p>Infomap is a robust algorithm designed to find community structures in a graph that requires some pre-processing steps. This implementation needs a reciprocated or an undirected graph, as well as the ranking score from the normalized weighted version of the Pagerank algorithm. It will assign a unique module (or community) label to each vertex in the graph based on their Pagerank score, edge weights and the labels of their neighbors. It is an iterative algorithm that updates the labels of the vertices in random order on each iteration using the previous factors, converging once there are no further changes in the vertex labels, or once the maximum number of iterations is reached. The algorithm is non-deterministic because of the random order for visiting and updating the vertex labels, thus the communities found might be different each time the algorithm is run.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O((k ^ 2) * E) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(10 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the undirected graph.</dd>
<dd><code>rank</code> - vertex property holding the normalized (weighted) PageRank value for each vertex (a value between 0 and 1).</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; weight = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = analyst.weightedPagerank(graph, 1e-16, 0.85, 1000, true, weight);
 VertexProperty&lt;Integer, Long&gt; module = graph.createVertexProperty(PropertyType.LONG);
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.communitiesInfomapAsync(graph, rank, weight);
 partition = promise.get()
 first_component = partition.getPartitionByIndex(0)
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="communitiesInfomapAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesInfomapAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;communitiesInfomapAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                             double&nbsp;tau,
                                                             double&nbsp;tol,
                                                             int&nbsp;maxIter)</pre>
<div class="block"><p>Infomap can find high quality communities in a graph.
</p>
      <h2>Definition</h2>
      <p>Infomap is a robust algorithm designed to find community structures in a graph that requires some pre-processing steps. This implementation needs a reciprocated or an undirected graph, as well as the ranking score from the normalized weighted version of the Pagerank algorithm. It will assign a unique module (or community) label to each vertex in the graph based on their Pagerank score, edge weights and the labels of their neighbors. It is an iterative algorithm that updates the labels of the vertices in random order on each iteration using the previous factors, converging once there are no further changes in the vertex labels, or once the maximum number of iterations is reached. The algorithm is non-deterministic because of the random order for visiting and updating the vertex labels, thus the communities found might be different each time the algorithm is run.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O((k ^ 2) * E) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(10 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the undirected graph.</dd>
<dd><code>rank</code> - vertex property holding the normalized (weighted) PageRank value for each vertex (a value between 0 and 1).</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>tau</code> - damping factor.</dd>
<dd><code>tol</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; weight = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = analyst.weightedPagerank(graph, 1e-16, 0.85, 1000, true, weight);
 VertexProperty&lt;Integer, Long&gt; module = graph.createVertexProperty(PropertyType.LONG);
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.communitiesInfomapAsync(graph, rank, weight, 0.15, 0.0001, 10);
 partition = promise.get()
 first_component = partition.getPartitionByIndex(0)
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="communitiesInfomapAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-double-double-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesInfomapAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;communitiesInfomapAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                             double&nbsp;tau,
                                                             double&nbsp;tol,
                                                             int&nbsp;maxIter,
                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;module)</pre>
<div class="block"><p>Infomap can find high quality communities in a graph.
</p>
      <h2>Definition</h2>
      <p>Infomap is a robust algorithm designed to find community structures in a graph that requires some pre-processing steps. This implementation needs a reciprocated or an undirected graph, as well as the ranking score from the normalized weighted version of the Pagerank algorithm. It will assign a unique module (or community) label to each vertex in the graph based on their Pagerank score, edge weights and the labels of their neighbors. It is an iterative algorithm that updates the labels of the vertices in random order on each iteration using the previous factors, converging once there are no further changes in the vertex labels, or once the maximum number of iterations is reached. The algorithm is non-deterministic because of the random order for visiting and updating the vertex labels, thus the communities found might be different each time the algorithm is run.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O((k ^ 2) * E) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(10 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the undirected graph.</dd>
<dd><code>rank</code> - vertex property holding the normalized (weighted) PageRank value for each vertex (a value between 0 and 1).</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>tau</code> - damping factor.</dd>
<dd><code>tol</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dd><code>module</code> - vertex property holding the label of the community assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; weight = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = analyst.weightedPagerank(graph, 1e-16, 0.85, 1000, true, weight);
 VertexProperty&lt;Integer, Long&gt; module = graph.createVertexProperty(PropertyType.LONG);
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.communitiesInfomapAsync(graph, rank, weight, 0.15, 0.0001,
    10, module);
 partition = promise.get()
 first_component = partition.getPartitionByIndex(0)
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="communitiesInfomapAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesInfomapAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;communitiesInfomapAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank,
                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;module)</pre>
<div class="block"><p>Infomap can find high quality communities in a graph.
</p>
      <h2>Definition</h2>
      <p>Infomap is a robust algorithm designed to find community structures in a graph that requires some pre-processing steps. This implementation needs a reciprocated or an undirected graph, as well as the ranking score from the normalized weighted version of the Pagerank algorithm. It will assign a unique module (or community) label to each vertex in the graph based on their Pagerank score, edge weights and the labels of their neighbors. It is an iterative algorithm that updates the labels of the vertices in random order on each iteration using the previous factors, converging once there are no further changes in the vertex labels, or once the maximum number of iterations is reached. The algorithm is non-deterministic because of the random order for visiting and updating the vertex labels, thus the communities found might be different each time the algorithm is run.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O((k ^ 2) * E) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(10 * V + 2 * E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the undirected graph.</dd>
<dd><code>rank</code> - vertex property holding the normalized (weighted) PageRank value for each vertex (a value between 0 and 1).</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>module</code> - vertex property holding the label of the community assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; weight = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = analyst.weightedPagerank(graph, 1e-16, 0.85, 1000, true, weight);
 VertexProperty&lt;Integer, Long&gt; module = graph.createVertexProperty(PropertyType.LONG);
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.communitiesInfomapAsync(graph, rank, weight, module);
 partition = promise.get()
 first_component = partition.getPartitionByIndex(0)
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="communitiesLabelPropagation-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesLabelPropagation</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;communitiesLabelPropagation(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                               throws java.util.concurrent.ExecutionException,
                                                      java.lang.InterruptedException</pre>
<div class="block"><p>Label propagation can find communities in a graph relatively fast
</p>
      <h2>Definition</h2>
      <p>Label Propagation is an algorithm designed to find community structures in a graph. It assigns a unique community label to each vertex in the graph, which then is updated on each iteration by looking and choosing the most frequent label amongst those from its neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; conductance = analyst.communitiesLabelPropagation(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="communitiesLabelPropagation-oracle.pgx.api.PgxGraph-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesLabelPropagation</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;communitiesLabelPropagation(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                      int&nbsp;maxIterations)
                                               throws java.util.concurrent.ExecutionException,
                                                      java.lang.InterruptedException</pre>
<div class="block"><p>Label propagation can find communities in a graph relatively fast
</p>
      <h2>Definition</h2>
      <p>Label Propagation is an algorithm designed to find community structures in a graph. It assigns a unique community label to each vertex in the graph, which then is updated on each iteration by looking and choosing the most frequent label amongst those from its neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>maxIterations</code> - maximum number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; conductance = analyst.communitiesLabelPropagation(graph, 100);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="communitiesLabelPropagation-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesLabelPropagation</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;communitiesLabelPropagation(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                      int&nbsp;maxIterations,
                                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)
                                               throws java.util.concurrent.ExecutionException,
                                                      java.lang.InterruptedException</pre>
<div class="block"><p>Label propagation can find communities in a graph relatively fast
</p>
      <h2>Definition</h2>
      <p>Label Propagation is an algorithm designed to find community structures in a graph. It assigns a unique community label to each vertex in the graph, which then is updated on each iteration by looking and choosing the most frequent label amongst those from its neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>maxIterations</code> - maximum number of iterations that will be performed.</dd>
<dd><code>partitionDistribution</code> - vertex property holding the label of the community assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Long&gt; pd = graph.createVertexProperty(PropertyType.LONG);
 Partition&lt;Integer&gt; conductance = analyst.communitiesLabelPropagation(graph, 100, pd);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="communitiesLabelPropagation-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesLabelPropagation</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;communitiesLabelPropagation(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitonDistribution)
                                               throws java.util.concurrent.ExecutionException,
                                                      java.lang.InterruptedException</pre>
<div class="block"><p>Label propagation can find communities in a graph relatively fast
</p>
      <h2>Definition</h2>
      <p>Label Propagation is an algorithm designed to find community structures in a graph. It assigns a unique community label to each vertex in the graph, which then is updated on each iteration by looking and choosing the most frequent label amongst those from its neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partitonDistribution</code> - vertex property holding the label of the community assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Long&gt; pd = graph.createVertexProperty(PropertyType.LONG);
 Partition&lt;Integer&gt; conductance = analyst.communitiesLabelPropagation(graph, pd);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="communitiesLabelPropagationAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesLabelPropagationAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;communitiesLabelPropagationAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Label propagation can find communities in a graph relatively fast
</p>
      <h2>Definition</h2>
      <p>Label Propagation is an algorithm designed to find community structures in a graph. It assigns a unique community label to each vertex in the graph, which then is updated on each iteration by looking and choosing the most frequent label amongst those from its neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.communitiesLabelPropagationAsync(graph);
 promise.thenCompose(conductance -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="communitiesLabelPropagationAsync-oracle.pgx.api.PgxGraph-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesLabelPropagationAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;communitiesLabelPropagationAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                      int&nbsp;maxIterations)</pre>
<div class="block"><p>Label propagation can find communities in a graph relatively fast
</p>
      <h2>Definition</h2>
      <p>Label Propagation is an algorithm designed to find community structures in a graph. It assigns a unique community label to each vertex in the graph, which then is updated on each iteration by looking and choosing the most frequent label amongst those from its neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>maxIterations</code> - maximum number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.communitiesLabelPropagationAsync(graph, 100);
 promise.thenCompose(conductance -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="communitiesLabelPropagationAsync-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesLabelPropagationAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;communitiesLabelPropagationAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                      int&nbsp;maxIterations,
                                                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</pre>
<div class="block"><p>Label propagation can find communities in a graph relatively fast
</p>
      <h2>Definition</h2>
      <p>Label Propagation is an algorithm designed to find community structures in a graph. It assigns a unique community label to each vertex in the graph, which then is updated on each iteration by looking and choosing the most frequent label amongst those from its neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>maxIterations</code> - maximum number of iterations that will be performed.</dd>
<dd><code>partitionDistribution</code> - vertex property holding the label of the community assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Long&gt; pd = graph.createVertexProperty(PropertyType.LONG);
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.communitiesLabelPropagationAsync(graph, 100, pd);
 promise.thenCompose(conductance -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="communitiesLabelPropagationAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communitiesLabelPropagationAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;communitiesLabelPropagationAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</pre>
<div class="block"><p>Label propagation can find communities in a graph relatively fast
</p>
      <h2>Definition</h2>
      <p>Label Propagation is an algorithm designed to find community structures in a graph. It assigns a unique community label to each vertex in the graph, which then is updated on each iteration by looking and choosing the most frequent label amongst those from its neighbors. Convergence is achieved once the label of each vertex is the same as the most frequent one amongst its neighbors, i.e. when there are no changes in the communities assigned to the vertices in one iteration.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Community detection can be used for clustering and can be applied to the analysis of organization in real-world scenarios like groups of people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partitionDistribution</code> - vertex property holding the label of the community assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the communities found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Long&gt; pd = graph.createVertexProperty(PropertyType.LONG);
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.communitiesLabelPropagationAsync(graph, pd);
 promise.thenCompose(conductance -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + conductance.getPropertyName() + " MATCH (x) ORDER BY x." + conductance.getPropertyName() +
   " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="computeHighDegreeVertices-oracle.pgx.api.PgxGraph-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeHighDegreeVertices</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;,<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;&nbsp;computeHighDegreeVertices(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                  int&nbsp;k)
                                                                                           throws java.util.concurrent.ExecutionException,
                                                                                                  java.lang.InterruptedException</pre>
<div class="block"><p>Computes the k vertices with the highest degrees in the graph.
</p>
      <h2>Definition</h2>
      <p>Computes the k vertices with the highest degrees in the graph. The resulting map will contain a mapping with the sorted index to the high-degree vertex with the index.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(N log N) with N = number of vertices</code></li>
        <li>Space: <code>O(k) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Can be used to compute the vertices with the highest degrees a.k.a. super-vertices. This information can be useful in certain applications.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>k</code> - number of high-degree vertices to be computed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a map with the top <code>k</code> high-degree vertices and their indices and a second
 vertex set containing the same vertices.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="computeHighDegreeVertices-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeHighDegreeVertices</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;,<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;&nbsp;computeHighDegreeVertices(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                  int&nbsp;k,
                                                                                                  <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                                                                                  <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices)
                                                                                           throws java.util.concurrent.ExecutionException,
                                                                                                  java.lang.InterruptedException</pre>
<div class="block"><p>Computes the k vertices with the highest degrees in the graph.
</p>
      <h2>Definition</h2>
      <p>Computes the k vertices with the highest degrees in the graph. The resulting map will contain a mapping with the sorted index to the high-degree vertex with the index.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(N log N) with N = number of vertices</code></li>
        <li>Space: <code>O(k) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Can be used to compute the vertices with the highest degrees a.k.a. super-vertices. This information can be useful in certain applications.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>k</code> - number of high-degree vertices to be computed.</dd>
<dd><code>highDegreeVertexMapping</code> - (out argument)
                                the high-degree vertices.</dd>
<dd><code>highDegreeVertices</code> - (out argument)
                                the high-degree vertices.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a map with the top <code>k</code> high-degree vertices and their indices and a
 second vertex set containing the same vertices.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="computeHighDegreeVerticesAsync-oracle.pgx.api.PgxGraph-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeHighDegreeVerticesAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;,<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;&gt;&nbsp;computeHighDegreeVerticesAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                  int&nbsp;k)</pre>
<div class="block"><p>Computes the k vertices with the highest degrees in the graph.
</p>
      <h2>Definition</h2>
      <p>Computes the k vertices with the highest degrees in the graph. The resulting map will contain a mapping with the sorted index to the high-degree vertex with the index.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(N log N) with N = number of vertices</code></li>
        <li>Space: <code>O(k) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Can be used to compute the vertices with the highest degrees a.k.a. super-vertices. This information can be useful in certain applications.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>k</code> - number of high-degree vertices to be computed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a map with the top <code>k</code> high-degree vertices and their indices and a second
 vertex set containing the same vertices.</dd>
</dl>
</li>
</ul>
<a name="computeHighDegreeVerticesAsync-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeHighDegreeVerticesAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;,<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;&gt;&nbsp;computeHighDegreeVerticesAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                  int&nbsp;k,
                                                                                                                  <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                                                                                                  <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices)</pre>
<div class="block"><p>Computes the k vertices with the highest degrees in the graph.
</p>
      <h2>Definition</h2>
      <p>Computes the k vertices with the highest degrees in the graph. The resulting map will contain a mapping with the sorted index to the high-degree vertex with the index.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(N log N) with N = number of vertices</code></li>
        <li>Space: <code>O(k) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Can be used to compute the vertices with the highest degrees a.k.a. super-vertices. This information can be useful in certain applications.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>k</code> - number of high-degree vertices to be computed.</dd>
<dd><code>highDegreeVertexMapping</code> - (out-argument)
 the high-degree vertices.</dd>
<dd><code>highDegreeVertices</code> - (out-argument)
 the high-degree vertices.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a map with the top <code>k</code> high-degree vertices and their indices and a second
 vertex set containing the same vertices.</dd>
</dl>
</li>
</ul>
<a name="conductance-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>conductance</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;conductance(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                 <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                                                 long&nbsp;partitionIndex)
                                          throws java.util.concurrent.ExecutionException,
                                                 java.lang.InterruptedException</pre>
<div class="block"><p>Conductance assesses the quality of a partition in a graph
</p>
      <h2>Definition</h2>
      <p>Conductance in a graph is computed for a specific cut of it. A cut is a partition of the graph into two subsets (components), disconnecting the graph if the edges from the cut are removed. Thus the algorithm requires a labeling for the vertices in the different subsets of the graph, then the conductance is computed by the ratio of the edges belonging to the given cut (i.e. the edges that split the graph into disconnected components) and the edges belonging to each of these subsets. If there is more than one cut (or partition), this implementation will take the given component number as reference to compute the conductance associated with that particular cut.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(1)</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>num: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Conductance can be used to measure how well connected a graph is, making it an useful auxiliar measure to assess the quality of clusters in a graph, since these could be regarded as the subsets of a cut.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partition</code> - Partition of the graph with the corresponding node collections.</dd>
<dd><code>partitionIndex</code> - number of the component to be used for computing its conductance.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Scalar (double) to store the conductance value of the given cut.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; partition = analyst.communitiesConductanceMinimization(graph);
 Scalar&lt;Double&gt; conductance = analyst.conductance(graph, partition, 0);
 conductance.get();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Conductance_(graph)">Graph Conductance.</a></dd>
</dl>
</li>
</ul>
<a name="conductance-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-long-oracle.pgx.api.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>conductance</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;conductance(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                 <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                                                 long&nbsp;partitionIndex,
                                                 <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;conductance)
                                          throws java.util.concurrent.ExecutionException,
                                                 java.lang.InterruptedException</pre>
<div class="block"><p>Conductance assesses the quality of a partition in a graph
</p>
      <h2>Definition</h2>
      <p>Conductance in a graph is computed for a specific cut of it. A cut is a partition of the graph into two subsets (components), disconnecting the graph if the edges from the cut are removed. Thus the algorithm requires a labeling for the vertices in the different subsets of the graph, then the conductance is computed by the ratio of the edges belonging to the given cut (i.e. the edges that split the graph into disconnected components) and the edges belonging to each of these subsets. If there is more than one cut (or partition), this implementation will take the given component number as reference to compute the conductance associated with that particular cut.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(1)</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>num: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Conductance can be used to measure how well connected a graph is, making it an useful auxiliar measure to assess the quality of clusters in a graph, since these could be regarded as the subsets of a cut.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partition</code> - Partition of the graph with the corresponding node collections.</dd>
<dd><code>partitionIndex</code> - number of the component to be used for computing its conductance.</dd>
<dd><code>conductance</code> - Scalar (double) to store the conductance value of the given cut.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Scalar (double) to store the conductance value of the given cut.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; partition = analyst.communitiesConductanceMinimization(graph);
 Scalar&lt;Double&gt; scalar = graph.createScalar(PropertyType.DOUBLE);
 Scalar&lt;Double&gt; conductance = analyst.conductance(graph, partition, 0, scalar);
 conductance.get();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Conductance_(graph)">Graph Conductance.</a></dd>
</dl>
</li>
</ul>
<a name="conductanceAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>conductanceAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;&nbsp;conductanceAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                 <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                                                                 long&nbsp;partitionIndex)</pre>
<div class="block"><p>Conductance assesses the quality of a partition in a graph
</p>
      <h2>Definition</h2>
      <p>Conductance in a graph is computed for a specific cut of it. A cut is a partition of the graph into two subsets (components), disconnecting the graph if the edges from the cut are removed. Thus the algorithm requires a labeling for the vertices in the different subsets of the graph, then the conductance is computed by the ratio of the edges belonging to the given cut (i.e. the edges that split the graph into disconnected components) and the edges belonging to each of these subsets. If there is more than one cut (or partition), this implementation will take the given component number as reference to compute the conductance associated with that particular cut.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(1)</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>num: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Conductance can be used to measure how well connected a graph is, making it an useful auxiliar measure to assess the quality of clusters in a graph, since these could be regarded as the subsets of a cut.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partition</code> - Partition of the graph with the corresponding node collections.</dd>
<dd><code>partitionIndex</code> - number of the component to be used for computing its conductance.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Scalar (double) to store the conductance value of the given cut.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; partition = analyst.communitiesConductanceMinimization(graph);
 PgxFuture&lt;Scalar&lt;Double&gt;&gt; promise = analyst.conductanceAsync(graph, partition, 0);
 promise.thenAccept(conductance -&gt; {
   conductance.get();
 });
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Conductance_(graph)">Graph Conductance.</a></dd>
</dl>
</li>
</ul>
<a name="conductanceAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-long-oracle.pgx.api.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>conductanceAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;&nbsp;conductanceAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                 <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                                                                 long&nbsp;partitionIndex,
                                                                 <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;conductance)</pre>
<div class="block"><p>Conductance assesses the quality of a partition in a graph
</p>
      <h2>Definition</h2>
      <p>Conductance in a graph is computed for a specific cut of it. A cut is a partition of the graph into two subsets (components), disconnecting the graph if the edges from the cut are removed. Thus the algorithm requires a labeling for the vertices in the different subsets of the graph, then the conductance is computed by the ratio of the edges belonging to the given cut (i.e. the edges that split the graph into disconnected components) and the edges belonging to each of these subsets. If there is more than one cut (or partition), this implementation will take the given component number as reference to compute the conductance associated with that particular cut.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(1)</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>num: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Conductance can be used to measure how well connected a graph is, making it an useful auxiliar measure to assess the quality of clusters in a graph, since these could be regarded as the subsets of a cut.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partition</code> - Partition of the graph with the corresponding node collections.</dd>
<dd><code>partitionIndex</code> - number of the component to be used for computing its conductance.</dd>
<dd><code>conductance</code> - Scalar (double) to store the conductance value of the given cut.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Scalar (double) to store the conductance value of the given cut.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Scalar&lt;Double&gt; scalar = graph.createScalar(PropertyType.DOUBLE);
 Partition&lt;Integer&gt; partition = analyst.communitiesConductanceMinimization(graph);
 PgxFuture&lt;Scalar&lt;Double&gt;&gt; promise = analyst.conductanceAsync(graph, partition, 0, scalar);
 promise.thenAccept(conductance -&gt; {
   conductance.get();
 });
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Conductance_(graph)">Graph Conductance.</a></dd>
</dl>
</li>
</ul>
<a name="countTriangles-oracle.pgx.api.PgxGraph-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countTriangles</h4>
<pre>public&nbsp;long&nbsp;countTriangles(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                           boolean&nbsp;sortVerticesByDegree)
                    throws java.util.concurrent.ExecutionException,
                           java.lang.InterruptedException</pre>
<div class="block"><p>triangle counting gives an overview of the amount of connections between vertices in neighborhoods
</p>
      <h2>Definition</h2>
      <p>This algorithm is intended for directed graphs and will count all the existing triangles on it. To run the algorithm on undirected graphs, use the undirected version.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E ^ 1.5) with E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Triangles in graphs can be used as a measure of the quality in social networks, they can help to find communities within graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>sortVerticesByDegree</code> - boolean flag for sorting the nodes by their degree as preprocessing step.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>returns the total number of triangles found.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 long result = analyst.countTriangles(graph, true);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="countTrianglesAsync-oracle.pgx.api.PgxGraph-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countTrianglesAsync</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;java.lang.Long&gt;&nbsp;countTrianglesAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                     boolean&nbsp;sortVerticesByDegree)</pre>
<div class="block"><p>triangle counting gives an overview of the amount of connections between vertices in neighborhoods
</p>
      <h2>Definition</h2>
      <p>This algorithm is intended for directed graphs and will count all the existing triangles on it. To run the algorithm on undirected graphs, use the undirected version.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E ^ 1.5) with E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Triangles in graphs can be used as a measure of the quality in social networks, they can help to find communities within graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>sortVerticesByDegree</code> - boolean flag for sorting the nodes by their degree as preprocessing step.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>returns the total number of triangles found.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;Long&gt; promise = analyst.countTrianglesAsync(graph, true);
 promise.thenAccept(result -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="createDistanceIndex-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createDistanceIndex</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;createDistanceIndex(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                              <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                                                              <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices)
                                                                       throws java.util.concurrent.ExecutionException,
                                                                              java.lang.InterruptedException</pre>
<div class="block"><p>Computes an index with distances to each high-degree vertex.
</p>
      <h2>Definition</h2>
      <p>Computes an index which contains the distance to the given high-degree vertices for every node in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= number of high-degree vertices</code></li>
        <li>Space: <code>O(V * k) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The index can be used to speed up certain path-finding algorithms.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>highDegreeVertexMapping</code> - map containing the high-degree vertices as values and indices from 0 to k as keys.</dd>
<dd><code>highDegreeVertices</code> - a set containing the high-degree vertices.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A vertex-integer-vector property containing the distances from each high-degree vertex for each vertex
 in the graph.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="createDistanceIndex-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createDistanceIndex</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;createDistanceIndex(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                              <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                                                              <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                                                                              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index)
                                                                       throws java.util.concurrent.ExecutionException,
                                                                              java.lang.InterruptedException</pre>
<div class="block"><p>Computes an index with distances to each high-degree vertex.
</p>
      <h2>Definition</h2>
      <p>Computes an index which contains the distance to the given high-degree vertices for every node in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= number of high-degree vertices</code></li>
        <li>Space: <code>O(V * k) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The index can be used to speed up certain path-finding algorithms.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>highDegreeVertexMapping</code> - map containing the high-degree vertices as values and indices from 0 to k as keys.</dd>
<dd><code>highDegreeVertices</code> - a set containing the high-degree vertices.</dd>
<dd><code>index</code> - (out-argument)
 the index containing the distances to each high-degree vertex for all vertices.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A vertex-integer-vector property containing the distances from each high-degree vertex for each vertex
 in the graph.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="createDistanceIndexAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createDistanceIndexAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&gt;&nbsp;createDistanceIndexAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                              <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                                                                              <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices)</pre>
<div class="block"><p>Computes an index with distances to each high-degree vertex.
</p>
      <h2>Definition</h2>
      <p>Computes an index which contains the distance to the given high-degree vertices for every node in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= number of high-degree vertices</code></li>
        <li>Space: <code>O(V * k) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The index can be used to speed up certain path-finding algorithms.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>highDegreeVertexMapping</code> - map containing the high-degree vertices as values and indices from 0 to k as keys.</dd>
<dd><code>highDegreeVertices</code> - a set containing the high-degree vertices.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A vertex-integer-vector property containing the distances from each high-degree vertex for each vertex
 in the graph.</dd>
</dl>
</li>
</ul>
<a name="createDistanceIndexAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createDistanceIndexAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&gt;&nbsp;createDistanceIndexAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                              <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                                                                              <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                                                                                              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index)</pre>
<div class="block"><p>Computes an index with distances to each high-degree vertex.
</p>
      <h2>Definition</h2>
      <p>Computes an index which contains the distance to the given high-degree vertices for every node in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= number of high-degree vertices</code></li>
        <li>Space: <code>O(V * k) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The index can be used to speed up certain path-finding algorithms.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>highDegreeVertexMapping</code> - map containing the high-degree vertices as values and indices from 0 to k as keys.</dd>
<dd><code>highDegreeVertices</code> - a set containing the high-degree vertices.</dd>
<dd><code>index</code> - (out-argument)
 the index containing the distances to each high-degree vertex for all vertices.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A vertex-integer-vector property containing the distances from each high-degree vertex for each vertex
 in the graph.</dd>
</dl>
</li>
</ul>
<a name="deepWalkModelBuilder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deepWalkModelBuilder</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/mllib/DeepWalkModelBuilder.html" title="class in oracle.pgx.api.mllib">DeepWalkModelBuilder</a>&nbsp;deepWalkModelBuilder()</pre>
<div class="block">Builder for Deepwalk model</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the builder</dd>
</dl>
</li>
</ul>
<a name="degreeCentrality-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>degreeCentrality</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;degreeCentrality(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block"><p>Degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood
</p>
      <h2>Definition</h2>
      <p>Degree centrality counts the number of outgoing and incoming edges for each vertex in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since degree centrality accounts for the connections of the vertices, it can be used to see the influence a vertex has over the vertices in its immediate neighborhood.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the degree centrality value for each vertex in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Integer&gt; degree = analyst.degreeCentrality(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + degree.getName() + " MATCH (x) ORDER BY x." + degree.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="degreeCentrality-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>degreeCentrality</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;degreeCentrality(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;dc)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block"><p>Degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood
</p>
      <h2>Definition</h2>
      <p>Degree centrality counts the number of outgoing and incoming edges for each vertex in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since degree centrality accounts for the connections of the vertices, it can be used to see the influence a vertex has over the vertices in its immediate neighborhood.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>dc</code> - (out argument)
    vertex property holding the degree centrality value for each vertex in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the degree centrality value for each vertex in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Integer&gt; dc = graph.createVertexProperty(PropertyType.INTEGER);
 VertexProperty&lt;Integer, Integer&gt; degree = analyst.degreeCentrality(graph, dc);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + degree.getName() + " MATCH (x) ORDER BY x." + degree.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="degreeCentralityAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>degreeCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;degreeCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood
</p>
      <h2>Definition</h2>
      <p>Degree centrality counts the number of outgoing and incoming edges for each vertex in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since degree centrality accounts for the connections of the vertices, it can be used to see the influence a vertex has over the vertices in its immediate neighborhood.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the degree centrality value for each vertex in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Integer&gt;&gt; promise = analyst.degreeCentralityAsync(graph);
 promise.thenCompose(degree -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + degree.getName() + " MATCH (x) ORDER BY x." + degree.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="degreeCentralityAsync-oracle.pgx.api.PgxGraph-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>degreeCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;degreeCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                  java.lang.String&nbsp;propertyName)</pre>
</li>
</ul>
<a name="degreeCentralityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>degreeCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;degreeCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;dc)</pre>
<div class="block"><p>Degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood
</p>
      <h2>Definition</h2>
      <p>Degree centrality counts the number of outgoing and incoming edges for each vertex in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since degree centrality accounts for the connections of the vertices, it can be used to see the influence a vertex has over the vertices in its immediate neighborhood.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>dc</code> - (out argument)
    vertex property holding the degree centrality value for each vertex in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the degree centrality value for each vertex in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Integer&gt; dc = graph.createVertexProperty(PropertyType.INTEGER);
 PgxFuture&lt;VertexProperty&lt;Integer, Integer&gt;&gt; promise = analyst.degreeCentralityAsync(graph, dc);
 promise.thenCompose(degree -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + degree.getName() + " MATCH (x) ORDER BY x." + degree.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="destroyAsync--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>destroyAsync</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;java.lang.Void&gt;&nbsp;destroyAsync()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="../../../oracle/pgx/api/Destroyable.html#destroyAsync--">Destroyable</a></code></span></div>
<div class="block">Requests destruction of this object. After this method returns, the behavior of any method of this class becomes
 undefined.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../oracle/pgx/api/Destroyable.html#destroyAsync--">destroyAsync</a></code>&nbsp;in class&nbsp;<code><a href="../../../oracle/pgx/api/Destroyable.html" title="class in oracle.pgx.api">Destroyable</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a future which will be completed once the destruction request finishes.</dd>
</dl>
</li>
</ul>
<a name="diameter-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>diameter</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;diameter(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                                                   throws java.util.concurrent.ExecutionException,
                                                                                          java.lang.InterruptedException</pre>
<div class="block"><p>Diameter/radius gives an overview of the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortest paths to any other vertex in the graph. This algorithm will compute the eccentricity of all the vertices and will also return the diameter or radius value depending on the request. The algorithm will return an INF eccentricity and diameter/radius, for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortest paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>diameterOn: true</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the diameter of the graph and a node property with eccentricity value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Pair&lt;Scalar&lt;Integer&gt;, VertexProperty&lt;Integer, Integer&gt;&gt; diameter = analyst.diameter(graph);
 diameter.getFirst().get();
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + diameter.getSecond().getName() + " MATCH (x) ORDER BY x." + diameter.getSecond().getName() +
   " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="diameter-oracle.pgx.api.PgxGraph-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>diameter</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;diameter(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                          <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;&nbsp;diameter,
                                                                                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;eccentricity)
                                                                                   throws java.util.concurrent.ExecutionException,
                                                                                          java.lang.InterruptedException</pre>
<div class="block"><p>Diameter/radius gives an overview of the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortest paths to any other vertex in the graph. This algorithm will compute the eccentricity of all the vertices and will also return the diameter or radius value depending on the request. The algorithm will return an INF eccentricity and diameter/radius, for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortest paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>diameterOn: true</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>diameter</code> - Scalar (integer) for holding the value of the diameter of the graph.</dd>
<dd><code>eccentricity</code> - (out argument) vertex property holding the eccentricity value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the diameter of the graph and a node property with eccentricity value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Scalar&lt;Integer&gt; scalar = graph.createScalar(PropertyType.INTEGER);
 VertexProperty&lt;Integer, Integer&gt; prop = graph.CreateVertexProperty(PropertyType.INTEGER);
 Pair&lt;Scalar&lt;Integer&gt;, VertexProperty&lt;Integer, Integer&gt;&gt; diameter = analyst.diameter(graph, scalar, prop);
 diameter.getFirst().get();
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + diameter.getSecond().getName() + " MATCH (x) ORDER BY x." + diameter.getSecond().getName() +
   " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="diameterAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>diameterAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&gt;&nbsp;diameterAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Diameter/radius gives an overview of the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortest paths to any other vertex in the graph. This algorithm will compute the eccentricity of all the vertices and will also return the diameter or radius value depending on the request. The algorithm will return an INF eccentricity and diameter/radius, for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortest paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>diameterOn: true</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the diameter of the graph and a node property with eccentricity value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;Pair&lt;Scalar&lt;Integer&gt;, VertexProperty&lt;Integer, Integer&gt;&gt;&gt; promise = analyst.diameterAsync(graph);
 promise.thenCompose(diameter -&gt; {
   diameter.getFirst().get();
   graph.queryPgqlAsync(
     "SELECT x, x." + diameter.getSecond().getName() + " MATCH (x) ORDER BY x." + diameter.getSecond().getName() +
     " DESC"))
     .thenAccept(PgqlResultSet::print);
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="diameterAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>diameterAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&gt;&nbsp;diameterAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                          <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;&nbsp;diameter,
                                                                                                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;eccentricity)</pre>
<div class="block"><p>Diameter/radius gives an overview of the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortest paths to any other vertex in the graph. This algorithm will compute the eccentricity of all the vertices and will also return the diameter or radius value depending on the request. The algorithm will return an INF eccentricity and diameter/radius, for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortest paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>diameterOn: true</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>diameter</code> - Scalar (integer) for holding the value of the diameter of the graph.</dd>
<dd><code>eccentricity</code> - (out argument) vertex property holding the eccentricity value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the diameter of the graph and a node property with eccentricity value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Scalar&lt;Integer&gt; scalar = graph.createScalar(PropertyType.INTEGER);
 VertexProperty&lt;Integer, Integer&gt; prop = graph.createVertexProperty(PropertyType.INTEGER);
 PgxFuture&lt;Pair&lt;Scalar&lt;Integer&gt;, VertexProperty&lt;Integer, Integer&gt;&gt;&gt; promise = analyst.diameterAsync(
   graph, scalar, prop);
 promise.thenCompose(diameter -&gt; {
   diameter.getFirst().get();
   graph.queryPgqlAsync(
     "SELECT x, x." + diameter.getSecond().getName() + " MATCH (x) ORDER BY x." + diameter.getSecond().getName() +
     " DESC"))
     .thenAccept(PgqlResultSet::print);
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="eigenvectorCentrality-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eigenvectorCentrality</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;eigenvectorCentrality(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                               throws java.util.concurrent.ExecutionException,
                                                                      java.lang.InterruptedException</pre>
<div class="block"><p>Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>The Eigenvector Centrality determines the centrality of a vertex by adding and weighting the centrality of its neighbors. Using outgoing or incoming edges when computing the eigenvector centrality will be equivalent to do so with the normal or the transpose adjacency matrix, respectively leading to the "right" and "left" eigenvectors.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the power iteration method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * k) with V = number of vertices, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
<li>max_diff: 0.001</li>
<li>use_l2norm: false</li>
<li>use_inEdges: false</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The eigenvector centrality assigns higher scores to vertices that are connected to other well-connected vertices in the graphs, making this algorithm a good option to find important or relevant people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; eigenvector = analyst.eigenvectorCentrality(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + eigenvector.getName() + " MATCH (x) ORDER BY x." + eigenvector.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="eigenvectorCentrality-oracle.pgx.api.PgxGraph-int-double-boolean-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eigenvectorCentrality</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;eigenvectorCentrality(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                      int&nbsp;max,
                                                                      double&nbsp;maxDiff,
                                                                      boolean&nbsp;useL2Norm,
                                                                      boolean&nbsp;useInEdge)
                                                               throws java.util.concurrent.ExecutionException,
                                                                      java.lang.InterruptedException</pre>
<div class="block"><p>Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>The Eigenvector Centrality determines the centrality of a vertex by adding and weighting the centrality of its neighbors. Using outgoing or incoming edges when computing the eigenvector centrality will be equivalent to do so with the normal or the transpose adjacency matrix, respectively leading to the "right" and "left" eigenvectors.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the power iteration method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * k) with V = number of vertices, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
<li>max_diff: 0.001</li>
<li>use_l2norm: false</li>
<li>use_inEdges: false</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The eigenvector centrality assigns higher scores to vertices that are connected to other well-connected vertices in the graphs, making this algorithm a good option to find important or relevant people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>useL2Norm</code> - boolean flag to determine whether the algorithm will use the l2 norm (Euclidean norm) or the l1 norm (absolute value) to normalize the centrality scores.</dd>
<dd><code>useInEdge</code> - boolean flag to determine whether the algorithm will use the incoming or the outgoing edges in the graph for the computations.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; eigenvector = analyst.eigenvectorCentrality(graph, 100, 0.001, false, false);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + eigenvector.getName() + " MATCH (x) ORDER BY x." + eigenvector.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="eigenvectorCentrality-oracle.pgx.api.PgxGraph-int-double-boolean-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eigenvectorCentrality</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;eigenvectorCentrality(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                      int&nbsp;max,
                                                                      double&nbsp;maxDiff,
                                                                      boolean&nbsp;useL2Norm,
                                                                      boolean&nbsp;useInEdge,
                                                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;ec)
                                                               throws java.util.concurrent.ExecutionException,
                                                                      java.lang.InterruptedException</pre>
<div class="block"><p>Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>The Eigenvector Centrality determines the centrality of a vertex by adding and weighting the centrality of its neighbors. Using outgoing or incoming edges when computing the eigenvector centrality will be equivalent to do so with the normal or the transpose adjacency matrix, respectively leading to the "right" and "left" eigenvectors.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the power iteration method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * k) with V = number of vertices, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
<li>max_diff: 0.001</li>
<li>use_l2norm: false</li>
<li>use_inEdges: false</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The eigenvector centrality assigns higher scores to vertices that are connected to other well-connected vertices in the graphs, making this algorithm a good option to find important or relevant people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>useL2Norm</code> - boolean flag to determine whether the algorithm will use the l2 norm (Euclidean norm) or the l1 norm (absolute value) to normalize the centrality scores.</dd>
<dd><code>useInEdge</code> - boolean flag to determine whether the algorithm will use the incoming or the outgoing edges in the graph for the computations.</dd>
<dd><code>ec</code> - (out argument)
    vertex property holding the normalized centrality value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; ec = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; eigenvector = analyst.eigenvectorCentrality(graph, 100, 0.001, false, false, ec);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + eigenvector.getName() + " MATCH (x) ORDER BY x." + eigenvector.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="eigenvectorCentrality-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eigenvectorCentrality</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;eigenvectorCentrality(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;ec)
                                                               throws java.util.concurrent.ExecutionException,
                                                                      java.lang.InterruptedException</pre>
<div class="block"><p>Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>The Eigenvector Centrality determines the centrality of a vertex by adding and weighting the centrality of its neighbors. Using outgoing or incoming edges when computing the eigenvector centrality will be equivalent to do so with the normal or the transpose adjacency matrix, respectively leading to the "right" and "left" eigenvectors.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the power iteration method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * k) with V = number of vertices, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
<li>max_diff: 0.001</li>
<li>use_l2norm: false</li>
<li>use_inEdges: false</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The eigenvector centrality assigns higher scores to vertices that are connected to other well-connected vertices in the graphs, making this algorithm a good option to find important or relevant people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>ec</code> - (out argument)
    vertex property holding the normalized centrality value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; ec = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; eigenvector = analyst.eigenvectorCentrality(graph, ec);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + eigenvector.getName() + " MATCH (x) ORDER BY x." + eigenvector.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="eigenvectorCentralityAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eigenvectorCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;eigenvectorCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>The Eigenvector Centrality determines the centrality of a vertex by adding and weighting the centrality of its neighbors. Using outgoing or incoming edges when computing the eigenvector centrality will be equivalent to do so with the normal or the transpose adjacency matrix, respectively leading to the "right" and "left" eigenvectors.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the power iteration method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * k) with V = number of vertices, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
<li>max_diff: 0.001</li>
<li>use_l2norm: false</li>
<li>use_inEdges: false</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The eigenvector centrality assigns higher scores to vertices that are connected to other well-connected vertices in the graphs, making this algorithm a good option to find important or relevant people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.eigenvectorCentralityAsync(graph);
 promise.thenCompose(eigenvector -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + eigenvector.getName() + " MATCH (x) ORDER BY x." + eigenvector.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="eigenvectorCentralityAsync-oracle.pgx.api.PgxGraph-int-double-boolean-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eigenvectorCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;eigenvectorCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                      int&nbsp;max,
                                                                                      double&nbsp;maxDiff,
                                                                                      boolean&nbsp;useL2Norm,
                                                                                      boolean&nbsp;useInEdge)</pre>
<div class="block"><p>Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>The Eigenvector Centrality determines the centrality of a vertex by adding and weighting the centrality of its neighbors. Using outgoing or incoming edges when computing the eigenvector centrality will be equivalent to do so with the normal or the transpose adjacency matrix, respectively leading to the "right" and "left" eigenvectors.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the power iteration method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * k) with V = number of vertices, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
<li>max_diff: 0.001</li>
<li>use_l2norm: false</li>
<li>use_inEdges: false</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The eigenvector centrality assigns higher scores to vertices that are connected to other well-connected vertices in the graphs, making this algorithm a good option to find important or relevant people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>useL2Norm</code> - boolean flag to determine whether the algorithm will use the l2 norm (Euclidean norm) or the l1 norm (absolute value) to normalize the centrality scores.</dd>
<dd><code>useInEdge</code> - boolean flag to determine whether the algorithm will use the incoming or the outgoing edges in the graph for the computations.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.eigenvectorCentralityAsync(
   graph, 100, 0.001, false, false);
 promise.thenCompose(eigenvector -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + eigenvector.getName() + " MATCH (x) ORDER BY x." + eigenvector.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="eigenvectorCentralityAsync-oracle.pgx.api.PgxGraph-int-double-boolean-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eigenvectorCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;eigenvectorCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                      int&nbsp;max,
                                                                                      double&nbsp;maxDiff,
                                                                                      boolean&nbsp;useL2Norm,
                                                                                      boolean&nbsp;useInEdge,
                                                                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;ec)</pre>
<div class="block"><p>Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>The Eigenvector Centrality determines the centrality of a vertex by adding and weighting the centrality of its neighbors. Using outgoing or incoming edges when computing the eigenvector centrality will be equivalent to do so with the normal or the transpose adjacency matrix, respectively leading to the "right" and "left" eigenvectors.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the power iteration method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * k) with V = number of vertices, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
<li>max_diff: 0.001</li>
<li>use_l2norm: false</li>
<li>use_inEdges: false</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The eigenvector centrality assigns higher scores to vertices that are connected to other well-connected vertices in the graphs, making this algorithm a good option to find important or relevant people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>useL2Norm</code> - boolean flag to determine whether the algorithm will use the l2 norm (Euclidean norm) or the l1 norm (absolute value) to normalize the centrality scores.</dd>
<dd><code>useInEdge</code> - boolean flag to determine whether the algorithm will use the incoming or the outgoing edges in the graph for the computations.</dd>
<dd><code>ec</code> - (out argument)
    vertex property holding the normalized centrality value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; ec = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.eigenvectorCentralityAsync(
   graph, 100, 0.001, false, false, ec);
 promise.thenCompose(eigenvector -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + eigenvector.getName() + " MATCH (x) ORDER BY x." + eigenvector.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="eigenvectorCentralityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eigenvectorCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;eigenvectorCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;ec)</pre>
<div class="block"><p>Eigenvector centrality gets the centrality of the vertices in an intrincated way using neighbors, allowing to find well-connected vertices
</p>
      <h2>Definition</h2>
      <p>The Eigenvector Centrality determines the centrality of a vertex by adding and weighting the centrality of its neighbors. Using outgoing or incoming edges when computing the eigenvector centrality will be equivalent to do so with the normal or the transpose adjacency matrix, respectively leading to the "right" and "left" eigenvectors.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the power iteration method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * k) with V = number of vertices, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
<li>max_diff: 0.001</li>
<li>use_l2norm: false</li>
<li>use_inEdges: false</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The eigenvector centrality assigns higher scores to vertices that are connected to other well-connected vertices in the graphs, making this algorithm a good option to find important or relevant people in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>ec</code> - (out argument)
    vertex property holding the normalized centrality value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; ec = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.eigenvectorCentralityAsync(graph, ec);
 promise.thenCompose(eigenvector -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + eigenvector.getName() + " MATCH (x) ORDER BY x." + eigenvector.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="enumerateSimplePaths-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.VertexSet-oracle.pgx.api.EdgeSet-oracle.pgx.api.PgxMap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enumerateSimplePaths</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;org.apache.commons.lang3.tuple.Triple&lt;<a href="../../../oracle/pgx/api/ScalarSequence.html" title="class in oracle.pgx.api">ScalarSequence</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;&nbsp;enumerateSimplePaths(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                                                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                                                                                          int&nbsp;k,
                                                                                                                                          <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&nbsp;verticesOnPath,
                                                                                                                                          <a href="../../../oracle/pgx/api/EdgeSet.html" title="class in oracle.pgx.api">EdgeSet</a>&nbsp;edgesOnPath,
                                                                                                                                          <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&nbsp;dist)
                                                                                                                                   throws java.util.concurrent.ExecutionException,
                                                                                                                                          java.lang.InterruptedException</pre>
<div class="block"><p>Enumerate all simple paths between the source and destination vertex
</p>
      <h2>Definition</h2>
      <p>Enumerate all simple paths between the source and destination vertex
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex.</dd>
<dd><code>dst</code> - the destination vertex.</dd>
<dd><code>k</code> - the dimension of the distances property; i.e. number of high-degree vertices.</dd>
<dd><code>verticesOnPath</code> - the vertices on the path.</dd>
<dd><code>edgesOnPath</code> - the edges on the path.</dd>
<dd><code>dist</code> - map containing the distance from the source vertex for each vertex on a path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>Triple</code> containing a sequence containing the path lengths, a vertex-sequence containing the
 vertices on the paths and an edge-sequence containing the edges on the paths</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="enumerateSimplePathsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.VertexSet-oracle.pgx.api.EdgeSet-oracle.pgx.api.PgxMap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enumerateSimplePathsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;org.apache.commons.lang3.tuple.Triple&lt;<a href="../../../oracle/pgx/api/ScalarSequence.html" title="class in oracle.pgx.api">ScalarSequence</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;&gt;&nbsp;enumerateSimplePathsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                                                                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                                                                                                          int&nbsp;k,
                                                                                                                                                          <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&nbsp;verticesOnPath,
                                                                                                                                                          <a href="../../../oracle/pgx/api/EdgeSet.html" title="class in oracle.pgx.api">EdgeSet</a>&nbsp;edgesOnPath,
                                                                                                                                                          <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&nbsp;dist)</pre>
<div class="block"><p>Enumerate all simple paths between the source and destination vertex
</p>
      <h2>Definition</h2>
      <p>Enumerate all simple paths between the source and destination vertex
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex.</dd>
<dd><code>dst</code> - the destination vertex.</dd>
<dd><code>k</code> - the dimension of the distances property; i.e. number of high-degree vertices.</dd>
<dd><code>verticesOnPath</code> - the vertices on the path.</dd>
<dd><code>edgesOnPath</code> - the edges on the path.</dd>
<dd><code>dist</code> - map containing the distance from the source vertex for each vertex on a path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>Triple</code> containing a sequence containing the path lengths, a vertex-sequence containing the
 vertices on the paths and an edge-sequence containing the edges on the paths</dd>
</dl>
</li>
</ul>
<a name="fattestPath-oracle.pgx.api.PgxGraph-java.lang.Object-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a><a name="fattestPath-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fattestPath</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;fattestPath(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                     ID&nbsp;rootId,
                                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;capacity)
                              throws java.util.concurrent.ExecutionException,
                                     java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#fattestPath-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-"><code>fattestPath(PgxGraph, PgxVertex, EdgeProperty)</code></a> taking a vertex ID instead of a
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="fattestPath-oracle.pgx.api.PgxGraph-java.lang.Object-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a><a name="fattestPath-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fattestPath</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;fattestPath(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                     ID&nbsp;rootId,
                                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;capacity,
                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                              throws java.util.concurrent.ExecutionException,
                                     java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#fattestPath-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-"><code>fattestPath(PgxGraph, PgxVertex, EdgeProperty, VertexProperty,
 VertexProperty, VertexProperty)</code></a> taking a vertex ID instead of a
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="fattestPath-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fattestPath</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;fattestPath(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;capacity)
                              throws java.util.concurrent.ExecutionException,
                                     java.lang.InterruptedException</pre>
<div class="block"><p>Fattest path is a fast algorithm for finding a shortest path adding constraints for flowing related matters
</p>
      <h2>Definition</h2>
      <p>The Fattest path algorithm can be regarded as a variant of Dijkstra's algorithm, it tries to find the fattest path between the given source and all the reachable vertices in the graph. The fatness of a path is equal to the minimum value of the capacity from the edges that take part in the path, thus a fattest path is conformed by the edges with the largest possible capacity.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>capacity</code> - edge property holding the capacity of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible fattest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; root = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 AllPaths&lt;Integer&gt; fattestPath = analyst.fattestPath(graph, root, cost);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="fattestPath-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fattestPath</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;fattestPath(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;capacity,
                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                              throws java.util.concurrent.ExecutionException,
                                     java.lang.InterruptedException</pre>
<div class="block"><p>Fattest path is a fast algorithm for finding a shortest path adding constraints for flowing related matters
</p>
      <h2>Definition</h2>
      <p>The Fattest path algorithm can be regarded as a variant of Dijkstra's algorithm, it tries to find the fattest path between the given source and all the reachable vertices in the graph. The fatness of a path is equal to the minimum value of the capacity from the edges that take part in the path, thus a fattest path is conformed by the edges with the largest possible capacity.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>capacity</code> - edge property holding the capacity of each edge in the graph.</dd>
<dd><code>distance</code> - (out argument) vertex property holding the capacity value of the fattest path up to the current vertex. The fatness value for the source vertex will be INF, while it will be 0 for all the vertices that are not reachable from the source.</dd>
<dd><code>parent</code> - (out argument) vertex property holding the parent vertex of the each vertex in the fattest path.</dd>
<dd><code>parentEdge</code> - (out argument) vertex property holding the edge ID linking the current vertex in the path with the previous vertex in the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible fattest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; root = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; distance = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 AllPaths&lt;Integer&gt; fattestPath = analyst.fattestPath(graph, root, cost, distance, parent, parentEdge);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="fattestPathAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fattestPathAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;&nbsp;fattestPathAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;capacity)</pre>
<div class="block"><p>Fattest path is a fast algorithm for finding a shortest path adding constraints for flowing related matters
</p>
      <h2>Definition</h2>
      <p>The Fattest path algorithm can be regarded as a variant of Dijkstra's algorithm, it tries to find the fattest path between the given source and all the reachable vertices in the graph. The fatness of a path is equal to the minimum value of the capacity from the edges that take part in the path, thus a fattest path is conformed by the edges with the largest possible capacity.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>capacity</code> - edge property holding the capacity of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible fattest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; root = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;AllPaths&lt;Integer&gt;&gt; promise = analyst.fattestPathAsync(graph, root, cost);
 promise.thenAccept(paths -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="fattestPathAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fattestPathAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;&nbsp;fattestPathAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;capacity,
                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</pre>
<div class="block"><p>Fattest path is a fast algorithm for finding a shortest path adding constraints for flowing related matters
</p>
      <h2>Definition</h2>
      <p>The Fattest path algorithm can be regarded as a variant of Dijkstra's algorithm, it tries to find the fattest path between the given source and all the reachable vertices in the graph. The fatness of a path is equal to the minimum value of the capacity from the edges that take part in the path, thus a fattest path is conformed by the edges with the largest possible capacity.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>capacity</code> - edge property holding the capacity of each edge in the graph.</dd>
<dd><code>distance</code> - (out argument) vertex property holding the capacity value of the fattest path up to the current vertex. The fatness value for the source vertex will be INF, while it will be 0 for all the vertices that are not reachable from the source.</dd>
<dd><code>parent</code> - (out argument) vertex property holding the parent vertex of the each vertex in the fattest path.</dd>
<dd><code>parentEdge</code> - (out argument) vertex property holding the edge ID linking the current vertex in the path with the previous vertex in the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible fattest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; root = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; distance = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 PgxFuture&lt;AllPaths&lt;Integer&gt;&gt; promise = analyst.fattestPathAsync(graph, root, cost, distance, parent, parentEdge);
 promise.thenAccept(paths -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="filteredBfs-oracle.pgx.api.PgxGraph-java.lang.Object-">
<!--   -->
</a><a name="filteredBfs-oracle.pgx.api.PgxGraph-ID-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredBfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    ID&nbsp;root)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-"><code>filteredBfs(PgxGraph, PgxVertex)</code></a>
 taking a vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="filteredBfs-oracle.pgx.api.PgxGraph-java.lang.Object-int-">
<!--   -->
</a><a name="filteredBfs-oracle.pgx.api.PgxGraph-ID-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredBfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    ID&nbsp;root,
                                                                                                    int&nbsp;maxDepth)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-"><code>filteredBfs(PgxGraph, PgxVertex, int)</code></a>
 taking a vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredBfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; bfs =
   analyst.filteredBfs(graph, vertex);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredBfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                    int&nbsp;maxDepth)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; bfs =
   analyst.filteredBfs(graph, vertex, 2);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredBfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; bfs =
   analyst.filteredBfs(graph, vertex, navigator);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredBfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                    boolean&nbsp;initWithInf)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; bfs =
   analyst.filteredBfs(graph, vertex, navigator, true);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredBfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                    boolean&nbsp;initWithInf,
                                                                                                    int&nbsp;maxDepth)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; bfs =
   analyst.filteredBfs(graph, vertex, navigator, true, 2);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredBfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                    boolean&nbsp;initWithInf,
                                                                                                    int&nbsp;maxDepth,
                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dd><code>distance</code> - (out argument) vertex property holding the hop distance for each reachable vertex in the graph.</dd>
<dd><code>parent</code> - (out argument) vertex property holding the parent vertex of the each reachable vertex in the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 VertexProperty&lt;Integer, Integer&gt; distance = graph.createVertexProperty(PropertyType.INTEGER);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; bfs =
   analyst.filteredBfs(graph, vertex, navigator, true, distance, parent);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredBfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                    boolean&nbsp;initWithInf,
                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dd><code>distance</code> - (out argument) vertex property holding the hop distance for each reachable vertex in the graph.</dd>
<dd><code>parent</code> - (out argument) vertex property holding the parent vertex of the each reachable vertex in the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 VertexProperty&lt;Integer, Integer&gt; distance = graph.createVertexProperty(PropertyType.INTEGER);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; bfs =
   analyst.filteredBfs(graph, vertex, navigator, true, distance, parent);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredBfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredBfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                    int&nbsp;maxDepth)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; bfs =
   analyst.filteredBfs(graph, vertex, navigator, 2);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredBfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root)</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredBfsAsync(graph, vertex);
 promise.thenCompose(bfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredBfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                                    int&nbsp;maxDepth)</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredBfsAsync(graph, vertex, 2);
 promise.thenCompose(bfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredBfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator)</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredBfsAsync(graph, vertex, navigator);
 promise.thenCompose(bfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredBfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                                    boolean&nbsp;initWithInf)</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredBfsAsync(graph, vertex, filter, navigator, true);
 promise.thenCompose(bfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredBfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                                    boolean&nbsp;initWithInf,
                                                                                                                    int&nbsp;maxDepth)</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredBfsAsync(graph, vertex, navigator, true, 2);
 promise.thenCompose(bfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredBfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                                    boolean&nbsp;initWithInf,
                                                                                                                    int&nbsp;maxDepth,
                                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
                                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dd><code>distance</code> - (out argument) vertex property holding the hop distance for each reachable vertex in the graph.</dd>
<dd><code>parent</code> - (out argument) vertex property holding the parent vertex of the each reachable vertex in the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 VertexProperty&lt;Integer, Integer&gt; distance = graph.createVertexProperty(PropertyType.INTEGER);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredBfsAsync(graph, vertex, navigator, true, 2, distance, parent);
 promise.thenCompose(bfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredBfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                                    boolean&nbsp;initWithInf,
                                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
                                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dd><code>distance</code> - (out argument) vertex property holding the hop distance for each reachable vertex in the graph.</dd>
<dd><code>parent</code> - (out argument) vertex property holding the parent vertex of the each reachable vertex in the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 VertexProperty&lt;Integer, Integer&gt; distance = graph.createVertexProperty(PropertyType.INTEGER);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredBfsAsync(graph, vertex, navigator, true, distance, parent);
 promise.thenCompose(bfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredBfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredBfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredBfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                                    int&nbsp;maxDepth)</pre>
<div class="block"><p>A Breadth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the BFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using BFS.</li>
<li>You can use BFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredBfsAsync(graph, vertex, navigator, 2);
 promise.thenCompose(bfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + bfs.getFirst().getName() + ", x." + bfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   bfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfs-oracle.pgx.api.PgxGraph-java.lang.Object-">
<!--   -->
</a><a name="filteredDfs-oracle.pgx.api.PgxGraph-ID-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredDfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    ID&nbsp;root)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-"><code>filteredDfs(PgxGraph, PgxVertex)</code></a>
 taking a vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="filteredDfs-oracle.pgx.api.PgxGraph-java.lang.Object-int-">
<!--   -->
</a><a name="filteredDfs-oracle.pgx.api.PgxGraph-ID-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredDfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    ID&nbsp;root,
                                                                                                    int&nbsp;maxDepth)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-"><code>filteredDfs(PgxGraph, PgxVertex, int)</code></a>
 taking a vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredDfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; dfs =
   analyst.filteredDfs(graph, vertex);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredDfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                    int&nbsp;maxDepth)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; dfs =
   analyst.filteredDfs(graph, vertex, 2);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredDfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; dfs =
   analyst.filteredDfs(graph, vertex, navigator);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredDfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                    boolean&nbsp;initWithInf)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; dfs =
   analyst.filteredDfs(graph, vertex, navigator, true);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredDfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                    boolean&nbsp;initWithInf,
                                                                                                    int&nbsp;maxDepth)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; dfs =
   analyst.filteredDfs(graph, vertex, navigator, true, 2);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredDfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                    boolean&nbsp;initWithInf,
                                                                                                    int&nbsp;maxDepth,
                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dd><code>distance</code> - (out argument) vertex property holding the hop distance for each reachable vertex in the graph.</dd>
<dd><code>parent</code> - (out argument) vertex property holding the parent vertex of the each reachable vertex in the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 VertexProperty&lt;Integer, Integer&gt; distance = graph.createVertexProperty(PropertyType.INTEGER);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; dfs =
   analyst.filteredDfs(graph, vertex, navigator, true, distance, parent);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredDfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                    boolean&nbsp;initWithInf,
                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dd><code>distance</code> - (out argument) vertex property holding the hop distance for each reachable vertex in the graph.</dd>
<dd><code>parent</code> - (out argument) vertex property holding the parent vertex of the each reachable vertex in the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 VertexProperty&lt;Integer, Integer&gt; distance = graph.createVertexProperty(PropertyType.INTEGER);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; dfs =
   analyst.filteredDfs(graph, vertex, navigator, true, distance, parent);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfs-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfs</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&nbsp;filteredDfs(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                    int&nbsp;maxDepth)
                                                                                             throws java.util.concurrent.ExecutionException,
                                                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt; dfs =
   analyst.filteredDfs(graph, vertex, navigator, 2);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredDfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root)</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredDfsAsync(graph, vertex);
 promise.thenCompose(dfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredDfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                                    int&nbsp;maxDepth)</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredDfsAsync(graph, vertex, 2);
 promise.thenCompose(dfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredDfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator)</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredDfsAsync(graph, vertex, filter, navigator);
 promise.thenCompose(dfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredDfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                                    boolean&nbsp;initWithInf)</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredDfsAsync(graph, vertex, filter, navigator, true);
 promise.thenCompose(dfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredDfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                                    boolean&nbsp;initWithInf,
                                                                                                                    int&nbsp;maxDepth)</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredDfsAsync(graph, vertex, filter, navigator, true, 2);
 promise.thenCompose(dfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredDfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                                    boolean&nbsp;initWithInf,
                                                                                                                    int&nbsp;maxDepth,
                                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
                                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dd><code>distance</code> - (out argument) vertex property holding the hop distance for each reachable vertex in the graph.</dd>
<dd><code>parent</code> - (out argument) vertex property holding the parent vertex of the each reachable vertex in the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 VertexProperty&lt;Integer, Integer&gt; distance = graph.createVertexProperty(PropertyType.INTEGER);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredDfsAsync(graph, vertex, filter, navigator, true, 2, distance, parent);
 promise.thenCompose(dfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-boolean-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredDfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                                    boolean&nbsp;initWithInf,
                                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;distance,
                                                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent)</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>initWithInf</code> - boolean flag to set the initial distance values of the vertices. If set to true, it will initialize the distances as INF, and -1 otherwise.</dd>
<dd><code>distance</code> - (out argument) vertex property holding the hop distance for each reachable vertex in the graph.</dd>
<dd><code>parent</code> - (out argument) vertex property holding the parent vertex of the each reachable vertex in the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter navigator = VertexFilter.ALL;
 VertexProperty&lt;Integer, Integer&gt; distance = graph.createVertexProperty(PropertyType.INTEGER);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredDfsAsync(graph, vertex, filter, navigator, true, distance, parent);
 promise.thenCompose(dfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="filteredDfsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.filter.VertexFilter-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteredDfsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&gt;&gt;&nbsp;filteredDfsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;root,
                                                                                                                    <a href="../../../oracle/pgx/api/filter/VertexFilter.html" title="class in oracle.pgx.api.filter">VertexFilter</a>&nbsp;navigator,
                                                                                                                    int&nbsp;maxDepth)</pre>
<div class="block"><p>A Depth-First Search implementation with an option to filter edges during the traversal of the graph.
</p>
      <h2>Definition</h2>
      <p>This filtered version of the DFS algorithm allows to use a filter and a navigator expression to be evaluated over the vertices during the traversal and discriminate them according to the desired criteria. It will return the distance to the source vertex and the corresponding parent vertex for all the filtered vertices.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>In social networks, you can find people within a given distance from a person using DFS.</li>
<li>You can use DFS to find if there is a path between two vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>root</code> - the source vertex from the graph for the path.</dd>
<dd><code>navigator</code> - navigator expression to be evaluated on the vertices during the graph traversal.</dd>
<dd><code>maxDepth</code> - maximum depth limit for the BFS traversal.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding first a node property with the hop distance for each reachable node in the graph and a second
    node property with the parent node of each reachable node in the path.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexFilter filter = VertexFilter.ALL;
 VertexFilter navigator = VertexFilter.ALL;
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Integer&gt;, VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt;&gt;&gt; promise =
   analyst.filteredDfsAsync(graph, vertex, filter, navigator, 2);
 promise.thenCompose(dfs -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + dfs.getFirst().getName() + ", x." + dfs.getSecond().getName() + " MATCH (x) ORDER BY x." +
   dfs.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>20.1.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></dd>
</dl>
</li>
</ul>
<a name="findCycle-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findCycle</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;findCycle(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                           throws java.util.concurrent.ExecutionException,
                                  java.lang.InterruptedException</pre>
<div class="block"><p>Find cycle looks for any loop in the graph.
</p>
      <h2>Definition</h2>
      <p>This algorithm tries to find a cycle in a directed graph using DFS traversals and will return the first cycle found, if there is one. In such case, the vertices and edges involved in the cycle will be returned in the order of visit. The algorithm is expensive because it will perform DFS traversals using different vertices as starting points until it explores the whole graph (worst-case scenario), or until it finds a cycle.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in DFS feature. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * (V + E)) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(5 * V + E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Cycles in a graph can be useful in problems related to routes and flows.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath representing the cycle as path, if exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxPath&lt;Integer&gt; cycle = analyst.findCycle(graph);
 cycle.getPathLengthWithCost();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="findCycle-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findCycle</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;findCycle(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src)
                           throws java.util.concurrent.ExecutionException,
                                  java.lang.InterruptedException</pre>
<div class="block"><p>Find cycle looks for any loop in the graph.
</p>
      <h2>Definition</h2>
      <p>This implementation tries to find a cycle in a directed graph using the given vertex as starting point for the DFS traversal and will return the first cycle found, if there is one. In such case, the vertices and edges involved in the cycle will be returned in the order of visit. Restricting the DFS traversal to a single starting point means that some parts of the graph may not get explored.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V + E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>s: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Cycles in a graph can be useful in problems related to routes and flows.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - source vertex for the search.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath representing the cycle as path, if exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxPath&lt;Integer&gt; cycle = analyst.findCycle(graph, vertex);
 cycle.getPathLengthWithCost();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="findCycle-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findCycle</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;findCycle(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                  <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;nodeSeq,
                                  <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;edgeSeq)
                           throws java.util.concurrent.ExecutionException,
                                  java.lang.InterruptedException</pre>
<div class="block"><p>Find cycle looks for any loop in the graph.
</p>
      <h2>Definition</h2>
      <p>This implementation tries to find a cycle in a directed graph using the given vertex as starting point for the DFS traversal and will return the first cycle found, if there is one. In such case, the vertices and edges involved in the cycle will be returned in the order of visit. Restricting the DFS traversal to a single starting point means that some parts of the graph may not get explored.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V + E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>s: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Cycles in a graph can be useful in problems related to routes and flows.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - source vertex for the search.</dd>
<dd><code>nodeSeq</code> - (out argument)
                    vertex sequence holding the vertices in the cycle.</dd>
<dd><code>edgeSeq</code> - (out argument)
                    edge sequence holding the edges in the cycle.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath representing the cycle as path, if exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexSequence&lt;Integer&gt; nodeSeq = graph.createVertexSequence();
 EdgeSequence edgeSeq = graph.createEdgeSequence();
 PgxPath&lt;Integer&gt; cycle = analyst.findCycle(graph, vertex, nodeSeq, edgeSeq);
 cycle.getPathLengthWithCost();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="findCycle-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findCycle</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;findCycle(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                  <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;nodeSeq,
                                  <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;edgeSeq)
                           throws java.util.concurrent.ExecutionException,
                                  java.lang.InterruptedException</pre>
<div class="block"><p>Find cycle looks for any loop in the graph.
</p>
      <h2>Definition</h2>
      <p>This algorithm tries to find a cycle in a directed graph using DFS traversals and will return the first cycle found, if there is one. In such case, the vertices and edges involved in the cycle will be returned in the order of visit. The algorithm is expensive because it will perform DFS traversals using different vertices as starting points until it explores the whole graph (worst-case scenario), or until it finds a cycle.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in DFS feature. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * (V + E)) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(5 * V + E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Cycles in a graph can be useful in problems related to routes and flows.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>nodeSeq</code> - (out argument) vertex sequence holding the vertices in the cycle.</dd>
<dd><code>edgeSeq</code> - (out argument) edge sequence holding the edges in the cycle.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath representing the cycle as path, if exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSequence&lt;Integer&gt; nodeSeq = graph.createVertexSequence();
 EdgeSequence edgeSeq = graph.createEdgeSequence();
 PgxPath&lt;Integer&gt; cycle = analyst.findCycle(graph, nodeSeq, edgeSeq);
 cycle.getPathLengthWithCost();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="findCycleAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findCycleAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;&nbsp;findCycleAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Find cycle looks for any loop in the graph.
</p>
      <h2>Definition</h2>
      <p>This algorithm tries to find a cycle in a directed graph using DFS traversals and will return the first cycle found, if there is one. In such case, the vertices and edges involved in the cycle will be returned in the order of visit. The algorithm is expensive because it will perform DFS traversals using different vertices as starting points until it explores the whole graph (worst-case scenario), or until it finds a cycle.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in DFS feature. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * (V + E)) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(5 * V + E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Cycles in a graph can be useful in problems related to routes and flows.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath representing the cycle as path, if exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;PgxPath&lt;Integer&gt;&gt; promise = analyst.findCycleAsync(graph);
 promise.thenAccept(path -&gt; {
   path.getPathLengthWithCost();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="findCycleAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findCycleAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;&nbsp;findCycleAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src)</pre>
<div class="block"><p>Find cycle looks for any loop in the graph.
</p>
      <h2>Definition</h2>
      <p>This implementation tries to find a cycle in a directed graph using the given vertex as starting point for the DFS traversal and will return the first cycle found, if there is one. In such case, the vertices and edges involved in the cycle will be returned in the order of visit. Restricting the DFS traversal to a single starting point means that some parts of the graph may not get explored.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V + E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>s: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Cycles in a graph can be useful in problems related to routes and flows.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - source vertex for the search.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath representing the cycle as path, if exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxFuture&lt;PgxPath&lt;Integer&gt;&gt; promise = analyst.findCycleAsync(graph, vertex);
 promise.thenAccept(path -&gt; {
   path.getPathLengthWithCost();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="findCycleAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findCycleAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;&nbsp;findCycleAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                  <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;nodeSeq,
                                                  <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;edgeSeq)</pre>
<div class="block"><p>Find cycle looks for any loop in the graph.
</p>
      <h2>Definition</h2>
      <p>This implementation tries to find a cycle in a directed graph using the given vertex as starting point for the DFS traversal and will return the first cycle found, if there is one. In such case, the vertices and edges involved in the cycle will be returned in the order of visit. Restricting the DFS traversal to a single starting point means that some parts of the graph may not get explored.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V + E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>s: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Cycles in a graph can be useful in problems related to routes and flows.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - source vertex for the search.</dd>
<dd><code>nodeSeq</code> - (out argument)
                    vertex sequence holding the vertices in the cycle.</dd>
<dd><code>edgeSeq</code> - (out argument)
                    edge sequence holding the edges in the cycle.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath representing the cycle as path, if exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexSequence&lt;Integer&gt; nodeSeq = graph.createVertexSequence();
 EdgeSequence edgeSeq = graph.createEdgeSequence();
 PgxFuture&lt;PgxPath&lt;Integer&gt;&gt; promise = analyst.findCycleAsync(graph, vertex, nodeSeq, edgeSeq);
 promise.thenAccept(path -&gt; {
   path.getPathLengthWithCost();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="findCycleAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findCycleAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;&nbsp;findCycleAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                  <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;nodeSeq,
                                                  <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;edgeSeq)</pre>
<div class="block"><p>Find cycle looks for any loop in the graph.
</p>
      <h2>Definition</h2>
      <p>This algorithm tries to find a cycle in a directed graph using DFS traversals and will return the first cycle found, if there is one. In such case, the vertices and edges involved in the cycle will be returned in the order of visit. The algorithm is expensive because it will perform DFS traversals using different vertices as starting points until it explores the whole graph (worst-case scenario), or until it finds a cycle.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in DFS feature. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * (V + E)) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(5 * V + E) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Cycles in a graph can be useful in problems related to routes and flows.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>nodeSeq</code> - (out argument) vertex sequence holding the vertices in the cycle.</dd>
<dd><code>edgeSeq</code> - (out argument) edge sequence holding the edges in the cycle.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath representing the cycle as path, if exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSequence&lt;Integer&gt; nodeSeq = graph.createVertexSequence();
 EdgeSequence edgeSeq = graph.createEdgeSequence();
 PgxFuture&lt;PgxPath&lt;Integer&gt;&gt; promise = analyst.findCycleAsync(graph, nodeSeq, edgeSeq);
 promise.thenAccept(path -&gt; {
   path.getPathLengthWithCost();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="getSession--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSession</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/PgxSession.html" title="class in oracle.pgx.api">PgxSession</a>&nbsp;getSession()</pre>
<div class="block">Gets the session.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the PGX session</dd>
</dl>
</li>
</ul>
<a name="graphWiseConvLayerConfigBuilder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>graphWiseConvLayerConfigBuilder</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/mllib/GraphWiseConvLayerConfigBuilder.html" title="class in oracle.pgx.api.mllib">GraphWiseConvLayerConfigBuilder</a>&nbsp;graphWiseConvLayerConfigBuilder()</pre>
<div class="block">Return a GraphWiseLayerConfigBuilder used to create a GraphWiseLayerConfig</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the builder</dd>
</dl>
</li>
</ul>
<a name="graphWiseDgiLayerConfigBuilder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>graphWiseDgiLayerConfigBuilder</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/mllib/GraphWiseDgiLayerConfigBuilder.html" title="class in oracle.pgx.api.mllib">GraphWiseDgiLayerConfigBuilder</a>&nbsp;graphWiseDgiLayerConfigBuilder()</pre>
<div class="block">Return a GraphWiseDgiLayerConfigBuilder used to create a GraphWiseDgiLayerConfig</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the builder</dd>
</dl>
</li>
</ul>
<a name="graphWisePredictionLayerConfigBuilder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>graphWisePredictionLayerConfigBuilder</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/mllib/GraphWisePredictionLayerConfigBuilder.html" title="class in oracle.pgx.api.mllib">GraphWisePredictionLayerConfigBuilder</a>&nbsp;graphWisePredictionLayerConfigBuilder()</pre>
<div class="block">Return a GraphWisePredictionLayerConfigBuilder used to create a GraphWiseLayerConfig</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the builder</dd>
</dl>
</li>
</ul>
<a name="hits-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hits</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;hits(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                                                        throws java.util.concurrent.ExecutionException,
                                                                                               java.lang.InterruptedException</pre>
<div class="block"><p>HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>HITS is an algorithm that computes two ranking scores (authority and hub)for each vertex in the graph. The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific topic, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. The authority score of a vertex V is computed by adding all the hub scores of its incomming neighbors (i.e. vertices with edges pointing to V). The hub score is computed in a similar way, using the authority scores instead.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Both, authority and hub scores, of all the vertices in the graph are computed and updated at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>HITS was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the two vertex properties with the authority and hub scores.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Pair&lt;VertexProperty&lt;Integer, Double&gt;, VertexProperty&lt;Integer, Double&gt;&gt; hits = analyst.hits(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + hits.getFirst().getName() + ", x." + hits.getSecond().getName() + " MATCH (x) ORDER BY x." +
   hits.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="hits-oracle.pgx.api.PgxGraph-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hits</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;hits(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                               int&nbsp;max)
                                                                                        throws java.util.concurrent.ExecutionException,
                                                                                               java.lang.InterruptedException</pre>
<div class="block"><p>HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>HITS is an algorithm that computes two ranking scores (authority and hub)for each vertex in the graph. The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific topic, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. The authority score of a vertex V is computed by adding all the hub scores of its incomming neighbors (i.e. vertices with edges pointing to V). The hub score is computed in a similar way, using the authority scores instead.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Both, authority and hub scores, of all the vertices in the graph are computed and updated at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>HITS was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>max</code> - number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the two vertex properties with the authority and hub scores.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Pair&lt;VertexProperty&lt;Integer, Double&gt;, VertexProperty&lt;Integer, Double&gt;&gt; hits = analyst.hits(graph, 100);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + hits.getFirst().getName() + ", x." + hits.getSecond().getName() + " MATCH (x) ORDER BY x." +
   hits.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="hits-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hits</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;hits(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                               int&nbsp;max,
                                                                                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;auth,
                                                                                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;hubs)
                                                                                        throws java.util.concurrent.ExecutionException,
                                                                                               java.lang.InterruptedException</pre>
<div class="block"><p>HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>HITS is an algorithm that computes two ranking scores (authority and hub)for each vertex in the graph. The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific topic, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. The authority score of a vertex V is computed by adding all the hub scores of its incomming neighbors (i.e. vertices with edges pointing to V). The hub score is computed in a similar way, using the authority scores instead.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Both, authority and hub scores, of all the vertices in the graph are computed and updated at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>HITS was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>max</code> - number of iterations that will be performed.</dd>
<dd><code>auth</code> - (out argument) vertex property holding the authority score for each vertex.</dd>
<dd><code>hubs</code> - (out argument) vertex property holding the hub score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the two vertex properties with the authority and hub scores.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; auth = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; hubs = graph.createVertexProperty(PropertyType.DOUBLE);
 Pair&lt;VertexProperty&lt;Integer, Double&gt;, VertexProperty&lt;Integer, Double&gt;&gt; hits = analyst.hits(graph, 100, auth, hubs);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + hits.getFirst().getName() + ", x." + hits.getSecond().getName() + " MATCH (x) ORDER BY x." +
   hits.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="hits-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hits</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;hits(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;auth,
                                                                                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;hubs)
                                                                                        throws java.util.concurrent.ExecutionException,
                                                                                               java.lang.InterruptedException</pre>
<div class="block"><p>HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>HITS is an algorithm that computes two ranking scores (authority and hub)for each vertex in the graph. The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific topic, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. The authority score of a vertex V is computed by adding all the hub scores of its incomming neighbors (i.e. vertices with edges pointing to V). The hub score is computed in a similar way, using the authority scores instead.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Both, authority and hub scores, of all the vertices in the graph are computed and updated at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>HITS was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>auth</code> - (out argument) vertex property holding the authority score for each vertex.</dd>
<dd><code>hubs</code> - (out argument) vertex property holding the hub score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the two vertex properties with the authority and hub scores.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; auth = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; hubs = graph.createVertexProperty(PropertyType.DOUBLE);
 Pair&lt;VertexProperty&lt;Integer, Double&gt;, VertexProperty&lt;Integer, Double&gt;&gt; hits = analyst.hits(graph, auth, hubs);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + hits.getFirst().getName() + ", x." + hits.getSecond().getName() + " MATCH (x) ORDER BY x." +
   hits.getFirst().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="hitsAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hitsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&gt;&nbsp;hitsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>HITS is an algorithm that computes two ranking scores (authority and hub)for each vertex in the graph. The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific topic, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. The authority score of a vertex V is computed by adding all the hub scores of its incomming neighbors (i.e. vertices with edges pointing to V). The hub score is computed in a similar way, using the authority scores instead.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Both, authority and hub scores, of all the vertices in the graph are computed and updated at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>HITS was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the two vertex properties with the authority and hub scores.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Double&gt;, VertexProperty&lt;Integer, Double&gt;&gt;&gt; promise = analyst.hitsAsync(
   graph);
 promise.thenCompose(hits -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + hits.getFirst().getName() + " x." + hits.getSecond().getName() + " MATCH (x) ORDER BY x." +
   hits.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="hitsAsync-oracle.pgx.api.PgxGraph-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hitsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&gt;&nbsp;hitsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                               int&nbsp;max)</pre>
<div class="block"><p>HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>HITS is an algorithm that computes two ranking scores (authority and hub)for each vertex in the graph. The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific topic, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. The authority score of a vertex V is computed by adding all the hub scores of its incomming neighbors (i.e. vertices with edges pointing to V). The hub score is computed in a similar way, using the authority scores instead.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Both, authority and hub scores, of all the vertices in the graph are computed and updated at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>HITS was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>max</code> - number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the two vertex properties with the authority and hub scores.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Double&gt;, VertexProperty&lt;Integer, Double&gt;&gt;&gt; promise = analyst.hitsAsync(
   graph, 100);
 promise.thenCompose(hits -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + hits.getFirst().getName() + " x." + hits.getSecond().getName() + " MATCH (x) ORDER BY x." +
   hits.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="hitsAsync-oracle.pgx.api.PgxGraph-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hitsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&gt;&nbsp;hitsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                               int&nbsp;max,
                                                                                                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;auth,
                                                                                                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;hubs)</pre>
<div class="block"><p>HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>HITS is an algorithm that computes two ranking scores (authority and hub)for each vertex in the graph. The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific topic, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. The authority score of a vertex V is computed by adding all the hub scores of its incomming neighbors (i.e. vertices with edges pointing to V). The hub score is computed in a similar way, using the authority scores instead.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Both, authority and hub scores, of all the vertices in the graph are computed and updated at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>HITS was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>max</code> - number of iterations that will be performed.</dd>
<dd><code>auth</code> - (out argument) vertex property holding the authority score for each vertex.</dd>
<dd><code>hubs</code> - (out argument) vertex property holding the hub score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the two vertex properties with the authority and hub scores.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; auth = graph.CreateVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; hubs = graph.CreateVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Double&gt;, VertexProperty&lt;Integer, Double&gt;&gt;&gt; promise = analyst.hitsAsync(
   graph, 100, auth, hubs);
 promise.thenCompose(hits -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + hits.getFirst().getName() + " x." + hits.getSecond().getName() + " MATCH (x) ORDER BY x." +
   hits.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="hitsAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hitsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&gt;&nbsp;hitsAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;auth,
                                                                                                               <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;hubs)</pre>
<div class="block"><p>HITS assigns ranking scores to the vertices, aimed to assess the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>HITS is an algorithm that computes two ranking scores (authority and hub)for each vertex in the graph. The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific topic, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. The authority score of a vertex V is computed by adding all the hub scores of its incomming neighbors (i.e. vertices with edges pointing to V). The hub score is computed in a similar way, using the authority scores instead.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Both, authority and hub scores, of all the vertices in the graph are computed and updated at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>HITS was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>auth</code> - (out argument) vertex property holding the authority score for each vertex.</dd>
<dd><code>hubs</code> - (out argument) vertex property holding the hub score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the two vertex properties with the authority and hub scores.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; auth = graph.CreateVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; hubs = graph.CreateVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;Pair&lt;VertexProperty&lt;Integer, Double&gt;, VertexProperty&lt;Integer, Double&gt;&gt;&gt; promise = analyst.hitsAsync(
   graph, auth, hubs);
 promise.thenCompose(hits -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + hits.getFirst().getName() + " x." + hits.getSecond().getName() + " MATCH (x) ORDER BY x." +
   hits.getFirst().getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="inDegreeCentrality-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inDegreeCentrality</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;inDegreeCentrality(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                             throws java.util.concurrent.ExecutionException,
                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>In-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood
</p>
      <h2>Definition</h2>
      <p>In-Degree centrality returns the sum of the number of incoming edges for each vertex in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelism.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since in-degree centrality accounts for the connections of the vertices, it can be used to see the influence a vertex has over the vertices in its immediate neighborhood.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the degree centrality value for each vertex in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Integer&gt; degree = analyst.inDegreeCentrality(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + degree.getName() + " MATCH (x) ORDER BY x." + degree.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="inDegreeCentrality-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inDegreeCentrality</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;inDegreeCentrality(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;dc)
                                                             throws java.util.concurrent.ExecutionException,
                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>In-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood
</p>
      <h2>Definition</h2>
      <p>In-Degree centrality returns the sum of the number of incoming edges for each vertex in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelism.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since in-degree centrality accounts for the connections of the vertices, it can be used to see the influence a vertex has over the vertices in its immediate neighborhood.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>dc</code> - (out argument)
    vertex property holding the degree centrality value for each vertex in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the degree centrality value for each vertex in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Integer&gt; dc = graph.createVertexProperty(PropertyType.INTEGER);
 VertexProperty&lt;Integer, Integer&gt; degree = analyst.inDegreeCentrality(graph, dc);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + degree.getName() + " MATCH (x) ORDER BY x." + degree.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="inDegreeCentralityAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inDegreeCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;inDegreeCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>In-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood
</p>
      <h2>Definition</h2>
      <p>In-Degree centrality returns the sum of the number of incoming edges for each vertex in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelism.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since in-degree centrality accounts for the connections of the vertices, it can be used to see the influence a vertex has over the vertices in its immediate neighborhood.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the degree centrality value for each vertex in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Integer&gt;&gt; promise = analyst.inDegreeCentralityAsync(graph);
 promise.thenCompose(degree -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + degree.getName() + " MATCH (x) ORDER BY x." + degree.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="inDegreeCentralityAsync-oracle.pgx.api.PgxGraph-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inDegreeCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;inDegreeCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                    java.lang.String&nbsp;propertyName)</pre>
</li>
</ul>
<a name="inDegreeCentralityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inDegreeCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;inDegreeCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;dc)</pre>
<div class="block"><p>In-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood
</p>
      <h2>Definition</h2>
      <p>In-Degree centrality returns the sum of the number of incoming edges for each vertex in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelism.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since in-degree centrality accounts for the connections of the vertices, it can be used to see the influence a vertex has over the vertices in its immediate neighborhood.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>dc</code> - (out argument)
    vertex property holding the degree centrality value for each vertex in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the degree centrality value for each vertex in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Integer&gt; dc = graph.createVertexProperty(PropertyType.INTEGER);
 PgxFuture&lt;VertexProperty&lt;Integer, Integer&gt;&gt; promise = analyst.inDegreeCentralityAsync(graph, dc);
 promise.thenCompose(degree -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + degree.getName() + " MATCH (x) ORDER BY x." + degree.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="inDegreeDistribution-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inDegreeDistribution</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&nbsp;inDegreeDistribution(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>In-degree distribution gives information about the incoming flows in a graph
</p>
      <h2>Definition</h2>
      <p>This version of the degree distribution will return a map with the distribution of the in-degree (i.e. just incoming edges) of the graph. For undirected graphs the algorithm will consider all the edges (incoming and outgoing) for the distribution.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way. It uses a map with type int for the keys and type long for storing the mapped values of the distribution, like a histogram.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Degree distribution is a basic structural property of a graph which can help to characterize and classify them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>map holding a histogram of the vertex degrees in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxMap&lt;Integer, Long&gt; degree = analyst.inDegreeDistribution(graph);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="inDegreeDistribution-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inDegreeDistribution</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&nbsp;inDegreeDistribution(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&nbsp;distribution)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>In-degree distribution gives information about the incoming flows in a graph
</p>
      <h2>Definition</h2>
      <p>This version of the degree distribution will return a map with the distribution of the in-degree (i.e. just incoming edges) of the graph. For undirected graphs the algorithm will consider all the edges (incoming and outgoing) for the distribution.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way. It uses a map with type int for the keys and type long for storing the mapped values of the distribution, like a histogram.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Degree distribution is a basic structural property of a graph which can help to characterize and classify them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>distribution</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>map holding a histogram of the vertex degrees in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxMap&lt;Integer, Long&gt; distribution = graph.createMap(PropertyType.INTEGER, PropertyType.LONG);
 PgxMap&lt;Integer, Long&gt; degree = analyst.inDegreeDistribution(graph, distribution);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="inDegreeDistributionAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inDegreeDistributionAsync</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&gt;&nbsp;inDegreeDistributionAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>In-degree distribution gives information about the incoming flows in a graph
</p>
      <h2>Definition</h2>
      <p>This version of the degree distribution will return a map with the distribution of the in-degree (i.e. just incoming edges) of the graph. For undirected graphs the algorithm will consider all the edges (incoming and outgoing) for the distribution.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way. It uses a map with type int for the keys and type long for storing the mapped values of the distribution, like a histogram.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Degree distribution is a basic structural property of a graph which can help to characterize and classify them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>map holding a histogram of the vertex degrees in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;PgxMap&lt;Integer, Long&gt;&gt; promise = analyst.inDegreeDistributionAsync(graph);
 promise.thenAccept(map -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="inDegreeDistributionAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inDegreeDistributionAsync</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&gt;&nbsp;inDegreeDistributionAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&nbsp;distribution)</pre>
<div class="block"><p>In-degree distribution gives information about the incoming flows in a graph
</p>
      <h2>Definition</h2>
      <p>This version of the degree distribution will return a map with the distribution of the in-degree (i.e. just incoming edges) of the graph. For undirected graphs the algorithm will consider all the edges (incoming and outgoing) for the distribution.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way. It uses a map with type int for the keys and type long for storing the mapped values of the distribution, like a histogram.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Degree distribution is a basic structural property of a graph which can help to characterize and classify them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>distribution</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>map holding a histogram of the vertex degrees in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxMap&lt;Integer, Long&gt; distribution = graph.createMap(PropertyType.INTEGER, PropertyType.LONG);
 PgxFuture&lt;PgxMap&lt;Integer, Long&gt;&gt; promise = analyst.inDegreeDistributionAsync(graph, distribution);
 promise.thenAccept(map -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="kcore-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>kcore</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;&nbsp;kcore(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                                          throws java.util.concurrent.ExecutionException,
                                                                                 java.lang.InterruptedException</pre>
<div class="block"><p>k-core decomposes a graph into layers revealing subgraphs with particular properties
</p>
      <h2>Definition</h2>
      <p>A k-core is a maximal subgraph in which all of its vertices are connected and have the property that all of them have a degree of at least k. The k-cores can be regarded as layers in a graph, since a (k+1)-core will always be a subgraph of a k-core. This means that the larger k becomes, the smaller its k-core (i.e. its corresponding subgraph) will be. The k-core value (or coreness) assigned to a vertex will correspond to the core with the gratest degree from all the cores where it belongs. This implementation of k-core will look for cores lying within the interval set by the min_core and max_core input variables.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>K-Core can be used to analyze hierarchical structures in a graph by revealing subgraphs with particular properties. It can also help to visualize large graphs in 2D by using the "layers" provided by the k-cores.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the maximum core found and a node property with the largest k-core value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Pair&lt;Scalar&lt;Long&gt;, VertexProperty&lt;Integer, Long&gt;&gt; kcore = analyst.kcore(graph);
 kcore.getFirst().get();
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + kcore.getSecond().getName() + " MATCH (x) ORDER BY x." + kcore.getSecond().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://arxiv.org/pdf/cs/0310049v1.pdf">An O(m) Algorithm for Cores Decomposition of Networks</a>, 
<a href="https://arxiv.org/pdf/cs/0504107v2.pdf">k-core decomposition: a tool for the visualization of large scale networks</a></dd>
</dl>
</li>
</ul>
<a name="kcore-oracle.pgx.api.PgxGraph-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>kcore</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;&nbsp;kcore(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                 int&nbsp;minCore,
                                                                                 int&nbsp;maxCore)
                                                                          throws java.util.concurrent.ExecutionException,
                                                                                 java.lang.InterruptedException</pre>
<div class="block"><p>k-core decomposes a graph into layers revealing subgraphs with particular properties
</p>
      <h2>Definition</h2>
      <p>A k-core is a maximal subgraph in which all of its vertices are connected and have the property that all of them have a degree of at least k. The k-cores can be regarded as layers in a graph, since a (k+1)-core will always be a subgraph of a k-core. This means that the larger k becomes, the smaller its k-core (i.e. its corresponding subgraph) will be. The k-core value (or coreness) assigned to a vertex will correspond to the core with the gratest degree from all the cores where it belongs. This implementation of k-core will look for cores lying within the interval set by the min_core and max_core input variables.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>K-Core can be used to analyze hierarchical structures in a graph by revealing subgraphs with particular properties. It can also help to visualize large graphs in 2D by using the "layers" provided by the k-cores.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>minCore</code> - minimum k-core value.</dd>
<dd><code>maxCore</code> - maximum k-core value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the maximum core found and a node property with the largest k-core value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Pair&lt;Scalar&lt;Long&gt;, VertexProperty&lt;Integer, Long&gt;&gt; kcore = analyst.kcore(graph, 0, 2147483647);
 kcore.getFirst().get();
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + kcore.getSecond().getName() + " MATCH (x) ORDER BY x." + kcore.getSecond().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://arxiv.org/pdf/cs/0310049v1.pdf">An O(m) Algorithm for Cores Decomposition of Networks</a>, 
<a href="https://arxiv.org/pdf/cs/0504107v2.pdf">k-core decomposition: a tool for the visualization of large scale networks</a></dd>
</dl>
</li>
</ul>
<a name="kcore-oracle.pgx.api.PgxGraph-int-int-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>kcore</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;&nbsp;kcore(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                 int&nbsp;minCore,
                                                                                 int&nbsp;maxCore,
                                                                                 <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;&nbsp;maxKCore,
                                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;kcore)
                                                                          throws java.util.concurrent.ExecutionException,
                                                                                 java.lang.InterruptedException</pre>
<div class="block"><p>k-core decomposes a graph into layers revealing subgraphs with particular properties
</p>
      <h2>Definition</h2>
      <p>A k-core is a maximal subgraph in which all of its vertices are connected and have the property that all of them have a degree of at least k. The k-cores can be regarded as layers in a graph, since a (k+1)-core will always be a subgraph of a k-core. This means that the larger k becomes, the smaller its k-core (i.e. its corresponding subgraph) will be. The k-core value (or coreness) assigned to a vertex will correspond to the core with the gratest degree from all the cores where it belongs. This implementation of k-core will look for cores lying within the interval set by the min_core and max_core input variables.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>K-Core can be used to analyze hierarchical structures in a graph by revealing subgraphs with particular properties. It can also help to visualize large graphs in 2D by using the "layers" provided by the k-cores.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>minCore</code> - minimum k-core value.</dd>
<dd><code>maxCore</code> - maximum k-core value.</dd>
<dd><code>maxKCore</code> - Scalar (long) for holding the value of the maximum k-core found by the algorithm.</dd>
<dd><code>kcore</code> - (out argument) vertex property with the largest k-core value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the maximum core found and a node property with the largest k-core value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Scalar&lt;Long&gt; scalar = graph.createScalar(PropertyType.LONG);
 VertexProperty&lt;Integer, Long&gt; prop = graph.CreateVertexProperty(PropertyType.LONG);
 Pair&lt;Scalar&lt;Long&gt;, VertexProperty&lt;Integer, Long&gt;&gt; kcore = analyst.kcore(graph, 0, 2147483647, scalar, prop);
 kcore.getFirst().get();
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + kcore.getSecond().getName() + " MATCH (x) ORDER BY x." + kcore.getSecond().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://arxiv.org/pdf/cs/0310049v1.pdf">An O(m) Algorithm for Cores Decomposition of Networks</a>, 
<a href="https://arxiv.org/pdf/cs/0504107v2.pdf">k-core decomposition: a tool for the visualization of large scale networks</a></dd>
</dl>
</li>
</ul>
<a name="kcore-oracle.pgx.api.PgxGraph-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>kcore</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;&nbsp;kcore(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                 <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;&nbsp;maxKCore,
                                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;kcore)
                                                                          throws java.util.concurrent.ExecutionException,
                                                                                 java.lang.InterruptedException</pre>
<div class="block"><p>k-core decomposes a graph into layers revealing subgraphs with particular properties
</p>
      <h2>Definition</h2>
      <p>A k-core is a maximal subgraph in which all of its vertices are connected and have the property that all of them have a degree of at least k. The k-cores can be regarded as layers in a graph, since a (k+1)-core will always be a subgraph of a k-core. This means that the larger k becomes, the smaller its k-core (i.e. its corresponding subgraph) will be. The k-core value (or coreness) assigned to a vertex will correspond to the core with the gratest degree from all the cores where it belongs. This implementation of k-core will look for cores lying within the interval set by the min_core and max_core input variables.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>K-Core can be used to analyze hierarchical structures in a graph by revealing subgraphs with particular properties. It can also help to visualize large graphs in 2D by using the "layers" provided by the k-cores.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>maxKCore</code> - Scalar (long) for holding the value of the maximum k-core found by the algorithm.</dd>
<dd><code>kcore</code> - (out argument) vertex property with the largest k-core value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the maximum core found and a node property with the largest k-core value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Scalar&lt;Long&gt; scalar = graph.createScalar(PropertyType.LONG);
 VertexProperty&lt;Integer, Long&gt; prop = graph.CreateVertexProperty(PropertyType.LONG);
 Pair&lt;Scalar&lt;Long&gt;, VertexProperty&lt;Integer, Long&gt;&gt; kcore = analyst.kcore(graph, scalar, prop);
 kcore.getFirst().get();
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + kcore.getSecond().getName() + " MATCH (x) ORDER BY x." + kcore.getSecond().getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://arxiv.org/pdf/cs/0310049v1.pdf">An O(m) Algorithm for Cores Decomposition of Networks</a>, 
<a href="https://arxiv.org/pdf/cs/0504107v2.pdf">k-core decomposition: a tool for the visualization of large scale networks</a></dd>
</dl>
</li>
</ul>
<a name="kcoreAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>kcoreAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;&gt;&nbsp;kcoreAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>k-core decomposes a graph into layers revealing subgraphs with particular properties
</p>
      <h2>Definition</h2>
      <p>A k-core is a maximal subgraph in which all of its vertices are connected and have the property that all of them have a degree of at least k. The k-cores can be regarded as layers in a graph, since a (k+1)-core will always be a subgraph of a k-core. This means that the larger k becomes, the smaller its k-core (i.e. its corresponding subgraph) will be. The k-core value (or coreness) assigned to a vertex will correspond to the core with the gratest degree from all the cores where it belongs. This implementation of k-core will look for cores lying within the interval set by the min_core and max_core input variables.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>K-Core can be used to analyze hierarchical structures in a graph by revealing subgraphs with particular properties. It can also help to visualize large graphs in 2D by using the "layers" provided by the k-cores.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the maximum core found and a node property with the largest k-core value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;Pair&lt;Scalar&lt;Long&gt;, VertexProperty&lt;Integer, Long&gt;&gt;&gt; promise = analyst.kcoreAsync(graph);
 promise.thenCompose(kcore -&gt; {
   kcore.getFirst().get();
   graph.queryPgqlAsync(
     "SELECT x, x." + kcore.getSecond().getName() + " MATCH (x) ORDER BY x." + kcore.getSecond().getName() +
     " DESC"))
     .thenAccept(PgqlResultSet::print);
 });
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://arxiv.org/pdf/cs/0310049v1.pdf">An O(m) Algorithm for Cores Decomposition of Networks</a>, 
<a href="https://arxiv.org/pdf/cs/0504107v2.pdf">k-core decomposition: a tool for the visualization of large scale networks</a></dd>
</dl>
</li>
</ul>
<a name="kcoreAsync-oracle.pgx.api.PgxGraph-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>kcoreAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;&gt;&nbsp;kcoreAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                 int&nbsp;minCore,
                                                                                                 int&nbsp;maxCore)</pre>
<div class="block"><p>k-core decomposes a graph into layers revealing subgraphs with particular properties
</p>
      <h2>Definition</h2>
      <p>A k-core is a maximal subgraph in which all of its vertices are connected and have the property that all of them have a degree of at least k. The k-cores can be regarded as layers in a graph, since a (k+1)-core will always be a subgraph of a k-core. This means that the larger k becomes, the smaller its k-core (i.e. its corresponding subgraph) will be. The k-core value (or coreness) assigned to a vertex will correspond to the core with the gratest degree from all the cores where it belongs. This implementation of k-core will look for cores lying within the interval set by the min_core and max_core input variables.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>K-Core can be used to analyze hierarchical structures in a graph by revealing subgraphs with particular properties. It can also help to visualize large graphs in 2D by using the "layers" provided by the k-cores.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>minCore</code> - minimum k-core value.</dd>
<dd><code>maxCore</code> - maximum k-core value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the maximum core found and a node property with the largest k-core value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;Pair&lt;Scalar&lt;Long&gt;, VertexProperty&lt;Integer, Long&gt;&gt;&gt; promise = analyst.kcoreAsync(graph, 0, 2147483647);
 promise.thenCompose(kcore -&gt; {
   kcore.getFirst().get();
   graph.queryPgqlAsync(
     "SELECT x, x." + kcore.getSecond().getName() + " MATCH (x) ORDER BY x." + kcore.getSecond().getName() +
     " DESC"))
     .thenAccept(PgqlResultSet::print);
 });
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://arxiv.org/pdf/cs/0310049v1.pdf">An O(m) Algorithm for Cores Decomposition of Networks</a>, 
<a href="https://arxiv.org/pdf/cs/0504107v2.pdf">k-core decomposition: a tool for the visualization of large scale networks</a></dd>
</dl>
</li>
</ul>
<a name="kcoreAsync-oracle.pgx.api.PgxGraph-int-int-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>kcoreAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;&gt;&nbsp;kcoreAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                 int&nbsp;minCore,
                                                                                                 int&nbsp;maxCore,
                                                                                                 <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;&nbsp;maxKCore,
                                                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;kcore)</pre>
<div class="block"><p>k-core decomposes a graph into layers revealing subgraphs with particular properties
</p>
      <h2>Definition</h2>
      <p>A k-core is a maximal subgraph in which all of its vertices are connected and have the property that all of them have a degree of at least k. The k-cores can be regarded as layers in a graph, since a (k+1)-core will always be a subgraph of a k-core. This means that the larger k becomes, the smaller its k-core (i.e. its corresponding subgraph) will be. The k-core value (or coreness) assigned to a vertex will correspond to the core with the gratest degree from all the cores where it belongs. This implementation of k-core will look for cores lying within the interval set by the min_core and max_core input variables.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>K-Core can be used to analyze hierarchical structures in a graph by revealing subgraphs with particular properties. It can also help to visualize large graphs in 2D by using the "layers" provided by the k-cores.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>minCore</code> - minimum k-core value.</dd>
<dd><code>maxCore</code> - maximum k-core value.</dd>
<dd><code>maxKCore</code> - Scalar (long) for holding the value of the maximum k-core found by the algorithm.</dd>
<dd><code>kcore</code> - (out argument) vertex property with the largest k-core value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the maximum core found and a node property with the largest k-core value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Long&gt; prop = graph.createVertexProperty(PropertyType.LONG);
 PgxFuture&lt;Pair&lt;Scalar&lt;Long&gt;, VertexProperty&lt;Integer, Long&gt;&gt;&gt; promise = analyst.kcoreAsync(
   graph, 0, 2147483647, prop);
 promise.thenCompose(kcore -&gt; {
   kcore.getFirst().get();
   graph.queryPgqlAsync(
     "SELECT x, x." + kcore.getSecond().getName() + " MATCH (x) ORDER BY x." + kcore.getSecond().getName() +
     " DESC"))
     .thenAccept(PgqlResultSet::print);
 });
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://arxiv.org/pdf/cs/0310049v1.pdf">An O(m) Algorithm for Cores Decomposition of Networks</a>, 
<a href="https://arxiv.org/pdf/cs/0504107v2.pdf">k-core decomposition: a tool for the visualization of large scale networks</a></dd>
</dl>
</li>
</ul>
<a name="kcoreAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>kcoreAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;&gt;&nbsp;kcoreAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                 <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Long&gt;&nbsp;maxKCore,
                                                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;kcore)</pre>
<div class="block"><p>k-core decomposes a graph into layers revealing subgraphs with particular properties
</p>
      <h2>Definition</h2>
      <p>A k-core is a maximal subgraph in which all of its vertices are connected and have the property that all of them have a degree of at least k. The k-cores can be regarded as layers in a graph, since a (k+1)-core will always be a subgraph of a k-core. This means that the larger k becomes, the smaller its k-core (i.e. its corresponding subgraph) will be. The k-core value (or coreness) assigned to a vertex will correspond to the core with the gratest degree from all the cores where it belongs. This implementation of k-core will look for cores lying within the interval set by the min_core and max_core input variables.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>K-Core can be used to analyze hierarchical structures in a graph by revealing subgraphs with particular properties. It can also help to visualize large graphs in 2D by using the "layers" provided by the k-cores.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>maxKCore</code> - Scalar (long) for holding the value of the maximum k-core found by the algorithm.</dd>
<dd><code>kcore</code> - (out argument) vertex property with the largest k-core value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the maximum core found and a node property with the largest k-core value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Scalar&lt;Long&gt; scalar = graph.createScalar(PropertyType.LONG);
 VertexProperty&lt;Integer, Long&gt; prop = graph.createVertexProperty(PropertyType.LONG);
 PgxFuture&lt;Pair&lt;Scalar&lt;Long&gt;, VertexProperty&lt;Integer, Long&gt;&gt;&gt; promise = analyst.kcoreAsync(
   graph, 0, 2147483647, prop);
 promise.thenCompose(kcore -&gt; {
   kcore.getFirst().get();
   graph.queryPgqlAsync(
     "SELECT x, x." + kcore.getSecond().getName() + " MATCH (x) ORDER BY x." + kcore.getSecond().getName() +
     " DESC"))
     .thenAccept(PgqlResultSet::print);
 });
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://arxiv.org/pdf/cs/0310049v1.pdf">An O(m) Algorithm for Cores Decomposition of Networks</a>, 
<a href="https://arxiv.org/pdf/cs/0504107v2.pdf">k-core decomposition: a tool for the visualization of large scale networks</a></dd>
</dl>
</li>
</ul>
<a name="limitedShortestPathHopDist-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>limitedShortestPathHopDist</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;&nbsp;limitedShortestPathHopDist(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                             int&nbsp;maxHops,
                                                                             <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Computes the k-hop limited shortest path between two vertices.
</p>
      <h2>Definition</h2>
      <p>description: Computes the shortest path between the source and destination vertex. The algorithm only considers paths up to a length of k.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Path-finding applications where the path should be / can be limited by a certain number of hops.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex.</dd>
<dd><code>dst</code> - the destination vertex.</dd>
<dd><code>maxHops</code> - the maximum number of edges to follow when trying to find a path.</dd>
<dd><code>highDegreeVertexMapping</code> - the high-degree vertices.</dd>
<dd><code>highDegreeVertices</code> - the high-degree vertices.</dd>
<dd><code>index</code> - index containing distances to high-degree vertices.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A pair containing the vertices in the shortest path from <code>src</code> to <code>dst</code> and the edges on the
 path. Both will be empty if there is no path within <code>maxHops</code> steps.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="limitedShortestPathHopDist-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>limitedShortestPathHopDist</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;&nbsp;limitedShortestPathHopDist(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                             int&nbsp;maxHops,
                                                                             <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index,
                                                                             <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;pathVertices,
                                                                             <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;pathEdges)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Computes the k-hop limited shortest path between two vertices.
</p>
      <h2>Definition</h2>
      <p>description: Computes the shortest path between the source and destination vertex. The algorithm only considers paths up to a length of k.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Path-finding applications where the path should be / can be limited by a certain number of hops.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex.</dd>
<dd><code>dst</code> - the destination vertex.</dd>
<dd><code>maxHops</code> - the maximum number of edges to follow when trying to find a path.</dd>
<dd><code>highDegreeVertexMapping</code> - the high-degree vertices.</dd>
<dd><code>highDegreeVertices</code> - the high-degree vertices.</dd>
<dd><code>index</code> - index containing distances to high-degree vertices.</dd>
<dd><code>pathVertices</code> - (out-argument)
 will contain the vertices on the found path or will be empty if there is none.</dd>
<dd><code>pathEdges</code> - (out-argument)
 will contain the vertices on the found path or will be empty if there is none.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A pair containing the vertices in the shortest path from <code>src</code> to <code>dst</code> and the edges on the
 path. Both will be empty if there is no path within <code>maxHops</code> steps.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="limitedShortestPathHopDistAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>limitedShortestPathHopDistAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;&gt;&nbsp;limitedShortestPathHopDistAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                                             int&nbsp;maxHops,
                                                                                             <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index)</pre>
<div class="block"><p>Computes the k-hop limited shortest path between two vertices.
</p>
      <h2>Definition</h2>
      <p>description: Computes the shortest path between the source and destination vertex. The algorithm only considers paths up to a length of k.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Path-finding applications where the path should be / can be limited by a certain number of hops.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex.</dd>
<dd><code>dst</code> - the destination vertex.</dd>
<dd><code>maxHops</code> - the maximum number of edges to follow when trying to find a path.</dd>
<dd><code>highDegreeVertexMapping</code> - the high-degree vertices.</dd>
<dd><code>highDegreeVertices</code> - the high-degree vertices.</dd>
<dd><code>index</code> - index containing distances to high-degree vertices.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A pair containing the vertices in the shortest path from <code>src</code> to <code>dst</code> and the edges on the
 path. Both will be empty if there is no path within <code>maxHops</code> steps.</dd>
</dl>
</li>
</ul>
<a name="limitedShortestPathHopDistAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>limitedShortestPathHopDistAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;&gt;&nbsp;limitedShortestPathHopDistAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                                             int&nbsp;maxHops,
                                                                                             <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index,
                                                                                             <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;pathVertices,
                                                                                             <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;pathEdges)</pre>
<div class="block"><p>Computes the k-hop limited shortest path between two vertices.
</p>
      <h2>Definition</h2>
      <p>description: Computes the shortest path between the source and destination vertex. The algorithm only considers paths up to a length of k.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Path-finding applications where the path should be / can be limited by a certain number of hops.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex.</dd>
<dd><code>dst</code> - the destination vertex.</dd>
<dd><code>maxHops</code> - the maximum number of edges to follow when trying to find a path.</dd>
<dd><code>highDegreeVertexMapping</code> - the high-degree vertices.</dd>
<dd><code>highDegreeVertices</code> - the high-degree vertices.</dd>
<dd><code>index</code> - index containing distances to high-degree vertices.</dd>
<dd><code>pathVertices</code> - (out-argument)
 will contain the vertices on the found path or will be empty if there is none.</dd>
<dd><code>pathEdges</code> - (out-argument)
 will contain the vertices on the found path or will be empty if there is none.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A pair containing the vertices in the shortest path from <code>src</code> to <code>dst</code> and the edges on the
 path. Both will be empty if there is no path within <code>maxHops</code> steps.</dd>
</dl>
</li>
</ul>
<a name="limitedShortestPathHopDistFiltered-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-oracle.pgx.api.filter.EdgeFilter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>limitedShortestPathHopDistFiltered</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;&nbsp;limitedShortestPathHopDistFiltered(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                                     int&nbsp;maxHops,
                                                                                     <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index,
                                                                                     <a href="../../../oracle/pgx/api/filter/EdgeFilter.html" title="class in oracle.pgx.api.filter">EdgeFilter</a>&nbsp;filter)
                                                                              throws java.util.concurrent.ExecutionException,
                                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Computes the k-hop limited shortest path between two vertices.
</p>
      <h2>Definition</h2>
      <p>description: Computes the shortest path between the source and destination vertex. The algorithm only considers paths up to a length of k.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Path-finding applications where the path should be / can be limited by a certain number of hops.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex.</dd>
<dd><code>dst</code> - the destination vertex.</dd>
<dd><code>maxHops</code> - the maximum number of edges to follow when trying to find a path.</dd>
<dd><code>highDegreeVertexMapping</code> - the high-degree vertices.</dd>
<dd><code>highDegreeVertices</code> - the high-degree vertices.</dd>
<dd><code>index</code> - index containing distances to high-degree vertices.</dd>
<dd><code>filter</code> - filter to be evaluated on the edges when searching for a path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A pair containing the vertices in the shortest path from <code>src</code> to <code>dst</code> and the edges on the
 path. Both will be empty if there is no path within <code>maxHops</code> steps.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="limitedShortestPathHopDistFiltered-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-oracle.pgx.api.filter.EdgeFilter-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>limitedShortestPathHopDistFiltered</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;&nbsp;limitedShortestPathHopDistFiltered(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                                     int&nbsp;maxHops,
                                                                                     <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index,
                                                                                     <a href="../../../oracle/pgx/api/filter/EdgeFilter.html" title="class in oracle.pgx.api.filter">EdgeFilter</a>&nbsp;filter,
                                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;pathVertices,
                                                                                     <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;pathEdges)
                                                                              throws java.util.concurrent.ExecutionException,
                                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Computes the k-hop limited shortest path between two vertices.
</p>
      <h2>Definition</h2>
      <p>description: Computes the shortest path between the source and destination vertex. The algorithm only considers paths up to a length of k.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Path-finding applications where the path should be / can be limited by a certain number of hops.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex.</dd>
<dd><code>dst</code> - the destination vertex.</dd>
<dd><code>maxHops</code> - the maximum number of edges to follow when trying to find a path.</dd>
<dd><code>highDegreeVertexMapping</code> - the high-degree vertices.</dd>
<dd><code>highDegreeVertices</code> - the high-degree vertices.</dd>
<dd><code>index</code> - index containing distances to high-degree vertices.</dd>
<dd><code>filter</code> - filter to be evaluated on the edges when searching for a path.</dd>
<dd><code>pathVertices</code> - (out-argument)
 will contain the vertices on the found path or will be empty if there is none.</dd>
<dd><code>pathEdges</code> - (out-argument)
 will contain the vertices on the found path or will be empty if there is none.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A pair containing the vertices in the shortest path from <code>src</code> to <code>dst</code> and the edges on the
 path. Both will be empty if there is no path within <code>maxHops</code> steps.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="limitedShortestPathHopDistFilteredAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-oracle.pgx.api.filter.EdgeFilter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>limitedShortestPathHopDistFilteredAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;&gt;&nbsp;limitedShortestPathHopDistFilteredAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                                                     int&nbsp;maxHops,
                                                                                                     <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                                                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index,
                                                                                                     <a href="../../../oracle/pgx/api/filter/EdgeFilter.html" title="class in oracle.pgx.api.filter">EdgeFilter</a>&nbsp;filter)</pre>
<div class="block"><p>Computes the k-hop limited shortest path between two vertices.
</p>
      <h2>Definition</h2>
      <p>description: Computes the shortest path between the source and destination vertex. The algorithm only considers paths up to a length of k.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Path-finding applications where the path should be / can be limited by a certain number of hops.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex.</dd>
<dd><code>dst</code> - the destination vertex.</dd>
<dd><code>maxHops</code> - the maximum number of edges to follow when trying to find a path.</dd>
<dd><code>highDegreeVertexMapping</code> - the high-degree vertices.</dd>
<dd><code>highDegreeVertices</code> - the high-degree vertices.</dd>
<dd><code>index</code> - index containing distances to high-degree vertices.</dd>
<dd><code>filter</code> - filter to be evaluated on the edges when searching for a path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A pair containing the vertices in the shortest path from <code>src</code> to <code>dst</code> and the edges on the
 path. Both will be empty if there is no path within <code>maxHops</code> steps.</dd>
</dl>
</li>
</ul>
<a name="limitedShortestPathHopDistFilteredAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.PgxMap-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-oracle.pgx.api.filter.EdgeFilter-oracle.pgx.api.VertexSequence-oracle.pgx.api.EdgeSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>limitedShortestPathHopDistFilteredAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&gt;&gt;&nbsp;limitedShortestPathHopDistFilteredAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                                                     int&nbsp;maxHops,
                                                                                                     <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;highDegreeVertexMapping,
                                                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;highDegreeVertices,
                                                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Integer&gt;&gt;&nbsp;index,
                                                                                                     <a href="../../../oracle/pgx/api/filter/EdgeFilter.html" title="class in oracle.pgx.api.filter">EdgeFilter</a>&nbsp;filter,
                                                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;pathVertices,
                                                                                                     <a href="../../../oracle/pgx/api/EdgeSequence.html" title="class in oracle.pgx.api">EdgeSequence</a>&nbsp;pathEdges)</pre>
<div class="block"><p>Computes the k-hop limited shortest path between two vertices.
</p>
      <h2>Definition</h2>
      <p>description: Computes the shortest path between the source and destination vertex. The algorithm only considers paths up to a length of k.
</p>
      <h2>Implementation Details</h2>
      <p>null</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Path-finding applications where the path should be / can be limited by a certain number of hops.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex.</dd>
<dd><code>dst</code> - the destination vertex.</dd>
<dd><code>maxHops</code> - the maximum number of edges to follow when trying to find a path.</dd>
<dd><code>highDegreeVertexMapping</code> - the high-degree vertices.</dd>
<dd><code>highDegreeVertices</code> - the high-degree vertices.</dd>
<dd><code>index</code> - index containing distances to high-degree vertices.</dd>
<dd><code>filter</code> - filter to be evaluated on the edges when searching for a path.</dd>
<dd><code>pathVertices</code> - (out-argument)
 will contain the vertices on the found path or will be empty if there is none.</dd>
<dd><code>pathEdges</code> - (out-argument)
 will contain the vertices on the found path or will be empty if there is none.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A pair containing the vertices in the shortest path from <code>src</code> to <code>dst</code> and the edges on the
 path. Both will be empty if there is no path within <code>maxHops</code> steps.</dd>
</dl>
</li>
</ul>
<a name="loadDeepWalkModel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadDeepWalkModel</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib">GenericModelLoader</a>&lt;<a href="../../../oracle/pgx/api/mllib/DeepWalkModel.html" title="class in oracle.pgx.api.mllib">DeepWalkModel</a>&gt;&nbsp;loadDeepWalkModel()</pre>
<div class="block">Returns <a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib"><code>GenericModelLoader</code></a> to configure how to load a DeepWalk model and then trigger it.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib"><code>GenericModelLoader</code></a> to configure how to load a DeepWalk model</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>21.1</dd>
</dl>
</li>
</ul>
<a name="loadDeepWalkModel-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadDeepWalkModel</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/mllib/DeepWalkModel.html" title="class in oracle.pgx.api.mllib">DeepWalkModel</a>&nbsp;loadDeepWalkModel(java.lang.String&nbsp;path,
                                       java.lang.String&nbsp;key)
                                throws java.lang.InterruptedException,
                                       java.util.concurrent.ExecutionException</pre>
<div class="block">Loads an encrypted Deepwalk model</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>path</code> - the path</dd>
<dd><code>key</code> - the decryption key, or null if no encryption was used</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the loaded model</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code></dd>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
</dl>
</li>
</ul>
<a name="loadPg2vecModel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadPg2vecModel</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib">GenericModelLoader</a>&lt;<a href="../../../oracle/pgx/api/mllib/Pg2vecModel.html" title="class in oracle.pgx.api.mllib">Pg2vecModel</a>&gt;&nbsp;loadPg2vecModel()</pre>
<div class="block">Returns <a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib"><code>GenericModelLoader</code></a> to configure how to load a Pg2vec model and then trigger it.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib"><code>GenericModelLoader</code></a> to configure how to load a Pg2vec model</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>21.1</dd>
</dl>
</li>
</ul>
<a name="loadPg2vecModel-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadPg2vecModel</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/mllib/Pg2vecModel.html" title="class in oracle.pgx.api.mllib">Pg2vecModel</a>&nbsp;loadPg2vecModel(java.lang.String&nbsp;path,
                                   java.lang.String&nbsp;key)
                            throws java.lang.InterruptedException,
                                   java.util.concurrent.ExecutionException</pre>
<div class="block">Loads an encrypted pg2vec model</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>path</code> - the path</dd>
<dd><code>key</code> - the decryption key, or null if no encryption was used</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the loaded model</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code></dd>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
</dl>
</li>
</ul>
<a name="loadSupervisedGraphWiseModel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadSupervisedGraphWiseModel</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib">GenericModelLoader</a>&lt;<a href="../../../oracle/pgx/api/mllib/SupervisedGraphWiseModel.html" title="class in oracle.pgx.api.mllib">SupervisedGraphWiseModel</a>&gt;&nbsp;loadSupervisedGraphWiseModel()</pre>
<div class="block">Returns <a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib"><code>GenericModelLoader</code></a> to configure how to load a SupervisedGraphWiseModel model and then trigger it.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib"><code>GenericModelLoader</code></a> to configure how to load a SupervisedGraphWiseModel model</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>21.1</dd>
</dl>
</li>
</ul>
<a name="loadSupervisedGraphWiseModel-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadSupervisedGraphWiseModel</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/mllib/SupervisedGraphWiseModel.html" title="class in oracle.pgx.api.mllib">SupervisedGraphWiseModel</a>&nbsp;loadSupervisedGraphWiseModel(java.lang.String&nbsp;path,
                                                             java.lang.String&nbsp;key)
                                                      throws java.lang.InterruptedException,
                                                             java.util.concurrent.ExecutionException</pre>
<div class="block">Loads an encrypted SupervisedGraphWise model</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>path</code> - the path</dd>
<dd><code>key</code> - the decryption key, or null if no encryption was used</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the loaded model</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code></dd>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
</dl>
</li>
</ul>
<a name="loadUnsupervisedGraphWiseModel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadUnsupervisedGraphWiseModel</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib">GenericModelLoader</a>&lt;<a href="../../../oracle/pgx/api/mllib/UnsupervisedGraphWiseModel.html" title="class in oracle.pgx.api.mllib">UnsupervisedGraphWiseModel</a>&gt;&nbsp;loadUnsupervisedGraphWiseModel()</pre>
<div class="block">Returns <a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib"><code>GenericModelLoader</code></a> to configure how to load a UnsupervisedGraphWise model and then trigger it.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="../../../oracle/pgx/api/mllib/GenericModelLoader.html" title="class in oracle.pgx.api.mllib"><code>GenericModelLoader</code></a> to configure how to load a UnsupervisedGraphWise model</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>21.2</dd>
</dl>
</li>
</ul>
<a name="loadUnsupervisedGraphWiseModel-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadUnsupervisedGraphWiseModel</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/mllib/UnsupervisedGraphWiseModel.html" title="class in oracle.pgx.api.mllib">UnsupervisedGraphWiseModel</a>&nbsp;loadUnsupervisedGraphWiseModel(java.lang.String&nbsp;path,
                                                                 java.lang.String&nbsp;key)
                                                          throws java.lang.InterruptedException,
                                                                 java.util.concurrent.ExecutionException</pre>
<div class="block">Loads an encrypted UnsupervisedGraphWise model</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>path</code> - the path</dd>
<dd><code>key</code> - the decryption key, or null if no encryption was used</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the loaded model</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code></dd>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
</dl>
</li>
</ul>
<a name="localClusteringCoefficient-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localClusteringCoefficient</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;localClusteringCoefficient(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                                    throws java.util.concurrent.ExecutionException,
                                                                           java.lang.InterruptedException</pre>
<div class="block"><p>LCC gives information about potential clustering options in a graph
</p>
      <h2>Definition</h2>
      <p>The LCC of a vertex V is the fraction of connections between each pair of neighbors of V, i.e. the fraction of existing triangles from all the possible triangles involving V and every other pair of neighbor vertices of V. This implementation is intended for undirected graphs. Nodes with a degree smaller than 2 will be assigned a LCC value of 0.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V ^ 2) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>LCC can be used to determine how likely are vertices to cluster together, since it assess the degree of connections between a vertex and its neighbors. It could be used in social networks to spot out groups of people (commmunities), since people in groups tend to have a high density of links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the lcc value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; lcc = analyst.localClusteringCoefficient(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + lcc.getName() + " MATCH (x) ORDER BY x." + lcc.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="localClusteringCoefficient-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localClusteringCoefficient</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;localClusteringCoefficient(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;lcc)
                                                                    throws java.util.concurrent.ExecutionException,
                                                                           java.lang.InterruptedException</pre>
<div class="block"><p>LCC gives information about potential clustering options in a graph
</p>
      <h2>Definition</h2>
      <p>The LCC of a vertex V is the fraction of connections between each pair of neighbors of V, i.e. the fraction of existing triangles from all the possible triangles involving V and every other pair of neighbor vertices of V. This implementation is intended for undirected graphs. Nodes with a degree smaller than 2 will be assigned a LCC value of 0.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V ^ 2) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>LCC can be used to determine how likely are vertices to cluster together, since it assess the degree of connections between a vertex and its neighbors. It could be used in social networks to spot out groups of people (commmunities), since people in groups tend to have a high density of links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>lcc</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the lcc value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; prop = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; lcc = analyst.localClusteringCoefficient(graph, prop);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + lcc.getName() + " MATCH (x) ORDER BY x." + lcc.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="localClusteringCoefficientAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localClusteringCoefficientAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;localClusteringCoefficientAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>LCC gives information about potential clustering options in a graph
</p>
      <h2>Definition</h2>
      <p>The LCC of a vertex V is the fraction of connections between each pair of neighbors of V, i.e. the fraction of existing triangles from all the possible triangles involving V and every other pair of neighbor vertices of V. This implementation is intended for undirected graphs. Nodes with a degree smaller than 2 will be assigned a LCC value of 0.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V ^ 2) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>LCC can be used to determine how likely are vertices to cluster together, since it assess the degree of connections between a vertex and its neighbors. It could be used in social networks to spot out groups of people (commmunities), since people in groups tend to have a high density of links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the lcc value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.localClusteringCoefficientAsync(graph);
 promise.thenCompose(lcc -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + lcc.getName() + " MATCH (x) ORDER BY x." + lcc.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="localClusteringCoefficientAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localClusteringCoefficientAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;localClusteringCoefficientAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                           <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;lcc)</pre>
<div class="block"><p>LCC gives information about potential clustering options in a graph
</p>
      <h2>Definition</h2>
      <p>The LCC of a vertex V is the fraction of connections between each pair of neighbors of V, i.e. the fraction of existing triangles from all the possible triangles involving V and every other pair of neighbor vertices of V. This implementation is intended for undirected graphs. Nodes with a degree smaller than 2 will be assigned a LCC value of 0.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V ^ 2) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>LCC can be used to determine how likely are vertices to cluster together, since it assess the degree of connections between a vertex and its neighbors. It could be used in social networks to spot out groups of people (commmunities), since people in groups tend to have a high density of links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>lcc</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the lcc value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; lcc = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.localClusteringCoefficientAsync(graph, lcc);
 promise.thenCompose(lcc -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + lcc.getName() + " MATCH (x) ORDER BY x." + lcc.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="louvain-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>louvain</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;louvain(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                      <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                               throws java.util.concurrent.ExecutionException,
                                                      java.lang.InterruptedException</pre>
<div class="block"><p>Louvain can detect communities in a large graph relatively fast.
</p>
      <h2>Definition</h2>
      <p>Louvain is an algorithm for community detection in large graphs which uses the graph's modularity. Initially it assigns a different community to each node of the graph. It then iterates over the nodes and evaluates for each node the modularity gain obtained by removing the node from its community and placing it in the community of one of its neigbours. The node is placed in the community for which the modularity gain is maximum. This process is repeated for all nodes until no improvement is possible, i.e until no new assignement of a node to a different community can improve the graph's modularity.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(8 * V + E) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The Louvain algorithm can be used for community detection in a multiple real-life situations, like identifying cyber-communities in a social network.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>weight</code> - weights of the edges of the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the community ID assigned to each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; weight = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Long&gt; community = analyst.louvain(graph, weight);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="louvain-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>louvain</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;louvain(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                      <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                      int&nbsp;maxIter)
                                               throws java.util.concurrent.ExecutionException,
                                                      java.lang.InterruptedException</pre>
<div class="block"><p>Louvain can detect communities in a large graph relatively fast.
</p>
      <h2>Definition</h2>
      <p>Louvain is an algorithm for community detection in large graphs which uses the graph's modularity. Initially it assigns a different community to each node of the graph. It then iterates over the nodes and evaluates for each node the modularity gain obtained by removing the node from its community and placing it in the community of one of its neigbours. The node is placed in the community for which the modularity gain is maximum. This process is repeated for all nodes until no improvement is possible, i.e until no new assignement of a node to a different community can improve the graph's modularity.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(8 * V + E) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The Louvain algorithm can be used for community detection in a multiple real-life situations, like identifying cyber-communities in a social network.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>weight</code> - weights of the edges of the graph.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed during each pass.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the community ID assigned to each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; weight = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Long&gt; community = analyst.louvain(graph, weight);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="louvain-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-int-int-double-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>louvain</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;louvain(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                      <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                      int&nbsp;maxIter,
                                                      int&nbsp;nbrPass,
                                                      double&nbsp;tol,
                                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;community)
                                               throws java.util.concurrent.ExecutionException,
                                                      java.lang.InterruptedException</pre>
<div class="block"><p>Louvain can detect communities in a large graph relatively fast.
</p>
      <h2>Definition</h2>
      <p>Louvain is an algorithm for community detection in large graphs which uses the graph's modularity. Initially it assigns a different community to each node of the graph. It then iterates over the nodes and evaluates for each node the modularity gain obtained by removing the node from its community and placing it in the community of one of its neigbours. The node is placed in the community for which the modularity gain is maximum. This process is repeated for all nodes until no improvement is possible, i.e until no new assignement of a node to a different community can improve the graph's modularity.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(8 * V + E) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The Louvain algorithm can be used for community detection in a multiple real-life situations, like identifying cyber-communities in a social network.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>weight</code> - weights of the edges of the graph.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed during each pass.</dd>
<dd><code>nbrPass</code> - number of passes that will be performed.</dd>
<dd><code>tol</code> - maximum tolerated error value. The algorithm will stop once the graph's total modularity gain becomes smaller than this value.</dd>
<dd><code>community</code> - the community ID assigned to each node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the community ID assigned to each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; weight = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Long&gt; community = analyst.louvain(graph, 10, weight);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="louvainAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>louvainAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;&nbsp;louvainAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                      <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>Louvain can detect communities in a large graph relatively fast.
</p>
      <h2>Definition</h2>
      <p>Louvain is an algorithm for community detection in large graphs which uses the graph's modularity. Initially it assigns a different community to each node of the graph. It then iterates over the nodes and evaluates for each node the modularity gain obtained by removing the node from its community and placing it in the community of one of its neigbours. The node is placed in the community for which the modularity gain is maximum. This process is repeated for all nodes until no improvement is possible, i.e until no new assignement of a node to a different community can improve the graph's modularity.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(8 * V + E) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The Louvain algorithm can be used for community detection in a multiple real-life situations, like identifying cyber-communities in a social network.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>weight</code> - weights of the edges of the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the community ID assigned to each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; weight = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Long&gt; community = analyst.louvain(graph, weight);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="louvainAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>louvainAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;&nbsp;louvainAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                      <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                      int&nbsp;maxIter)</pre>
<div class="block"><p>Louvain can detect communities in a large graph relatively fast.
</p>
      <h2>Definition</h2>
      <p>Louvain is an algorithm for community detection in large graphs which uses the graph's modularity. Initially it assigns a different community to each node of the graph. It then iterates over the nodes and evaluates for each node the modularity gain obtained by removing the node from its community and placing it in the community of one of its neigbours. The node is placed in the community for which the modularity gain is maximum. This process is repeated for all nodes until no improvement is possible, i.e until no new assignement of a node to a different community can improve the graph's modularity.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(8 * V + E) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The Louvain algorithm can be used for community detection in a multiple real-life situations, like identifying cyber-communities in a social network.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>weight</code> - weights of the edges of the graph.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed during each pass.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the community ID assigned to each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; weight = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Long&gt; community = analyst.louvain(graph, weight);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="louvainAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-int-int-double-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>louvainAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&gt;&nbsp;louvainAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                      <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                      int&nbsp;maxIter,
                                                                      int&nbsp;nbrPass,
                                                                      double&nbsp;tol,
                                                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;community)</pre>
<div class="block"><p>Louvain can detect communities in a large graph relatively fast.
</p>
      <h2>Definition</h2>
      <p>Louvain is an algorithm for community detection in large graphs which uses the graph's modularity. Initially it assigns a different community to each node of the graph. It then iterates over the nodes and evaluates for each node the modularity gain obtained by removing the node from its community and placing it in the community of one of its neigbours. The node is placed in the community for which the modularity gain is maximum. This process is repeated for all nodes until no improvement is possible, i.e until no new assignement of a node to a different community can improve the graph's modularity.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(8 * V + E) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The Louvain algorithm can be used for community detection in a multiple real-life situations, like identifying cyber-communities in a social network.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>weight</code> - weights of the edges of the graph.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed during each pass.</dd>
<dd><code>nbrPass</code> - number of passes that will be performed.</dd>
<dd><code>community</code> - the community ID assigned to each node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the community ID assigned to each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; weight = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Long&gt; community = analyst.louvain(graph, 10, weight);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="matrixFactorizationGradientDescent-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matrixFactorizationGradientDescent</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;&nbsp;matrixFactorizationGradientDescent(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                                                     throws java.lang.InterruptedException,
                                                                            java.util.concurrent.ExecutionException</pre>
<div class="block"><p>Matrix factorization can be used as a recommendation algorithm for bipartite graphs
</p>
      <h2>Definition</h2>
      <p>This algorithm needs a [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph to generate feature vectors that factorize the given set of left vertices (users) and right vertices (items), so that the inner product of such feature vectors can recover the information from the original graph structure, which can be seen as a sparse matrix. The generated feature vectors can be used for making recommendations with the given set of users, where a good recommendation for a given user will be a dot (inner) product between the feature vector of the user and the corresponding feature vector of a vertex from the item set, such that the result of that dot product returns a high score.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k * s) with E = number of edges, k = maximum number of iteration, s = size of the feature vectors</code></li>
        <li>Space: <code>O(2 * V * s) with V = number of vertices, s = size of the feature vectors</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be used to get recommendations. The computed feature vectors can also be used to make predictions.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>weight</code> - edge property holding the rating weight of each edge in the graph. The weight needs to be pre-scaled into the range 1-5. If the weight values are not between 1 and 5, the result will become inaccurate.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Matrix factorization model holding the feature vectores found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 MatrixFactorizationModel&lt;Integer&gt; matrix = analyst.matrixFactorizationGradientDescent(graph, cost);
 matrix.getRootMeanSquareError();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code></dd>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://courses.ischool.berkeley.edu/i290-dm/s11/SECURE/Koren_Matrix_Factorization.pdf">Matrix factorization techniques for recommender systems</a></dd>
</dl>
</li>
</ul>
<a name="matrixFactorizationGradientDescent-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-double-double-double-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matrixFactorizationGradientDescent</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;&nbsp;matrixFactorizationGradientDescent(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                            double&nbsp;learningRate,
                                                                            double&nbsp;changePerStep,
                                                                            double&nbsp;lambda,
                                                                            int&nbsp;maxStep,
                                                                            int&nbsp;vectorLength)
                                                                     throws java.lang.InterruptedException,
                                                                            java.util.concurrent.ExecutionException</pre>
<div class="block"><p>Matrix factorization can be used as a recommendation algorithm for bipartite graphs
</p>
      <h2>Definition</h2>
      <p>This algorithm needs a [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph to generate feature vectors that factorize the given set of left vertices (users) and right vertices (items), so that the inner product of such feature vectors can recover the information from the original graph structure, which can be seen as a sparse matrix. The generated feature vectors can be used for making recommendations with the given set of users, where a good recommendation for a given user will be a dot (inner) product between the feature vector of the user and the corresponding feature vector of a vertex from the item set, such that the result of that dot product returns a high score.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k * s) with E = number of edges, k = maximum number of iteration, s = size of the feature vectors</code></li>
        <li>Space: <code>O(2 * V * s) with V = number of vertices, s = size of the feature vectors</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be used to get recommendations. The computed feature vectors can also be used to make predictions.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>weight</code> - edge property holding the rating weight of each edge in the graph. The weight needs to be pre-scaled into the range 1-5. If the weight values are not between 1 and 5, the result will become inaccurate.</dd>
<dd><code>learningRate</code> - learning rate for the optimization process.</dd>
<dd><code>changePerStep</code> - parameter used to modulate the learning rate during the optimization process.</dd>
<dd><code>lambda</code> - penalization parameter to avoid overfitting during optimization process.</dd>
<dd><code>maxStep</code> - maximum number of iterations that will be performed.</dd>
<dd><code>vectorLength</code> - size of the feature vectors to be generated for the factorization.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Matrix factorization model holding the feature vectores found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 MatrixFactorizationModel&lt;Integer&gt; matrix = analyst.matrixFactorizationGradientDescent(
   graph, cost, 0.1, 0.9, 0.1, 100, 20);
 matrix.getRootMeanSquareError();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code></dd>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://courses.ischool.berkeley.edu/i290-dm/s11/SECURE/Koren_Matrix_Factorization.pdf">Matrix factorization techniques for recommender systems</a></dd>
</dl>
</li>
</ul>
<a name="matrixFactorizationGradientDescent-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-double-double-double-int-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matrixFactorizationGradientDescent</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;&nbsp;matrixFactorizationGradientDescent(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                            double&nbsp;learningRate,
                                                                            double&nbsp;changePerStep,
                                                                            double&nbsp;lambda,
                                                                            int&nbsp;maxStep,
                                                                            int&nbsp;vectorLength,
                                                                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Double&gt;&gt;&nbsp;features)
                                                                     throws java.lang.InterruptedException,
                                                                            java.util.concurrent.ExecutionException</pre>
<div class="block"><p>Matrix factorization can be used as a recommendation algorithm for bipartite graphs
</p>
      <h2>Definition</h2>
      <p>This algorithm needs a [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph to generate feature vectors that factorize the given set of left vertices (users) and right vertices (items), so that the inner product of such feature vectors can recover the information from the original graph structure, which can be seen as a sparse matrix. The generated feature vectors can be used for making recommendations with the given set of users, where a good recommendation for a given user will be a dot (inner) product between the feature vector of the user and the corresponding feature vector of a vertex from the item set, such that the result of that dot product returns a high score.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k * s) with E = number of edges, k = maximum number of iteration, s = size of the feature vectors</code></li>
        <li>Space: <code>O(2 * V * s) with V = number of vertices, s = size of the feature vectors</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be used to get recommendations. The computed feature vectors can also be used to make predictions.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>weight</code> - edge property holding the rating weight of each edge in the graph. The weight needs to be pre-scaled into the range 1-5. If the weight values are not between 1 and 5, the result will become inaccurate.</dd>
<dd><code>learningRate</code> - learning rate for the optimization process.</dd>
<dd><code>changePerStep</code> - parameter used to modulate the learning rate during the optimization process.</dd>
<dd><code>lambda</code> - penalization parameter to avoid overfitting during optimization process.</dd>
<dd><code>maxStep</code> - maximum number of iterations that will be performed.</dd>
<dd><code>vectorLength</code> - size of the feature vectors to be generated for the factorization.</dd>
<dd><code>features</code> - (out argument)
    vertex property holding the generated feature vectors for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Matrix factorization model holding the feature vectores found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, PgxVect&lt;Double&gt;&gt; features = graph.createVertexVectorProperty(PropertyType.DOUBLE, 20);
 MatrixFactorizationModel&lt;Integer&gt; matrix = analyst.matrixFactorizationGradientDescent(
   graph, cost, 0.1, 0.9, 0.1, 100, 20, features);
 matrix.getRootMeanSquareError();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code></dd>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://courses.ischool.berkeley.edu/i290-dm/s11/SECURE/Koren_Matrix_Factorization.pdf">Matrix factorization techniques for recommender systems</a></dd>
</dl>
</li>
</ul>
<a name="matrixFactorizationGradientDescent-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matrixFactorizationGradientDescent</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;&nbsp;matrixFactorizationGradientDescent(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Double&gt;&gt;&nbsp;features)
                                                                     throws java.lang.InterruptedException,
                                                                            java.util.concurrent.ExecutionException</pre>
<div class="block"><p>Matrix factorization can be used as a recommendation algorithm for bipartite graphs
</p>
      <h2>Definition</h2>
      <p>This algorithm needs a [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph to generate feature vectors that factorize the given set of left vertices (users) and right vertices (items), so that the inner product of such feature vectors can recover the information from the original graph structure, which can be seen as a sparse matrix. The generated feature vectors can be used for making recommendations with the given set of users, where a good recommendation for a given user will be a dot (inner) product between the feature vector of the user and the corresponding feature vector of a vertex from the item set, such that the result of that dot product returns a high score.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k * s) with E = number of edges, k = maximum number of iteration, s = size of the feature vectors</code></li>
        <li>Space: <code>O(2 * V * s) with V = number of vertices, s = size of the feature vectors</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be used to get recommendations. The computed feature vectors can also be used to make predictions.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>weight</code> - edge property holding the rating weight of each edge in the graph. The weight needs to be pre-scaled into the range 1-5. If the weight values are not between 1 and 5, the result will become inaccurate.</dd>
<dd><code>features</code> - (out argument)
    vertex property holding the generated feature vectors for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Matrix factorization model holding the feature vectores found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, PgxVect&lt;Double&gt;&gt; features = graph.createVertexVectorProperty(PropertyType.DOUBLE, 20);
 MatrixFactorizationModel&lt;Integer&gt; matrix = analyst.matrixFactorizationGradientDescent(graph, cost, features);
 matrix.getRootMeanSquareError();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code></dd>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://courses.ischool.berkeley.edu/i290-dm/s11/SECURE/Koren_Matrix_Factorization.pdf">Matrix factorization techniques for recommender systems</a></dd>
</dl>
</li>
</ul>
<a name="matrixFactorizationGradientDescentAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matrixFactorizationGradientDescentAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;&gt;&nbsp;matrixFactorizationGradientDescentAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>Matrix factorization can be used as a recommendation algorithm for bipartite graphs
</p>
      <h2>Definition</h2>
      <p>This algorithm needs a [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph to generate feature vectors that factorize the given set of left vertices (users) and right vertices (items), so that the inner product of such feature vectors can recover the information from the original graph structure, which can be seen as a sparse matrix. The generated feature vectors can be used for making recommendations with the given set of users, where a good recommendation for a given user will be a dot (inner) product between the feature vector of the user and the corresponding feature vector of a vertex from the item set, such that the result of that dot product returns a high score.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k * s) with E = number of edges, k = maximum number of iteration, s = size of the feature vectors</code></li>
        <li>Space: <code>O(2 * V * s) with V = number of vertices, s = size of the feature vectors</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be used to get recommendations. The computed feature vectors can also be used to make predictions.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>weight</code> - edge property holding the rating weight of each edge in the graph. The weight needs to be pre-scaled into the range 1-5. If the weight values are not between 1 and 5, the result will become inaccurate.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Matrix factorization model holding the feature vectores found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;MatrixFactorizationModel&lt;Integer&gt;&gt; promise = analyst.matrixFactorizationGradientDescentAsync(
   graph, cost);
 promise.thenAccept(matrix -&gt; {
   matrix.getRootMeanSquareError();
 });
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://courses.ischool.berkeley.edu/i290-dm/s11/SECURE/Koren_Matrix_Factorization.pdf">Matrix factorization techniques for recommender systems</a></dd>
</dl>
</li>
</ul>
<a name="matrixFactorizationGradientDescentAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-double-double-double-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matrixFactorizationGradientDescentAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;&gt;&nbsp;matrixFactorizationGradientDescentAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                                            double&nbsp;learningRate,
                                                                                            double&nbsp;changePerStep,
                                                                                            double&nbsp;lambda,
                                                                                            int&nbsp;maxStep,
                                                                                            int&nbsp;vectorLength)</pre>
<div class="block"><p>Matrix factorization can be used as a recommendation algorithm for bipartite graphs
</p>
      <h2>Definition</h2>
      <p>This algorithm needs a [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph to generate feature vectors that factorize the given set of left vertices (users) and right vertices (items), so that the inner product of such feature vectors can recover the information from the original graph structure, which can be seen as a sparse matrix. The generated feature vectors can be used for making recommendations with the given set of users, where a good recommendation for a given user will be a dot (inner) product between the feature vector of the user and the corresponding feature vector of a vertex from the item set, such that the result of that dot product returns a high score.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k * s) with E = number of edges, k = maximum number of iteration, s = size of the feature vectors</code></li>
        <li>Space: <code>O(2 * V * s) with V = number of vertices, s = size of the feature vectors</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be used to get recommendations. The computed feature vectors can also be used to make predictions.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>weight</code> - edge property holding the rating weight of each edge in the graph. The weight needs to be pre-scaled into the range 1-5. If the weight values are not between 1 and 5, the result will become inaccurate.</dd>
<dd><code>learningRate</code> - learning rate for the optimization process.</dd>
<dd><code>changePerStep</code> - parameter used to modulate the learning rate during the optimization process.</dd>
<dd><code>lambda</code> - penalization parameter to avoid overfitting during optimization process.</dd>
<dd><code>maxStep</code> - maximum number of iterations that will be performed.</dd>
<dd><code>vectorLength</code> - size of the feature vectors to be generated for the factorization.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Matrix factorization model holding the feature vectores found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;MatrixFactorizationModel&lt;Integer&gt;&gt; promise = analyst.matrixFactorizationGradientDescentAsync(
   graph, cost, 0.1, 0.9, 0.1, 100, 20);
 promise.thenAccept(matrix -&gt; {
   matrix.getRootMeanSquareError();
 });
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://courses.ischool.berkeley.edu/i290-dm/s11/SECURE/Koren_Matrix_Factorization.pdf">Matrix factorization techniques for recommender systems</a></dd>
</dl>
</li>
</ul>
<a name="matrixFactorizationGradientDescentAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-double-double-double-int-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matrixFactorizationGradientDescentAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;&gt;&nbsp;matrixFactorizationGradientDescentAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                                            double&nbsp;learningRate,
                                                                                            double&nbsp;changePerStep,
                                                                                            double&nbsp;lambda,
                                                                                            int&nbsp;maxStep,
                                                                                            int&nbsp;vectorLength,
                                                                                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Double&gt;&gt;&nbsp;features)</pre>
<div class="block"><p>Matrix factorization can be used as a recommendation algorithm for bipartite graphs
</p>
      <h2>Definition</h2>
      <p>This algorithm needs a [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph to generate feature vectors that factorize the given set of left vertices (users) and right vertices (items), so that the inner product of such feature vectors can recover the information from the original graph structure, which can be seen as a sparse matrix. The generated feature vectors can be used for making recommendations with the given set of users, where a good recommendation for a given user will be a dot (inner) product between the feature vector of the user and the corresponding feature vector of a vertex from the item set, such that the result of that dot product returns a high score.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k * s) with E = number of edges, k = maximum number of iteration, s = size of the feature vectors</code></li>
        <li>Space: <code>O(2 * V * s) with V = number of vertices, s = size of the feature vectors</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be used to get recommendations. The computed feature vectors can also be used to make predictions.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>weight</code> - edge property holding the rating weight of each edge in the graph. The weight needs to be pre-scaled into the range 1-5. If the weight values are not between 1 and 5, the result will become inaccurate.</dd>
<dd><code>learningRate</code> - learning rate for the optimization process.</dd>
<dd><code>changePerStep</code> - parameter used to modulate the learning rate during the optimization process.</dd>
<dd><code>lambda</code> - penalization parameter to avoid overfitting during optimization process.</dd>
<dd><code>maxStep</code> - maximum number of iterations that will be performed.</dd>
<dd><code>vectorLength</code> - size of the feature vectors to be generated for the factorization.</dd>
<dd><code>features</code> - (out argument)
    vertex property holding the generated feature vectors for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Matrix factorization model holding the feature vectores found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, PgxVect&lt;Double&gt;&gt; features = graph.createVertexVectorProperty(PropertyType.DOUBLE, 20);
 PgxFuture&lt;MatrixFactorizationModel&lt;Integer&gt;&gt; promise = analyst.matrixFactorizationGradientDescentAsync(
   graph, cost, 0.1, 0.9, 0.1, 100, 20, features);
 promise.thenAccept(matrix -&gt; {
   matrix.getRootMeanSquareError();
 });
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://courses.ischool.berkeley.edu/i290-dm/s11/SECURE/Koren_Matrix_Factorization.pdf">Matrix factorization techniques for recommender systems</a></dd>
</dl>
</li>
</ul>
<a name="matrixFactorizationGradientDescentAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matrixFactorizationGradientDescentAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/MatrixFactorizationModel.html" title="class in oracle.pgx.api">MatrixFactorizationModel</a>&lt;ID&gt;&gt;&nbsp;matrixFactorizationGradientDescentAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Double&gt;&gt;&nbsp;features)</pre>
<div class="block"><p>Matrix factorization can be used as a recommendation algorithm for bipartite graphs
</p>
      <h2>Definition</h2>
      <p>This algorithm needs a [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph to generate feature vectors that factorize the given set of left vertices (users) and right vertices (items), so that the inner product of such feature vectors can recover the information from the original graph structure, which can be seen as a sparse matrix. The generated feature vectors can be used for making recommendations with the given set of users, where a good recommendation for a given user will be a dot (inner) product between the feature vector of the user and the corresponding feature vector of a vertex from the item set, such that the result of that dot product returns a high score.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k * s) with E = number of edges, k = maximum number of iteration, s = size of the feature vectors</code></li>
        <li>Space: <code>O(2 * V * s) with V = number of vertices, s = size of the feature vectors</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be used to get recommendations. The computed feature vectors can also be used to make predictions.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>weight</code> - edge property holding the rating weight of each edge in the graph. The weight needs to be pre-scaled into the range 1-5. If the weight values are not between 1 and 5, the result will become inaccurate.</dd>
<dd><code>features</code> - (out argument)
    vertex property holding the generated feature vectors for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Matrix factorization model holding the feature vectores found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, PgxVect&lt;Double&gt;&gt; features = graph.createVertexVectorProperty(PropertyType.DOUBLE, 20);
 PgxFuture&lt;MatrixFactorizationModel&lt;Integer&gt;&gt; promise = analyst.matrixFactorizationGradientDescentAsync(
   graph, cost, features);
 promise.thenAccept(matrix -&gt; {
   matrix.getRootMeanSquareError();
 });
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://courses.ischool.berkeley.edu/i290-dm/s11/SECURE/Koren_Matrix_Factorization.pdf">Matrix factorization techniques for recommender systems</a></dd>
</dl>
</li>
</ul>
<a name="matrixFactorizationRecommendations-oracle.pgx.api.BipartiteGraph-java.lang.Object-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a><a name="matrixFactorizationRecommendations-oracle.pgx.api.BipartiteGraph-ID-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matrixFactorizationRecommendations</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;matrixFactorizationRecommendations(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                                   ID&nbsp;user,
                                                                                   int&nbsp;vectorLength,
                                                                                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Double&gt;&gt;&nbsp;feature,
                                                                                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;estimatedRating)
                                                                            throws java.util.concurrent.ExecutionException,
                                                                                   java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#matrixFactorizationRecommendations-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-"><code>matrixFactorizationRecommendations(BipartiteGraph, PgxVertex, int,
 VertexProperty, VertexProperty)</code></a> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="matrixFactorizationRecommendations-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matrixFactorizationRecommendations</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;matrixFactorizationRecommendations(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                                   <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;user,
                                                                                   int&nbsp;vectorLength,
                                                                                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Double&gt;&gt;&nbsp;feature,
                                                                                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;estimatedRating)
                                                                            throws java.lang.InterruptedException,
                                                                                   java.util.concurrent.ExecutionException</pre>
<div class="block"><p>Estimate rating can be used as a prediction algorithm for bipartite graphs
</p>
      <h2>Definition</h2>
      <p>This algorithm is a complement for Matrix Factorization, thus it needs a bipartite graph and the generated feature vectors from such algorithm. The generated feature vectors will be used for making predictions in cases where the given user vertex has not been related to a particular item from the item set. Similarly to the recommendations from matrix factorization, this algorithm will perform dot products between the given user vertex and the rest of vertices in the graph, giving a score of 0 to the items that are already related to the user and to the products with other user vertices, hence returning the results of the dot products for the unrelated item vertices. The scores from those dot products can be interpreted as the predicted scores for the unrelated items given a particular user vertex.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm uses computed feature vectors from Matrix Factorization to make predictions about unrelated vertices from the item set (right vertices in the bipartite graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>user</code> - vertex from the left (user) side of the graph.</dd>
<dd><code>vectorLength</code> - size of the feature vectors.</dd>
<dd><code>feature</code> - vertex property holding the feature vectors for each vertex.</dd>
<dd><code>estimatedRating</code> - (out argument)
    vertex property holding the estimated rating score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the estimated rating score for each vertex.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code></dd>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://courses.ischool.berkeley.edu/i290-dm/s11/SECURE/Koren_Matrix_Factorization.pdf">Matrix factorization techniques for recommender systems</a></dd>
</dl>
</li>
</ul>
<a name="matrixFactorizationRecommendationsAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matrixFactorizationRecommendationsAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;matrixFactorizationRecommendationsAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                                                   <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;user,
                                                                                                   int&nbsp;vectorLength,
                                                                                                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVect.html" title="class in oracle.pgx.api">PgxVect</a>&lt;java.lang.Double&gt;&gt;&nbsp;feature,
                                                                                                   <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;estimatedRating)</pre>
<div class="block"><p>Estimate rating can be used as a prediction algorithm for bipartite graphs
</p>
      <h2>Definition</h2>
      <p>This algorithm is a complement for Matrix Factorization, thus it needs a bipartite graph and the generated feature vectors from such algorithm. The generated feature vectors will be used for making predictions in cases where the given user vertex has not been related to a particular item from the item set. Similarly to the recommendations from matrix factorization, this algorithm will perform dot products between the given user vertex and the rest of vertices in the graph, giving a score of 0 to the items that are already related to the user and to the products with other user vertices, hence returning the results of the dot products for the unrelated item vertices. The scores from those dot products can be interpreted as the predicted scores for the unrelated items given a particular user vertex.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm uses computed feature vectors from Matrix Factorization to make predictions about unrelated vertices from the item set (right vertices in the bipartite graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>user</code> - vertex from the left (user) side of the graph.</dd>
<dd><code>vectorLength</code> - size of the feature vectors.</dd>
<dd><code>feature</code> - vertex property holding the feature vectors for each vertex.</dd>
<dd><code>estimatedRating</code> - (out argument)
    vertex property holding the estimated rating score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the estimated rating score for each vertex.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://courses.ischool.berkeley.edu/i290-dm/s11/SECURE/Koren_Matrix_Factorization.pdf">Matrix factorization techniques for recommender systems</a></dd>
</dl>
</li>
</ul>
<a name="outDegreeCentrality-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outDegreeCentrality</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;outDegreeCentrality(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Out-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood
</p>
      <h2>Definition</h2>
      <p>Out-Degree centrality returns the sum of the number of outgoing edges for each vertex in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelism.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since out-degree centrality accounts for the connections of the vertices, it can be used to see the influence a vertex has over the vertices in its immediate neighborhood.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the degree centrality value for each vertex in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Integer&gt; degree = analyst.outDegreeCentrality(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + degree.getName() + " MATCH (x) ORDER BY x." + degree.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="outDegreeCentrality-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outDegreeCentrality</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;outDegreeCentrality(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;dc)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Out-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood
</p>
      <h2>Definition</h2>
      <p>Out-Degree centrality returns the sum of the number of outgoing edges for each vertex in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelism.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since out-degree centrality accounts for the connections of the vertices, it can be used to see the influence a vertex has over the vertices in its immediate neighborhood.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>dc</code> - (out argument)
    vertex property holding the degree centrality value for each vertex in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the degree centrality value for each vertex in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Integer&gt; dc = graph.createVertexProperty(PropertyType.INTEGER);
 VertexProperty&lt;Integer, Integer&gt; degree = analyst.outDegreeCentrality(graph, dc);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + degree.getName() + " MATCH (x) ORDER BY x." + degree.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="outDegreeCentralityAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outDegreeCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;outDegreeCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Out-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood
</p>
      <h2>Definition</h2>
      <p>Out-Degree centrality returns the sum of the number of outgoing edges for each vertex in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelism.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since out-degree centrality accounts for the connections of the vertices, it can be used to see the influence a vertex has over the vertices in its immediate neighborhood.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the degree centrality value for each vertex in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Integer&gt;&gt; promise = analyst.outDegreeCentralityAsync(graph);
 promise.thenCompose(degree -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + degree.getName() + " MATCH (x) ORDER BY x." + degree.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="outDegreeCentralityAsync-oracle.pgx.api.PgxGraph-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outDegreeCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;outDegreeCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     java.lang.String&nbsp;propertyName)</pre>
</li>
</ul>
<a name="outDegreeCentralityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outDegreeCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;outDegreeCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;dc)</pre>
<div class="block"><p>Out-degree centrality measures the centrality of the vertices based on its degree, letting you see how a vertex influences its neighborhood
</p>
      <h2>Definition</h2>
      <p>Out-Degree centrality returns the sum of the number of outgoing edges for each vertex in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelism.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since out-degree centrality accounts for the connections of the vertices, it can be used to see the influence a vertex has over the vertices in its immediate neighborhood.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>dc</code> - (out argument)
    vertex property holding the degree centrality value for each vertex in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the degree centrality value for each vertex in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Integer&gt; dc = graph.createVertexProperty(PropertyType.INTEGER);
 PgxFuture&lt;VertexProperty&lt;Integer, Integer&gt;&gt; promise = analyst.outDegreeCentralityAsync(graph, dc);
 promise.thenCompose(degree -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + degree.getName() + " MATCH (x) ORDER BY x." + degree.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="outDegreeDistribution-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outDegreeDistribution</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&nbsp;outDegreeDistribution(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                               throws java.util.concurrent.ExecutionException,
                                                                      java.lang.InterruptedException</pre>
<div class="block"><p>Out-degree distribution gives information about the outgoing flows in a graph
</p>
      <h2>Definition</h2>
      <p>This version of the degree distribution will return a map with the distirbution of the out-degree (i.e. just outgoing edges) of the graph. For undirected graphs the algorithm will consider all the edges (incoming and outgoing) for the distribution.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way. It uses a map with type int for the keys and type long for storing the mapped values of the distribution, like a histogram.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Degree distribution is a basic structural property of a graph which can help to characterize and classify them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>map holding a histogram of the node degrees in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxMap&lt;Integer, Long&gt; degree = analyst.outDegreeDistribution(graph);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="outDegreeDistribution-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outDegreeDistribution</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&nbsp;outDegreeDistribution(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                      <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&nbsp;distribution)
                                                               throws java.util.concurrent.ExecutionException,
                                                                      java.lang.InterruptedException</pre>
<div class="block"><p>Out-degree distribution gives information about the outgoing flows in a graph
</p>
      <h2>Definition</h2>
      <p>This version of the degree distribution will return a map with the distirbution of the out-degree (i.e. just outgoing edges) of the graph. For undirected graphs the algorithm will consider all the edges (incoming and outgoing) for the distribution.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way. It uses a map with type int for the keys and type long for storing the mapped values of the distribution, like a histogram.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Degree distribution is a basic structural property of a graph which can help to characterize and classify them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>distribution</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>map holding a histogram of the node degrees in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxMap&lt;Integer, Long&gt; distribution = graph.createMap(PropertyType.INTEGER, PropertyType.LONG);
 PgxMap&lt;Integer, Long&gt; degree = analyst.outDegreeDistribution(graph, distribution);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="outDegreeDistributionAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outDegreeDistributionAsync</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&gt;&nbsp;outDegreeDistributionAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Out-degree distribution gives information about the outgoing flows in a graph
</p>
      <h2>Definition</h2>
      <p>This version of the degree distribution will return a map with the distirbution of the out-degree (i.e. just outgoing edges) of the graph. For undirected graphs the algorithm will consider all the edges (incoming and outgoing) for the distribution.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way. It uses a map with type int for the keys and type long for storing the mapped values of the distribution, like a histogram.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Degree distribution is a basic structural property of a graph which can help to characterize and classify them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>map holding a histogram of the node degrees in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;PgxMap&lt;Integer, Long&gt;&gt; promise = analyst.outDegreeDistributionAsync(graph);
 promise.thenAccept(map -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="outDegreeDistributionAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxMap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outDegreeDistributionAsync</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&gt;&nbsp;outDegreeDistributionAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                      <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;java.lang.Integer,java.lang.Long&gt;&nbsp;distribution)</pre>
<div class="block"><p>Out-degree distribution gives information about the outgoing flows in a graph
</p>
      <h2>Definition</h2>
      <p>This version of the degree distribution will return a map with the distirbution of the out-degree (i.e. just outgoing edges) of the graph. For undirected graphs the algorithm will consider all the edges (incoming and outgoing) for the distribution.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way. It uses a map with type int for the keys and type long for storing the mapped values of the distribution, like a histogram.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V) with V = number of vertices</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Degree distribution is a basic structural property of a graph which can help to characterize and classify them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>distribution</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>map holding a histogram of the node degrees in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxMap&lt;Integer, Long&gt; distribution = graph.createMap(PropertyType.INTEGER, PropertyType.LONG);
 PgxFuture&lt;PgxMap&lt;Integer, Long&gt;&gt; promise = analyst.outDegreeDistributionAsync(graph, distribution);
 promise.thenAccept(map -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="pagerank-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;pagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                  throws java.util.concurrent.ExecutionException,
                                                         java.lang.InterruptedException</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.pagerank(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="pagerank-oracle.pgx.api.PgxGraph-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;pagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                         boolean&nbsp;norm)
                                                  throws java.util.concurrent.ExecutionException,
                                                         java.lang.InterruptedException</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.pagerank(graph, false);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="pagerank-oracle.pgx.api.PgxGraph-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;pagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                         boolean&nbsp;norm,
                                                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                  throws java.util.concurrent.ExecutionException,
                                                         java.lang.InterruptedException</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.pagerank(graph, false, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="pagerank-oracle.pgx.api.PgxGraph-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;pagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                         double&nbsp;e,
                                                         double&nbsp;d,
                                                         int&nbsp;max)
                                                  throws java.util.concurrent.ExecutionException,
                                                         java.lang.InterruptedException</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.pagerank(graph, 0.001, 0.85, 100);
 PgqlResultSet rs = graph.queryPgql("SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." +
   pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="pagerank-oracle.pgx.api.PgxGraph-double-double-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;pagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                         double&nbsp;e,
                                                         double&nbsp;d,
                                                         int&nbsp;max,
                                                         boolean&nbsp;norm)
                                                  throws java.util.concurrent.ExecutionException,
                                                         java.lang.InterruptedException</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.pagerank(graph, 0.001, 0.85, 100, false);
 PgqlResultSet rs = graph.queryPgql("SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." +
   pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="pagerank-oracle.pgx.api.PgxGraph-double-double-int-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;pagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                         double&nbsp;e,
                                                         double&nbsp;d,
                                                         int&nbsp;max,
                                                         boolean&nbsp;norm,
                                                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                  throws java.util.concurrent.ExecutionException,
                                                         java.lang.InterruptedException</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.pagerank(graph, 0.001, 0.85, 100, false, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="pagerank-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;pagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                         double&nbsp;e,
                                                         double&nbsp;d,
                                                         int&nbsp;max,
                                                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                  throws java.util.concurrent.ExecutionException,
                                                         java.lang.InterruptedException</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.pagerank(graph, 0.001, 0.85, 100, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="pagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;pagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                  throws java.util.concurrent.ExecutionException,
                                                         java.lang.InterruptedException</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.pagerank(graph, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="pagerankApproximate-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankApproximate</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;pagerankApproximate(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                             throws java.util.concurrent.ExecutionException,
                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>Faster, but less accurate than pagerank. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the PageRank algorithm computes the ranking scores for the vertices in similar way to the classic algorithm without normalization and with a more relaxed convergence criteria, since the tolerated error value is compared against each single vertex in the graph, instead of looking at the cumulative vertex error. Thus this variant will converge faster than the classic algorithm, but the ranking values might not be as accurate as in the classic implementation.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The ranking values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.pagerankApproximate(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="pagerankApproximate-oracle.pgx.api.PgxGraph-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankApproximate</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;pagerankApproximate(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                    double&nbsp;e,
                                                                    double&nbsp;d,
                                                                    int&nbsp;max)
                                                             throws java.util.concurrent.ExecutionException,
                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>Faster, but less accurate than pagerank. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the PageRank algorithm computes the ranking scores for the vertices in similar way to the classic algorithm without normalization and with a more relaxed convergence criteria, since the tolerated error value is compared against each single vertex in the graph, instead of looking at the cumulative vertex error. Thus this variant will converge faster than the classic algorithm, but the ranking values might not be as accurate as in the classic implementation.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The ranking values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.pagerankApproximate(graph, 0.001, 0.85, 100);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="pagerankApproximate-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankApproximate</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;pagerankApproximate(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                    double&nbsp;e,
                                                                    double&nbsp;d,
                                                                    int&nbsp;max,
                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                             throws java.util.concurrent.ExecutionException,
                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>Faster, but less accurate than pagerank. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the PageRank algorithm computes the ranking scores for the vertices in similar way to the classic algorithm without normalization and with a more relaxed convergence criteria, since the tolerated error value is compared against each single vertex in the graph, instead of looking at the cumulative vertex error. Thus this variant will converge faster than the classic algorithm, but the ranking values might not be as accurate as in the classic implementation.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The ranking values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.pagerankApproximate(graph, 0.001, 0.85, 100, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="pagerankApproximate-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankApproximate</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;pagerankApproximate(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                             throws java.util.concurrent.ExecutionException,
                                                                    java.lang.InterruptedException</pre>
<div class="block"><p>Faster, but less accurate than pagerank. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the PageRank algorithm computes the ranking scores for the vertices in similar way to the classic algorithm without normalization and with a more relaxed convergence criteria, since the tolerated error value is compared against each single vertex in the graph, instead of looking at the cumulative vertex error. Thus this variant will converge faster than the classic algorithm, but the ranking values might not be as accurate as in the classic implementation.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The ranking values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.pagerankApproximate(graph, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="pagerankApproximateAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankApproximateAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;pagerankApproximateAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Faster, but less accurate than pagerank. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the PageRank algorithm computes the ranking scores for the vertices in similar way to the classic algorithm without normalization and with a more relaxed convergence criteria, since the tolerated error value is compared against each single vertex in the graph, instead of looking at the cumulative vertex error. Thus this variant will converge faster than the classic algorithm, but the ranking values might not be as accurate as in the classic implementation.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The ranking values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.pagerankApproximateAsync(graph);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="pagerankApproximateAsync-oracle.pgx.api.PgxGraph-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankApproximateAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;pagerankApproximateAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                    double&nbsp;e,
                                                                                    double&nbsp;d,
                                                                                    int&nbsp;max)</pre>
<div class="block"><p>Faster, but less accurate than pagerank. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the PageRank algorithm computes the ranking scores for the vertices in similar way to the classic algorithm without normalization and with a more relaxed convergence criteria, since the tolerated error value is compared against each single vertex in the graph, instead of looking at the cumulative vertex error. Thus this variant will converge faster than the classic algorithm, but the ranking values might not be as accurate as in the classic implementation.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The ranking values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.pagerankApproximateAsync(graph, 0.001, 0.85, 100);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="pagerankApproximateAsync-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankApproximateAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;pagerankApproximateAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                    double&nbsp;e,
                                                                                    double&nbsp;d,
                                                                                    int&nbsp;max,
                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Faster, but less accurate than pagerank. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the PageRank algorithm computes the ranking scores for the vertices in similar way to the classic algorithm without normalization and with a more relaxed convergence criteria, since the tolerated error value is compared against each single vertex in the graph, instead of looking at the cumulative vertex error. Thus this variant will converge faster than the classic algorithm, but the ranking values might not be as accurate as in the classic implementation.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The ranking values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.pagerankApproximateAsync(
   graph, 0.001, 0.85, 100, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="pagerankApproximateAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankApproximateAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;pagerankApproximateAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Faster, but less accurate than pagerank. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the PageRank algorithm computes the ranking scores for the vertices in similar way to the classic algorithm without normalization and with a more relaxed convergence criteria, since the tolerated error value is compared against each single vertex in the graph, instead of looking at the cumulative vertex error. Thus this variant will converge faster than the classic algorithm, but the ranking values might not be as accurate as in the classic implementation.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The ranking values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.pagerankApproximateAsync(graph, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="pagerankAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;pagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.pagerankAsync(graph);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="pagerankAsync-oracle.pgx.api.PgxGraph-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;pagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                         boolean&nbsp;norm)</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.pagerankAsync(graph, false);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="pagerankAsync-oracle.pgx.api.PgxGraph-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;pagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                         boolean&nbsp;norm,
                                                                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.pagerankAsync(graph, false, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="pagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;pagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                         double&nbsp;e,
                                                                         double&nbsp;d,
                                                                         int&nbsp;max)</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.pagerankAsync(graph, 0.001, 0.85, 100);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="pagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;pagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                         double&nbsp;e,
                                                                         double&nbsp;d,
                                                                         int&nbsp;max,
                                                                         boolean&nbsp;norm)</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.pagerankAsync(graph, 0.001, 0.85, 100, false);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="pagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;pagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                         double&nbsp;e,
                                                                         double&nbsp;d,
                                                                         int&nbsp;max,
                                                                         boolean&nbsp;norm,
                                                                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.pagerankAsync(graph, 0.001, 0.85, 100, false, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="pagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;pagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                         double&nbsp;e,
                                                                         double&nbsp;d,
                                                                         int&nbsp;max,
                                                                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.pagerankAsync(graph, 0.001, 0.85, 100, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="pagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;pagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                         <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>PageRank computes ranking scores based on the edges in a graph. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>PageRank is an algorithm that computes ranking scores for the vertices using the network created by the incoming edges in the graph. Thus it is intended for directed graphs, although undirected graphs can be treated as well by converting them into directed graphs with reciprocated edges (i.e. keeping the original edge and creating a second one going in the opposite direction). The edges on the graph will define the relevance of each vertex in the graph, reflecting this on the scores, meaning that greater scores will correspond to vertices with greater relevance.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>max_iter: 100</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>PageRank can be used to measure the relative importance of documents which are linked together, such as the World Wide Web. The computed rank represents a probability distribution of the likelihood that a person randomly clicking on links will arrive at any particular page.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.pagerankAsync(graph, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="partitionConductance-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partitionConductance</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;,<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;&nbsp;partitionConductance(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                         <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition)
                                                                                  throws java.util.concurrent.ExecutionException,
                                                                                         java.lang.InterruptedException</pre>
<div class="block"><p>Partition conductance assesses the quality of many partitions in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the conductance algorithm will compute the conductance for the given number of components, returning an output with the minimun value of conductance found from the corresponding partitions and their average conductance value.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization. Note that this algorithm will be inefficient if number_of_components are big (i.e. O(N)).
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(1)</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Conductance can be used to measure how well connected is a graph, making it an useful auxiliar measure to assess the quality of clusters in a graph, since these could be regarded as the subsets of a cut.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partition</code> - Partition of the graph with the corresponding node collections.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair with two scalars, the first one with the value of the average conductance, and the second with
 minimun conductance value.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; partition = analyst.communitiesConductanceMinimization(graph);
 Pair&lt;Scalar&lt;Double&gt;, Scalar&lt;Double&gt;&gt; conductance = analyst.partitionConductance(graph, partition);
 conductance.getFirst().get();
 conductance.getSecond().get();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="partitionConductance-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-oracle.pgx.api.Scalar-oracle.pgx.api.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partitionConductance</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;,<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;&nbsp;partitionConductance(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                         <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                                                                                         <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;avgConductance,
                                                                                         <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;minConductance)
                                                                                  throws java.util.concurrent.ExecutionException,
                                                                                         java.lang.InterruptedException</pre>
<div class="block"><p>Partition conductance assesses the quality of many partitions in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the conductance algorithm will compute the conductance for the given number of components, returning an output with the minimun value of conductance found from the corresponding partitions and their average conductance value.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization. Note that this algorithm will be inefficient if number_of_components are big (i.e. O(N)).
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(1)</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Conductance can be used to measure how well connected is a graph, making it an useful auxiliar measure to assess the quality of clusters in a graph, since these could be regarded as the subsets of a cut.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partition</code> - Partition of the graph with the corresponding node collections.</dd>
<dd><code>avgConductance</code> - Scalar that will get updated with the computed average conductance value.</dd>
<dd><code>minConductance</code> - Scalar that will get updated with the computed minimum conductance value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair with two scalars, the first one with the value of the average conductance, and the second with
 minimun conductance value.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; partition = analyst.communitiesConductanceMinimization(graph);
 Scalar&lt;Double&gt; avgConductance = graph.createScalar(PropertyType.DOUBLE);
 Scalar&lt;Double&gt; minConductance = graph.createScalar(PropertyType.DOUBLE);
 Pair&lt;Scalar&lt;Double&gt;, Scalar&lt;Double&gt;&gt; conductance =
   analyst.partitionConductance(graph, partition, avgConductance, minConductance);
 conductance.getFirst().get();
 conductance.getSecond().get();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="partitionConductanceAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partitionConductanceAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;,<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;&gt;&nbsp;partitionConductanceAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                         <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition)</pre>
<div class="block"><p>Partition conductance assesses the quality of many partitions in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the conductance algorithm will compute the conductance for the given number of components, returning an output with the minimun value of conductance found from the corresponding partitions and their average conductance value.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization. Note that this algorithm will be inefficient if number_of_components are big (i.e. O(N)).
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(1)</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Conductance can be used to measure how well connected is a graph, making it an useful auxiliar measure to assess the quality of clusters in a graph, since these could be regarded as the subsets of a cut.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partition</code> - Partition of the graph with the corresponding node collections.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair with two scalars, the first one with the value of the average conductance, and the second with
 minimun conductance value.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; partition = analyst.communitiesConductanceMinimization(graph);
 PgxFuture&lt;Pair&lt;Scalar&lt;Double&gt;, Scalar&lt;Double&gt;&gt;&gt; promise = analyst.partitionConductanceAsync(graph, partition);
 promise.thenAccept(coductance -&gt; {
   coductance.getFirst().get();
   coductance.getSecond().get();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="partitionConductanceAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-oracle.pgx.api.Scalar-oracle.pgx.api.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partitionConductanceAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;,<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;&gt;&nbsp;partitionConductanceAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                         <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                                                                                                         <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;avgConductance,
                                                                                                         <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;minConductance)</pre>
<div class="block"><p>Partition conductance assesses the quality of many partitions in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the conductance algorithm will compute the conductance for the given number of components, returning an output with the minimun value of conductance found from the corresponding partitions and their average conductance value.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization. Note that this algorithm will be inefficient if number_of_components are big (i.e. O(N)).
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E) with E = number of edges</code></li>
        <li>Space: <code>O(1)</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Conductance can be used to measure how well connected is a graph, making it an useful auxiliar measure to assess the quality of clusters in a graph, since these could be regarded as the subsets of a cut.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partition</code> - Partition of the graph with the corresponding node collections.</dd>
<dd><code>avgConductance</code> - Scalar that will get updated with the computed average conductance value.</dd>
<dd><code>minConductance</code> - Scalar that will get updated with the computed minimum conductance value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair with two scalars, the first one with the value of the average conductance, and the second with
 minimun conductance value.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; partition = analyst.communitiesConductanceMinimization(graph);
 Scalar&lt;Double&gt; avgConductance = graph.createScalar(PropertyType.DOUBLE);
 Scalar&lt;Double&gt; minConductance = graph.createScalar(PropertyType.DOUBLE);
 PgxFuture&lt;Pair&lt;Scalar&lt;Double&gt;, Scalar&lt;Double&gt;&gt;&gt; promise = analyst.partitionConductanceAsync(
   graph, partition, avgConductance, minConductance);
 promise.thenAccept(coductance -&gt; {
   coductance.getFirst().get();
   coductance.getSecond().get();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="partitionModularity-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partitionModularity</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;partitionModularity(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                         <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition)
                                                  throws java.util.concurrent.ExecutionException,
                                                         java.lang.InterruptedException</pre>
<div class="block"><p>Modularity summarizes information about the quality of components in a graph
</p>
      <h2>Definition</h2>
      <p>Modularity in a graph is a measure for assessing the quality of the partition induced by the components (or community structures) within the graph found by any clustering algorithm (e.g. label propagation, Infomap, WCC, etc.). It compares the number of the edges between the vertices within a component against the expected number of edges if these were generated at random (assuming a uniform probability distribution). A possitive modularity value means that, on average, there are more edges within the components than the amount expected (meaning stronger components), and viceversa for a negative modularity value. This implementation is intended for directed graphs.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization. Note that this algorithm will be inefficient if number_of_components are big (i.e. O(N)).
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * c) with E = number of edges, c = number of components</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since modularity help to assess the quality of communities in a graph, it can be used in optimization processes when detecting them in other algorithms.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partition</code> - Partition of the graph with the corresponding node collections.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Scalar (double) with the modularity value.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; partition = analyst.communitiesConductanceMinimization(graph);
 Scalar&lt;Double&gt; modularity = analyst.partitionModularity(graph, partition);
 modularity.get();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="partitionModularity-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-oracle.pgx.api.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partitionModularity</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;partitionModularity(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                         <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                                                         <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;modularity)
                                                  throws java.util.concurrent.ExecutionException,
                                                         java.lang.InterruptedException</pre>
<div class="block"><p>Modularity summarizes information about the quality of components in a graph
</p>
      <h2>Definition</h2>
      <p>Modularity in a graph is a measure for assessing the quality of the partition induced by the components (or community structures) within the graph found by any clustering algorithm (e.g. label propagation, Infomap, WCC, etc.). It compares the number of the edges between the vertices within a component against the expected number of edges if these were generated at random (assuming a uniform probability distribution). A possitive modularity value means that, on average, there are more edges within the components than the amount expected (meaning stronger components), and viceversa for a negative modularity value. This implementation is intended for directed graphs.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization. Note that this algorithm will be inefficient if number_of_components are big (i.e. O(N)).
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * c) with E = number of edges, c = number of components</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since modularity help to assess the quality of communities in a graph, it can be used in optimization processes when detecting them in other algorithms.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partition</code> - Partition of the graph with the corresponding node collections.</dd>
<dd><code>modularity</code> - Scalar (double) to store the modularity value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Scalar (double) with the modularity value.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; partition = analyst.communitiesConductanceMinimization(graph);
 Scalar&lt;Double&gt; scalar = graph.createScalar(PropertyType.DOUBLE);
 Scalar&lt;Double&gt; modularity = analyst.partitionModularity(graph, partition, scalar);
 modularity.get();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="partitionModularityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partitionModularityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;&nbsp;partitionModularityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                         <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition)</pre>
<div class="block"><p>Modularity summarizes information about the quality of components in a graph
</p>
      <h2>Definition</h2>
      <p>Modularity in a graph is a measure for assessing the quality of the partition induced by the components (or community structures) within the graph found by any clustering algorithm (e.g. label propagation, Infomap, WCC, etc.). It compares the number of the edges between the vertices within a component against the expected number of edges if these were generated at random (assuming a uniform probability distribution). A possitive modularity value means that, on average, there are more edges within the components than the amount expected (meaning stronger components), and viceversa for a negative modularity value. This implementation is intended for directed graphs.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization. Note that this algorithm will be inefficient if number_of_components are big (i.e. O(N)).
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * c) with E = number of edges, c = number of components</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since modularity help to assess the quality of communities in a graph, it can be used in optimization processes when detecting them in other algorithms.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partition</code> - Partition of the graph with the corresponding node collections.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Scalar (double) with the modularity value.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; partition = analyst.communitiesConductanceMinimization(graph);
 PgxFuture&lt;Scalar&lt;Double&gt;&gt; promise = analyst.partitionModularityAsync(graph, partition);
 promise.thenAccept(modularity -&gt; {
   modularity.get();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="partitionModularityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-oracle.pgx.api.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partitionModularityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;&nbsp;partitionModularityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                         <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                                                                         <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&nbsp;modularity)</pre>
<div class="block"><p>Modularity summarizes information about the quality of components in a graph
</p>
      <h2>Definition</h2>
      <p>Modularity in a graph is a measure for assessing the quality of the partition induced by the components (or community structures) within the graph found by any clustering algorithm (e.g. label propagation, Infomap, WCC, etc.). It compares the number of the edges between the vertices within a component against the expected number of edges if these were generated at random (assuming a uniform probability distribution). A possitive modularity value means that, on average, there are more edges within the components than the amount expected (meaning stronger components), and viceversa for a negative modularity value. This implementation is intended for directed graphs.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization. Note that this algorithm will be inefficient if number_of_components are big (i.e. O(N)).
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * c) with E = number of edges, c = number of components</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Since modularity help to assess the quality of communities in a graph, it can be used in optimization processes when detecting them in other algorithms.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partition</code> - Partition of the graph with the corresponding node collections.</dd>
<dd><code>modularity</code> - Scalar (double) to store the modularity value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Scalar (double) with the modularity value.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; partition = analyst.communitiesConductanceMinimization(graph);
 Scalar&lt;Double&gt; scalar = graph.createScalar(PropertyType.DOUBLE);
 PgxFuture&lt;Scalar&lt;Double&gt;&gt; promise = analyst.partitionModularityAsync(graph, partition, scalar);
 promise.thenAccept(modularity -&gt; {
   modularity.get();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="partitionModularityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Partition-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partitionModularityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Double&gt;&gt;&nbsp;partitionModularityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                         <a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;partition,
                                                                         java.lang.String&nbsp;modularityName)</pre>
</li>
</ul>
<a name="periphery-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>periphery</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;periphery(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                             throws java.util.concurrent.ExecutionException,
                                    java.lang.InterruptedException</pre>
<div class="block"><p>Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The periphery of a graph is the set of vertices that have an eccentricity value equal to the diameter of the graph. Similarly, the center is comprised by the set of vertices with eccentricity equal to the radius of the graph. The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortests paths to any other vertex in the graph. This algorithm will return the set of vertices from the periphery or the center of the graph, depending on the request. The algorithm will return a set with all the vertices for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex set holding the vertices from the periphery or center of the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; periphery = analyst.periphery(graph);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="periphery-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>periphery</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;periphery(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                    <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;periphery)
                             throws java.util.concurrent.ExecutionException,
                                    java.lang.InterruptedException</pre>
<div class="block"><p>Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The periphery of a graph is the set of vertices that have an eccentricity value equal to the diameter of the graph. Similarly, the center is comprised by the set of vertices with eccentricity equal to the radius of the graph. The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortests paths to any other vertex in the graph. This algorithm will return the set of vertices from the periphery or the center of the graph, depending on the request. The algorithm will return a set with all the vertices for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>periphery</code> - (out argument) vertex set holding the vertices from the periphery or center of the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex set holding the vertices from the periphery or center of the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.createVertexSet();
 VertexSet&lt;Integer&gt; periphery = analyst.periphery(graph, vertices);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="peripheryAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>peripheryAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;&nbsp;peripheryAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The periphery of a graph is the set of vertices that have an eccentricity value equal to the diameter of the graph. Similarly, the center is comprised by the set of vertices with eccentricity equal to the radius of the graph. The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortests paths to any other vertex in the graph. This algorithm will return the set of vertices from the periphery or the center of the graph, depending on the request. The algorithm will return a set with all the vertices for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex set holding the vertices from the periphery or center of the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexSet&lt;Integer&gt;&gt; promise = analyst.peripheryAsync(graph);
 promise.thenAccept(periphery -&gt; {
   ...
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="peripheryAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>peripheryAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&gt;&nbsp;peripheryAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                    <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;periphery)</pre>
<div class="block"><p>Periphery/center gives an overview of the extreme distances and the corresponding vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The periphery of a graph is the set of vertices that have an eccentricity value equal to the diameter of the graph. Similarly, the center is comprised by the set of vertices with eccentricity equal to the radius of the graph. The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortests paths to any other vertex in the graph. This algorithm will return the set of vertices from the periphery or the center of the graph, depending on the request. The algorithm will return a set with all the vertices for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>periphery</code> - (out argument) vertex set holding the vertices from the periphery or center of the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex set holding the vertices from the periphery or center of the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.createVertexSet();
 PgxFuture&lt;VertexSet&lt;Integer&gt;&gt; promise = analyst.peripheryAsync(graph, vertices);
 promise.thenAccept(periphery -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-java.lang.Object-java.math.BigDecimal-java.math.BigDecimal-int-">
<!--   -->
</a><a name="personalizedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     ID&nbsp;vertexId,
                                                                     java.math.BigDecimal&nbsp;e,
                                                                     java.math.BigDecimal&nbsp;d,
                                                                     int&nbsp;max)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-java.math.BigDecimal-java.math.BigDecimal-int-"><code>personalizedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int,)</code></a>
 taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-java.lang.Object-java.math.BigDecimal-java.math.BigDecimal-int-boolean-">
<!--   -->
</a><a name="personalizedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     ID&nbsp;vertexId,
                                                                     java.math.BigDecimal&nbsp;e,
                                                                     java.math.BigDecimal&nbsp;d,
                                                                     int&nbsp;max,
                                                                     boolean&nbsp;norm)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-java.math.BigDecimal-java.math.BigDecimal-int-boolean-"><code>personalizedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int,
 boolean)</code></a> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-java.lang.Object-java.math.BigDecimal-java.math.BigDecimal-int-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a><a name="personalizedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     ID&nbsp;vertexId,
                                                                     java.math.BigDecimal&nbsp;e,
                                                                     java.math.BigDecimal&nbsp;d,
                                                                     int&nbsp;max,
                                                                     boolean&nbsp;norm,
                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around
 <code>#personalizedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int, boolean,
 VertexProperty<ID, Double>)</code> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-java.lang.Object-java.math.BigDecimal-java.math.BigDecimal-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a><a name="personalizedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     ID&nbsp;vertexId,
                                                                     java.math.BigDecimal&nbsp;e,
                                                                     java.math.BigDecimal&nbsp;d,
                                                                     int&nbsp;max,
                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <code>#personalizedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int,
 VertexProperty<ID, Double>)</code> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedPagerank(graph, vertex);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                     boolean&nbsp;norm)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedPagerank(graph, vertex, false);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                     boolean&nbsp;norm,
                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedPagerank(graph, vertex, false, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                     double&nbsp;e,
                                                                     double&nbsp;d,
                                                                     int&nbsp;max)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedPagerank(graph, vertex, 0.001, 0.85, 100);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                     double&nbsp;e,
                                                                     double&nbsp;d,
                                                                     int&nbsp;max,
                                                                     boolean&nbsp;norm)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedPagerank(graph, vertex, 0.001, 0.85, 100, false);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                     double&nbsp;e,
                                                                     double&nbsp;d,
                                                                     int&nbsp;max,
                                                                     boolean&nbsp;norm,
                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank =
   analyst.personalizedPagerank(graph, vertex, 0.001, 0.85, 100, false, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                     double&nbsp;e,
                                                                     double&nbsp;d,
                                                                     int&nbsp;max,
                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedPagerank(graph, vertex, 0.001, 0.85, 100, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedPagerank(graph, vertex, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedPagerank(graph, vertices);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                     boolean&nbsp;norm)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedPagerank(graph, vertices, false);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                     boolean&nbsp;norm,
                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedPagerank(graph, vertices, false, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                     double&nbsp;e,
                                                                     double&nbsp;d,
                                                                     int&nbsp;max)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedPagerank(graph, vertices, 0.001, 0.85, 100);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                     double&nbsp;e,
                                                                     double&nbsp;d,
                                                                     int&nbsp;max,
                                                                     boolean&nbsp;norm)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedPagerank(graph, vertices, 0.001, 0.85, 100, false);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                     double&nbsp;e,
                                                                     double&nbsp;d,
                                                                     int&nbsp;max,
                                                                     boolean&nbsp;norm,
                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank =
   analyst.personalizedPagerank(graph, vertices, 0.001, 0.85, 100, false, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                     double&nbsp;e,
                                                                     double&nbsp;d,
                                                                     int&nbsp;max,
                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedPagerank(graph, vertices, 0.001, 0.85, 100, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedPagerank(graph, vertices, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v)</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(graph, vertex);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                     boolean&nbsp;norm)</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(graph, vertex, false);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                     boolean&nbsp;norm,
                                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(graph, vertex, false, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                     double&nbsp;e,
                                                                                     double&nbsp;d,
                                                                                     int&nbsp;max)</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(
   graph, vertex, 0.001, 0.85, 100);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                     double&nbsp;e,
                                                                                     double&nbsp;d,
                                                                                     int&nbsp;max,
                                                                                     boolean&nbsp;norm)</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(
   graph, vertex, 0.001, 0.85, 100, false);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                     double&nbsp;e,
                                                                                     double&nbsp;d,
                                                                                     int&nbsp;max,
                                                                                     boolean&nbsp;norm,
                                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(
   graph, vertex, 0.001, 0.85, 100, false, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                     double&nbsp;e,
                                                                                     double&nbsp;d,
                                                                                     int&nbsp;max,
                                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(
   graph, vertex, 0.001, 0.85, 100, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized PageRank for a vertex of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the beginning.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(graph, vertex, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices)</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(graph, vertices);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                     boolean&nbsp;norm)</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(graph, vertices, false);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                     boolean&nbsp;norm,
                                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(
   graph, vertices, false, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                     double&nbsp;e,
                                                                                     double&nbsp;d,
                                                                                     int&nbsp;max)</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(
   graph, vertices, 0.001, 0.85, 100);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                     double&nbsp;e,
                                                                                     double&nbsp;d,
                                                                                     int&nbsp;max,
                                                                                     boolean&nbsp;norm)</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(
   graph, vertices, 0.001, 0.85, 100, false);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                     double&nbsp;e,
                                                                                     double&nbsp;d,
                                                                                     int&nbsp;max,
                                                                                     boolean&nbsp;norm,
                                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(
   graph, vertices, 0.001, 0.85, 100, false, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                     double&nbsp;e,
                                                                                     double&nbsp;d,
                                                                                     int&nbsp;max,
                                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(
   graph, vertices, 0.001, 0.85, 100, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized PageRank for a set of vertices of interest. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Pagerank allows to select a particular vertex or a set of vertices from the given graph in order to give them a greater importance when computing the ranking score, which will have as result a personalized Pagerank score and reveal relevant (or similar) vertices to the ones chosen at the begining.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It introduces the concept of personalization for the PageRank applications, which allows to get relevant information from the given subset of vertices.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedPagerankAsync(graph, vertices, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsa-oracle.pgx.api.BipartiteGraph-java.lang.Object-java.math.BigDecimal-int-java.math.BigDecimal-">
<!--   -->
</a><a name="personalizedSalsa-oracle.pgx.api.BipartiteGraph-ID-java.math.BigDecimal-int-java.math.BigDecimal-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsa</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedSalsa(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                  ID&nbsp;v,
                                                                  java.math.BigDecimal&nbsp;d,
                                                                  int&nbsp;maxIterations,
                                                                  java.math.BigDecimal&nbsp;maxDiff)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-java.math.BigDecimal-int-java.math.BigDecimal-"><code>personalizedSalsa(BipartiteGraph, PgxVertex, BigDecimal, int, BigDecimal)</code></a>
 taking a vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsa-oracle.pgx.api.BipartiteGraph-java.lang.Object-java.math.BigDecimal-int-java.math.BigDecimal-oracle.pgx.api.VertexProperty-">
<!--   -->
</a><a name="personalizedSalsa-oracle.pgx.api.BipartiteGraph-ID-java.math.BigDecimal-int-java.math.BigDecimal-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsa</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedSalsa(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                  ID&nbsp;v,
                                                                  java.math.BigDecimal&nbsp;d,
                                                                  int&nbsp;maxIterations,
                                                                  java.math.BigDecimal&nbsp;maxDiff,
                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around
 <code>#personalizedSalsa(BipartiteGraph, PgxVertex, BigDecimal, int, BigDecimal, VertexProperty<ID, Double>)</code>
 taking a vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsa</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedSalsa(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block"><p>Personalized salsa for a vertex of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; salsa = analyst.personalizedSalsa(graph, vertex);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-double-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsa</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedSalsa(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                  double&nbsp;d,
                                                                  int&nbsp;maxIter,
                                                                  double&nbsp;maxDiff)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block"><p>Personalized salsa for a vertex of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>d</code> - damping factor to modulate the degree of personalization of the scores by the algorithm.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; salsa = analyst.personalizedSalsa(graph, vertex, 0.85, 100, 0.001);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-double-int-double-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsa</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedSalsa(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                  double&nbsp;d,
                                                                  int&nbsp;maxIter,
                                                                  double&nbsp;maxDiff,
                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block"><p>Personalized salsa for a vertex of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>d</code> - damping factor to modulate the degree of personalization of the scores by the algorithm.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>salsaRank</code> - (out argument)
    vertex property holding the normalized authority/hub ranking score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; salsa = analyst.personalizedSalsa(graph, vertex, 0.85, 100, 0.001, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsa</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedSalsa(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block"><p>Personalized salsa for a vertex of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>salsaRank</code> - (out argument)
    vertex property holding the normalized authority/hub ranking score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; salsa = analyst.personalizedSalsa(graph, vertex, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsa</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedSalsa(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                  <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block"><p>Personalized salsa for a set of vertices of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; salsa = analyst.personalizedSalsa(graph, vertices);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-double-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsa</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedSalsa(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                  <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                  double&nbsp;d,
                                                                  int&nbsp;maxIter,
                                                                  double&nbsp;maxDiff)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block"><p>Personalized salsa for a set of vertices of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>d</code> - damping factor to modulate the degree of personalization of the scores by the algorithm.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; salsa = analyst.personalizedSalsa(graph, vertices, 0.85, 100, 0.001);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-double-int-double-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsa</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedSalsa(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                  <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                  double&nbsp;d,
                                                                  int&nbsp;maxIter,
                                                                  double&nbsp;maxDiff,
                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block"><p>Personalized salsa for a set of vertices of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>d</code> - damping factor to modulate the degree of personalization of the scores by the algorithm.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>salsaRank</code> - (out argument)
    vertex property holding the normalized authority/hub ranking score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; salsa = analyst.personalizedSalsa(graph, vertices, 0.85, 100, 0.001, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsa</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedSalsa(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                  <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block"><p>Personalized salsa for a set of vertices of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>salsaRank</code> - (out argument)
    vertex property holding the normalized authority/hub ranking score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; salsa = analyst.personalizedSalsa(graph, vertices, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsaAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedSalsaAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v)</pre>
<div class="block"><p>Personalized salsa for a vertex of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedSalsaAsync(graph, vertex);
 promise.thenCompose(salsa -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-double-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsaAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedSalsaAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                  double&nbsp;d,
                                                                                  int&nbsp;maxIter,
                                                                                  double&nbsp;maxDiff)</pre>
<div class="block"><p>Personalized salsa for a vertex of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>d</code> - damping factor to modulate the degree of personalization of the scores by the algorithm.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedSalsaAsync(
   graph, vertex, 0.85, 100, 0.001);
 promise.thenCompose(salsa -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-double-int-double-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsaAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedSalsaAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                  double&nbsp;d,
                                                                                  int&nbsp;maxIter,
                                                                                  double&nbsp;maxDiff,
                                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</pre>
<div class="block"><p>Personalized salsa for a vertex of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>d</code> - damping factor to modulate the degree of personalization of the scores by the algorithm.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>salsaRank</code> - (out argument)
    vertex property holding the normalized authority/hub ranking score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedSalsaAsync(
   graph, vertex, 0.85, 100, 0.001, rank);
 promise.thenCompose(salsa -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsaAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedSalsaAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</pre>
<div class="block"><p>Personalized salsa for a vertex of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>salsaRank</code> - (out argument)
    vertex property holding the normalized authority/hub ranking score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedSalsaAsync(graph, vertex, rank);
 promise.thenCompose(salsa -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsaAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedSalsaAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                                  <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices)</pre>
<div class="block"><p>Personalized salsa for a set of vertices of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedSalsaAsync(graph, vertices);
 promise.thenCompose(salsa -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-double-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsaAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedSalsaAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                                  <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                  double&nbsp;d,
                                                                                  int&nbsp;maxIter,
                                                                                  double&nbsp;maxDiff)</pre>
<div class="block"><p>Personalized salsa for a set of vertices of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>d</code> - damping factor to modulate the degree of personalization of the scores by the algorithm.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedSalsaAsync(
   graph, vertices, 0.85, 100, 0.001);
 promise.thenCompose(salsa -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-double-int-double-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsaAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedSalsaAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                                  <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                  double&nbsp;d,
                                                                                  int&nbsp;maxIter,
                                                                                  double&nbsp;maxDiff,
                                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</pre>
<div class="block"><p>Personalized salsa for a set of vertices of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>d</code> - damping factor to modulate the degree of personalization of the scores by the algorithm.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>salsaRank</code> - (out argument)
    vertex property holding the normalized authority/hub ranking score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedSalsaAsync(
   graph, vertices, 0.85, 100, 0.001, rank);
 promise.thenCompose(salsa -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="personalizedSalsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedSalsaAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedSalsaAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                                  <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</pre>
<div class="block"><p>Personalized salsa for a set of vertices of interest. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>This Personalized version of SALSA allows to select a particular vertex or set of vertices from the given graph in order to give them a greater importance when computing the ranking scores, which will have as result a personalized SALSA score and show relevant (or similar) vertices to the ones chosen for the personalization.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>salsaRank</code> - (out argument)
    vertex property holding the normalized authority/hub ranking score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedSalsaAsync(graph, vertices, rank);
 promise.thenCompose(salsa -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-java.lang.Object-java.math.BigDecimal-java.math.BigDecimal-int-boolean-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a><a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-boolean-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             ID&nbsp;vertexId,
                                                                             java.math.BigDecimal&nbsp;e,
                                                                             java.math.BigDecimal&nbsp;d,
                                                                             int&nbsp;max,
                                                                             boolean&nbsp;norm,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-java.math.BigDecimal-java.math.BigDecimal-int-boolean-oracle.pgx.api.EdgeProperty-"><code>personalizedWeightedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int,
 boolean, EdgeProperty)</code></a> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-java.lang.Object-java.math.BigDecimal-java.math.BigDecimal-int-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a><a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             ID&nbsp;vertexId,
                                                                             java.math.BigDecimal&nbsp;e,
                                                                             java.math.BigDecimal&nbsp;d,
                                                                             int&nbsp;max,
                                                                             boolean&nbsp;norm,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around
 <code>#personalizedWeightedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int, boolean, EdgeProperty,
 VertexProperty<ID, Double>)</code> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-java.lang.Object-java.math.BigDecimal-java.math.BigDecimal-int-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a><a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             ID&nbsp;vertexId,
                                                                             java.math.BigDecimal&nbsp;e,
                                                                             java.math.BigDecimal&nbsp;d,
                                                                             int&nbsp;max,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-java.math.BigDecimal-java.math.BigDecimal-int-oracle.pgx.api.EdgeProperty-"><code>personalizedWeightedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int,
 EdgeProperty)</code></a> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-java.lang.Object-java.math.BigDecimal-java.math.BigDecimal-int-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a><a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-ID-java.math.BigDecimal-java.math.BigDecimal-int-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             ID&nbsp;vertexId,
                                                                             java.math.BigDecimal&nbsp;e,
                                                                             java.math.BigDecimal&nbsp;d,
                                                                             int&nbsp;max,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around
 <code>#personalizedWeightedPagerank(PgxGraph, PgxVertex, BigDecimal, BigDecimal, int, EdgeProperty,
 VertexProperty<ID, Double>)</code> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                             boolean&nbsp;norm,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedWeightedPagerank(graph, vertex, false, cost);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                             boolean&nbsp;norm,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedWeightedPagerank(graph, vertex, false, cost, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                             double&nbsp;e,
                                                                             double&nbsp;d,
                                                                             int&nbsp;max,
                                                                             boolean&nbsp;norm,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; pagerank =
    analyst.personalizedWeightedPagerank(graph, vertex, 0.001, 0.85, 100, false, cost);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                             double&nbsp;e,
                                                                             double&nbsp;d,
                                                                             int&nbsp;max,
                                                                             boolean&nbsp;norm,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank =
   analyst.personalizedWeightedPagerank(graph, vertex, 0.001, 0.85, 100, false, cost, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                             double&nbsp;e,
                                                                             double&nbsp;d,
                                                                             int&nbsp;max,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; pagerank =
   analyst.personalizedWeightedPagerank(graph, vertex, 0.001, 0.85, 100, cost);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                             double&nbsp;e,
                                                                             double&nbsp;d,
                                                                             int&nbsp;max,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank =
    analyst.personalizedWeightedPagerank(graph, vertex, 0.001, 0.85, 100, cost, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedWeightedPagerank(graph, vertex, cost);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedWeightedPagerank(graph, vertex, cost, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                             boolean&nbsp;norm,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedWeightedPagerank(graph, vertices, false, cost);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                             boolean&nbsp;norm,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank =
   analyst.personalizedWeightedPagerank(graph, vertices, false, cost, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                             double&nbsp;e,
                                                                             double&nbsp;d,
                                                                             int&nbsp;max,
                                                                             boolean&nbsp;norm,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; pagerank =
   analyst.personalizedWeightedPagerank(graph, vertices, 0.001, 0.85, 100, false, cost);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                             double&nbsp;e,
                                                                             double&nbsp;d,
                                                                             int&nbsp;max,
                                                                             boolean&nbsp;norm,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank =
   analyst.personalizedWeightedPagerank(graph, vertices, 0.001, 0.85, 100, false, cost, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                             double&nbsp;e,
                                                                             double&nbsp;d,
                                                                             int&nbsp;max,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; pagerank =
   analyst.personalizedWeightedPagerank(graph, vertices, 0.001, 0.85, 100, cost);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                             double&nbsp;e,
                                                                             double&nbsp;d,
                                                                             int&nbsp;max,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank =
   analyst.personalizedWeightedPagerank(graph, vertices, 0.001, 0.85, 100, cost, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedWeightedPagerank(graph, vertices, cost);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;personalizedWeightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                                      throws java.util.concurrent.ExecutionException,
                                                                             java.lang.InterruptedException</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.personalizedWeightedPagerank(graph, vertices, cost, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                             boolean&nbsp;norm,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertex, false, cost);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                             boolean&nbsp;norm,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertex, false, cost, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                             double&nbsp;e,
                                                                                             double&nbsp;d,
                                                                                             int&nbsp;max,
                                                                                             boolean&nbsp;norm,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertex, 0.001, 0.85, 100, false, cost);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                             double&nbsp;e,
                                                                                             double&nbsp;d,
                                                                                             int&nbsp;max,
                                                                                             boolean&nbsp;norm,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertex, 0.001, 0.85, 100, false, cost, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                             double&nbsp;e,
                                                                                             double&nbsp;d,
                                                                                             int&nbsp;max,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertex, 0.001, 0.85, 100, cost);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-double-double-int-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                             double&nbsp;e,
                                                                                             double&nbsp;d,
                                                                                             int&nbsp;max,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertex, 0.001, 0.85, 100, cost, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertex, cost);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;v,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized weighted pagerank for a vertex and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>v</code> - the chosen vertex from the graph for personalization.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) weighted PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertex, cost, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                             boolean&nbsp;norm,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertices, false, cost);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                             boolean&nbsp;norm,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertices, false, cost, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                             double&nbsp;e,
                                                                                             double&nbsp;d,
                                                                                             int&nbsp;max,
                                                                                             boolean&nbsp;norm,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertices, 0.001, 0.85, 100, false, cost);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                             double&nbsp;e,
                                                                                             double&nbsp;d,
                                                                                             int&nbsp;max,
                                                                                             boolean&nbsp;norm,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertices, 0.001, 0.85, 100, false, cost, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                             double&nbsp;e,
                                                                                             double&nbsp;d,
                                                                                             int&nbsp;max,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertices, 0.001, 0.85, 100, cost);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-double-double-int-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                             double&nbsp;e,
                                                                                             double&nbsp;d,
                                                                                             int&nbsp;max,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertices, 0.001, 0.85, 100, cost, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertices, cost);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="personalizedWeightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>personalizedWeightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;personalizedWeightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                             <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;vertices,
                                                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>Personalized pagerank for a set of vertices and weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Personalized Weighted Pagerank combines elements from the weighted and the personalized versions in order to make the personalization of the results more unique, since both: the selection of a subset of vertices and the inclusion of specific weights in the edges, will help to set the importance of the ranking scores when these are being computed.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This variant takes the personalization of the ranking scores a step further, thus its use is suggested when looking for highly personalized results.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertices</code> - the set of chosen vertices from the graph for personalization.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument)
    vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; vertices = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.personalizedWeightedPagerankAsync(
   graph, vertices, cost, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://infolab.stanford.edu/pub/papers/google.pdf">The Anatomy of a Large-Scale Hypertextual Web Search Engine</a>, 
<a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank citation ranking: Bringing order to the Web.</a></dd>
</dl>
</li>
</ul>
<a name="pg2vecModelBuilder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pg2vecModelBuilder</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/mllib/Pg2vecModelBuilder.html" title="class in oracle.pgx.api.mllib">Pg2vecModelBuilder</a>&nbsp;pg2vecModelBuilder()</pre>
<div class="block">Builds a pg2vec model</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a name="prim-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prim</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Boolean&gt;&nbsp;prim(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                     throws java.util.concurrent.ExecutionException,
                                            java.lang.InterruptedException</pre>
<div class="block"><p>prim reveals tree structures with shortest paths in a graph
</p>
      <h2>Definition</h2>
      <p>This implementation of Prim's algorithm works on undirected graphs that are connected and have no multi-edges (i.e. more than one edge connecting the same pair of vertices). The algorithm computes the minimum spanning tree (MST) of the graph using the weights associated to each edge. A minimum spanning tree is a subset of the edges that connects all the vertices in the graph such that it minimizes the total weight assiciated to the edges.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * E + V) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The trees found with Prim's algorithm can be used to simplify the desgin of networks when just looking to connect all the elements on the network, like in computer or transportation networks. It can also be used to generate mazes using the structure of a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>edge property holding the edges belonging to the minimum spanning tree of the graph (i.e. all the edges with in_mst=true).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 EdgeProperty&lt;Boolean&gt; prim = analyst.prim(graph, cost);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + prim.getName() + " MATCH (x) ORDER BY x." + prim.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="prim-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prim</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Boolean&gt;&nbsp;prim(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Boolean&gt;&nbsp;mst)
                                     throws java.util.concurrent.ExecutionException,
                                            java.lang.InterruptedException</pre>
<div class="block"><p>prim reveals tree structures with shortest paths in a graph
</p>
      <h2>Definition</h2>
      <p>This implementation of Prim's algorithm works on undirected graphs that are connected and have no multi-edges (i.e. more than one edge connecting the same pair of vertices). The algorithm computes the minimum spanning tree (MST) of the graph using the weights associated to each edge. A minimum spanning tree is a subset of the edges that connects all the vertices in the graph such that it minimizes the total weight assiciated to the edges.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * E + V) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The trees found with Prim's algorithm can be used to simplify the desgin of networks when just looking to connect all the elements on the network, like in computer or transportation networks. It can also be used to generate mazes using the structure of a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>mst</code> - (out argument) edge property holding the edges belonging to the minimum spanning tree of the graph (i.e. all the edges with in_mst=true).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>edge property holding the edges belonging to the minimum spanning tree of the graph (i.e. all the edges with in_mst=true).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 EdgeProperty&lt;Boolean&gt; mst = graph.createEdgeProperty(PropertyType.BOOLEAN);
 EdgeProperty&lt;Boolean&gt; prim = analyst.prim(graph, cost, mst);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + prim.getName() + " MATCH (x) ORDER BY x." + prim.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="prim-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prim</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Boolean&gt;&nbsp;prim(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                            java.lang.String&nbsp;mstName)
                                     throws java.util.concurrent.ExecutionException,
                                            java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#prim-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-java.lang.String-"><code>prim(PgxGraph, EdgeProperty, String)</code></a></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="primAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>primAsync</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Boolean&gt;&gt;&nbsp;primAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>prim reveals tree structures with shortest paths in a graph
</p>
      <h2>Definition</h2>
      <p>This implementation of Prim's algorithm works on undirected graphs that are connected and have no multi-edges (i.e. more than one edge connecting the same pair of vertices). The algorithm computes the minimum spanning tree (MST) of the graph using the weights associated to each edge. A minimum spanning tree is a subset of the edges that connects all the vertices in the graph such that it minimizes the total weight assiciated to the edges.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * E + V) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The trees found with Prim's algorithm can be used to simplify the desgin of networks when just looking to connect all the elements on the network, like in computer or transportation networks. It can also be used to generate mazes using the structure of a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>edge property holding the edges belonging to the minimum spanning tree of the graph (i.e. all the edges with in_mst=true).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;EdgeProperty&lt;Boolean&gt;&gt; promise = analyst.primAsync(graph, cost);
 promise.thenCompose(prim -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + prim.getName() + " MATCH (x) ORDER BY x." + prim.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="primAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>primAsync</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Boolean&gt;&gt;&nbsp;primAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                            <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Boolean&gt;&nbsp;mst)</pre>
<div class="block"><p>prim reveals tree structures with shortest paths in a graph
</p>
      <h2>Definition</h2>
      <p>This implementation of Prim's algorithm works on undirected graphs that are connected and have no multi-edges (i.e. more than one edge connecting the same pair of vertices). The algorithm computes the minimum spanning tree (MST) of the graph using the weights associated to each edge. A minimum spanning tree is a subset of the edges that connects all the vertices in the graph such that it minimizes the total weight assiciated to the edges.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * E + V) with V = number of vertices, E = number of edges</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The trees found with Prim's algorithm can be used to simplify the desgin of networks when just looking to connect all the elements on the network, like in computer or transportation networks. It can also be used to generate mazes using the structure of a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>mst</code> - (out argument) edge property holding the edges belonging to the minimum spanning tree of the graph (i.e. all the edges with in_mst=true).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>edge property holding the edges belonging to the minimum spanning tree of the graph (i.e. all the edges with in_mst=true).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 EdgeProperty&lt;Boolean&gt; mst = graph.createEdgeProperty(PropertyType.BOOLEAN);
 PgxFuture&lt;EdgeProperty&lt;Boolean&gt;&gt; promise = analyst.primAsync(graph, cost, mst);
 promise.thenCompose(prim -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + prim.getName() + " MATCH (x) ORDER BY x." + prim.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="radius-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>radius</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;radius(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                                                 throws java.util.concurrent.ExecutionException,
                                                                                        java.lang.InterruptedException</pre>
<div class="block"><p>Diameter/radius gives an overview of the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortest paths to any other vertex in the graph. This algorithm will compute the eccentricity of all the vertices and will also return the diameter or radius value depending on the request. The algorithm will return an INF eccentricity and diameter/radius, for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortest paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>diameterOn: true</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the radius of the graph and a node property with eccentricity value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Pair&lt;Scalar&lt;Integer&gt;, VertexProperty&lt;Integer, Integer&gt;&gt; diameter = analyst.radius(graph);
 radius.getFirst().get();
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + radius.getSecond().getName() + " MATCH (x) ORDER BY x." + radius.getSecond().getName() +
   " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="radius-oracle.pgx.api.PgxGraph-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>radius</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;radius(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                        <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;&nbsp;radius,
                                                                                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;eccentricity)
                                                                                 throws java.util.concurrent.ExecutionException,
                                                                                        java.lang.InterruptedException</pre>
<div class="block"><p>Diameter/radius gives an overview of the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortest paths to any other vertex in the graph. This algorithm will compute the eccentricity of all the vertices and will also return the diameter or radius value depending on the request. The algorithm will return an INF eccentricity and diameter/radius, for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortest paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>diameterOn: true</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>radius</code> - Scalar (integer) for holding the value of the radius of the graph.</dd>
<dd><code>eccentricity</code> - (out argument) vertex property holding the eccentricity value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the radius of the graph and a node property with eccentricity value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Scalar&lt;Integer&gt; scalar = graph.createScalar(PropertyType.INTEGER);
 VertexProperty&lt;Integer, Integer&gt; prop = graph.CreateVertexProperty(PropertyType.INTEGER);
 Pair&lt;Scalar&lt;Integer&gt;, VertexProperty&lt;Integer, Integer&gt;&gt; diameter = analyst.radius(graph, scalar, prop);
 radius.getFirst().get();
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + radius.getSecond().getName() + " MATCH (x) ORDER BY x." + radius.getSecond().getName() +
   " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="radiusAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>radiusAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&gt;&nbsp;radiusAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Diameter/radius gives an overview of the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortest paths to any other vertex in the graph. This algorithm will compute the eccentricity of all the vertices and will also return the diameter or radius value depending on the request. The algorithm will return an INF eccentricity and diameter/radius, for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortest paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>diameterOn: true</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the radius of the graph and a node property with eccentricity value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;Pair&lt;Scalar&lt;Integer&gt;, VertexProperty&lt;Integer, Integer&gt;&gt;&gt; promise = analyst.radiusAsync(graph);
 promise.thenCompose(radius -&gt; {
   radius.getFirst().get();
   graph.queryPgqlAsync(
     "SELECT x, x." + radius.getSecond().getName() + " MATCH (x) ORDER BY x." + radius.getSecond().getName() +
     " DESC"))
     .thenAccept(PgqlResultSet::print);
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="radiusAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.Scalar-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>radiusAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;,<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&gt;&nbsp;radiusAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                                        <a href="../../../oracle/pgx/api/Scalar.html" title="class in oracle.pgx.api">Scalar</a>&lt;java.lang.Integer&gt;&nbsp;radius,
                                                                                                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;eccentricity)</pre>
<div class="block"><p>Diameter/radius gives an overview of the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The diameter of a graph is the maximal value of eccentricity of all the vertices in the graph, while the radius is the minimum graph eccentricity. The eccentricity of a vertex is the maximum distance via shortest paths to any other vertex in the graph. This algorithm will compute the eccentricity of all the vertices and will also return the diameter or radius value depending on the request. The algorithm will return an INF eccentricity and diameter/radius, for graphs with more than one strongly connected component.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortest paths. It still is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>diameterOn: true</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>radius</code> - Scalar (integer) for holding the value of the radius of the graph.</dd>
<dd><code>eccentricity</code> - (out argument) vertex property holding the eccentricity value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the radius of the graph and a node property with eccentricity value for each node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Scalar&lt;Integer&gt; scalar = graph.createScalar(PropertyType.INTEGER);
 VertexProperty&lt;Integer, Integer&gt; prop = graph.createVertexProperty(PropertyType.INTEGER);
 PgxFuture&lt;Pair&lt;Scalar&lt;Integer&gt;, VertexProperty&lt;Integer, Integer&gt;&gt;&gt; promise = analyst.radiusAsync(
   graph, scalar, prop);
 promise.thenCompose(radius -&gt; {
   radius.getFirst().get();
   graph.queryPgqlAsync(
     "SELECT x, x." + radius.getSecond().getName() + " MATCH (x) ORDER BY x." + radius.getSecond().getName() +
     " DESC"))
     .thenAccept(PgqlResultSet::print);
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="randomWalkWithRestart-oracle.pgx.api.PgxGraph-java.lang.Object-int-java.math.BigDecimal-oracle.pgx.api.PgxMap-">
<!--   -->
</a><a name="randomWalkWithRestart-oracle.pgx.api.PgxGraph-ID-int-java.math.BigDecimal-oracle.pgx.api.PgxMap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomWalkWithRestart</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&nbsp;randomWalkWithRestart(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                          ID&nbsp;source,
                                                                          int&nbsp;length,
                                                                          java.math.BigDecimal&nbsp;resetProb,
                                                                          <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&nbsp;visitCount)
                                                                   throws java.util.concurrent.ExecutionException,
                                                                          java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#randomWalkWithRestart-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-double-oracle.pgx.api.PgxMap-"><code>randomWalkWithRestart(PgxGraph, PgxVertex, int, double,
 PgxMap)</code></a> taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="randomWalkWithRestart-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-double-oracle.pgx.api.PgxMap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomWalkWithRestart</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&nbsp;randomWalkWithRestart(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;source,
                                                                          int&nbsp;length,
                                                                          double&nbsp;resetProb,
                                                                          <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&nbsp;visitCount)
                                                                   throws java.util.concurrent.ExecutionException,
                                                                          java.lang.InterruptedException</pre>
<div class="block"><p>random walk with restart does the what its name says, it can find approximate stationary distributions
</p>
      <h2>Definition</h2>
      <p>This algorithm performs a random walk over the graph. The walk will start at the given source vertex and will randomly visit neighboring vertices in the graph, with a probability equal to the value of reset_probability of going back to the starting point. The random walk will also go back to the starting point every time it reaches a vertex with no outgoing edges. The algorithm will stop once it reaches the specified walk lenght.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(L) with L = length of the random walk</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The inforamtion gathered from a random walk can be used to approximate stationary distributions when the number of visits is normalized</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>source</code> - (in argument)
    starting point of the random walk.</dd>
<dd><code>length</code> - (in argument)
    length (number of steps) of the random walk.</dd>
<dd><code>resetProb</code> - (in argument)
    probability value for resetting the random walk.</dd>
<dd><code>visitCount</code> - (out argument)
    map holding the number of visits during the random walk for each vertex in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>map holding the number of visits during the random walk for each vertex in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxMap&lt;PgxVertex, Integer&gt; visitCount = graph.createMap(PropertyType.VERTEX, PropertyType.INTEGER);
 PgxMap&lt;PgxVertex, Integer&gt; count = analyst.randomWalkWithRestart(graph, 0, 100, 0,6, visit_count);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://www.cs.yale.edu/publications/techreports/tr1029.pdf">Random Walks on Graphs: A Survey</a></dd>
</dl>
</li>
</ul>
<a name="randomWalkWithRestartAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-double-oracle.pgx.api.PgxMap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomWalkWithRestartAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&gt;&nbsp;randomWalkWithRestartAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;source,
                                                                                          int&nbsp;length,
                                                                                          double&nbsp;resetProb,
                                                                                          <a href="../../../oracle/pgx/api/PgxMap.html" title="class in oracle.pgx.api">PgxMap</a>&lt;<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;,java.lang.Integer&gt;&nbsp;visitCount)</pre>
<div class="block"><p>random walk with restart does the what its name says, it can find approximate stationary distributions
</p>
      <h2>Definition</h2>
      <p>This algorithm performs a random walk over the graph. The walk will start at the given source vertex and will randomly visit neighboring vertices in the graph, with a probability equal to the value of reset_probability of going back to the starting point. The random walk will also go back to the starting point every time it reaches a vertex with no outgoing edges. The algorithm will stop once it reaches the specified walk lenght.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. Since the algorithm visits the vertices in a random order on each iteration it is non-deterministic.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(L) with L = length of the random walk</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The inforamtion gathered from a random walk can be used to approximate stationary distributions when the number of visits is normalized</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>source</code> - (in argument)
    starting point of the random walk.</dd>
<dd><code>length</code> - (in argument)
    length (number of steps) of the random walk.</dd>
<dd><code>resetProb</code> - (in argument)
    probability value for resetting the random walk.</dd>
<dd><code>visitCount</code> - (out argument)
    map holding the number of visits during the random walk for each vertex in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>map holding the number of visits during the random walk for each vertex in the graph.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxMap&lt;PgxVertex, Integer&gt; visit_count;
 PgxFuture&lt;PgxMap&lt;PgxVertex, Integer&gt;&gt; promise = analyst.randomWalkWithRestart(graph, 0, 100, 0,6, visit_count);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://www.cs.yale.edu/publications/techreports/tr1029.pdf">Random Walks on Graphs: A Survey</a></dd>
</dl>
</li>
</ul>
<a name="reachability-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reachability</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;java.lang.Integer&nbsp;reachability(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;source,
                                           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dest,
                                           int&nbsp;maxHops,
                                           boolean&nbsp;ignoreEdgeDirection)
                                    throws java.util.concurrent.ExecutionException,
                                           java.lang.InterruptedException</pre>
<div class="block"><p>Reachability is a fast way to check if two vertices are reachable from each other.
</p>
      <h2>Definition</h2>
      <p>This algorithm tries to find if the destination vertex is reachable given the source vertex and the maximum hop distance set by the user. The search can be performed in a directed or undirected way. These options may lead to different hop distances, since an undirected search has less restrictions on the possible paths connecting vertices than the directed option. Hence hop distances from an undirected search can be smaller than the ones from the directed cases.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(1)</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Check connectivity between vertices in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>source</code> - source vertex for the search.</dd>
<dd><code>dest</code> - destination vertex for the search.</dd>
<dd><code>maxHops</code> - maximum hop distance between the source and destination vertices.</dd>
<dd><code>ignoreEdgeDirection</code> - boolean flag for ignoring the direction of the edges during the search.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the number of hops between the vertices. It will return -1 if the vertices are not connected or are not reachable given the condition of the maximum hop distance allowed.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 integer result = analyst.reachability(graph, src, dst, 2, false);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="reachabilityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reachabilityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;java.lang.Integer&gt;&nbsp;reachabilityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;source,
                                                           <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dest,
                                                           int&nbsp;maxHops,
                                                           boolean&nbsp;ignoreEdgeDirection)</pre>
<div class="block"><p>Reachability is a fast way to check if two vertices are reachable from each other.
</p>
      <h2>Definition</h2>
      <p>This algorithm tries to find if the destination vertex is reachable given the source vertex and the maximum hop distance set by the user. The search can be performed in a directed or undirected way. These options may lead to different hop distances, since an undirected search has less restrictions on the possible paths connecting vertices than the directed option. Hence hop distances from an undirected search can be smaller than the ones from the directed cases.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(1)</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>Check connectivity between vertices in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>source</code> - source vertex for the search.</dd>
<dd><code>dest</code> - destination vertex for the search.</dd>
<dd><code>maxHops</code> - maximum hop distance between the source and destination vertices.</dd>
<dd><code>ignoreEdgeDirection</code> - boolean flag for ignoring the direction of the edges during the search.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the number of hops between the vertices. It will return -1 if the vertices are not connected or are not reachable given the condition of the maximum hop distance allowed.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 PgxFuture&lt;Integer&gt; promise = analyst.reachabilityAsync(graph, src, dst, 2, false);
 promise.thenAccept(result -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="salsa-oracle.pgx.api.BipartiteGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>salsa</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsa(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph)
                                               throws java.util.concurrent.ExecutionException,
                                                      java.lang.InterruptedException</pre>
<div class="block"><p>SALSA computes ranking scores. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific matter, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. SALSA is an algorithm that computes authorities and hubs ranking scores for the vertices using the network created by the edges of the [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph and assigning weights to the contributions of their 2nd-degree neighbors. This way of computing the scores creates the independence between the authority and hub scores, which are assigned to the vertices depending on the side of the graph they belong (left:hub / right:aut).
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; salsa = analyst.salsa(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="salsa-oracle.pgx.api.BipartiteGraph-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>salsa</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsa(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                      double&nbsp;maxDiff,
                                                      int&nbsp;maxIter)
                                               throws java.util.concurrent.ExecutionException,
                                                      java.lang.InterruptedException</pre>
<div class="block"><p>SALSA computes ranking scores. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific matter, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. SALSA is an algorithm that computes authorities and hubs ranking scores for the vertices using the network created by the edges of the [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph and assigning weights to the contributions of their 2nd-degree neighbors. This way of computing the scores creates the independence between the authority and hub scores, which are assigned to the vertices depending on the side of the graph they belong (left:hub / right:aut).
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; salsa = analyst.salsa(graph, 0.001, 100);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="salsa-oracle.pgx.api.BipartiteGraph-double-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>salsa</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsa(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                      double&nbsp;maxDiff,
                                                      int&nbsp;maxIter,
                                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)
                                               throws java.util.concurrent.ExecutionException,
                                                      java.lang.InterruptedException</pre>
<div class="block"><p>SALSA computes ranking scores. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific matter, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. SALSA is an algorithm that computes authorities and hubs ranking scores for the vertices using the network created by the edges of the [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph and assigning weights to the contributions of their 2nd-degree neighbors. This way of computing the scores creates the independence between the authority and hub scores, which are assigned to the vertices depending on the side of the graph they belong (left:hub / right:aut).
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dd><code>salsaRank</code> - (out argument) vertex property holding the normalized authority/hub ranking score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; salsa = analyst.salsa(graph, 0.001, 100, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="salsa-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>salsa</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsa(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)
                                               throws java.util.concurrent.ExecutionException,
                                                      java.lang.InterruptedException</pre>
<div class="block"><p>SALSA computes ranking scores. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific matter, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. SALSA is an algorithm that computes authorities and hubs ranking scores for the vertices using the network created by the edges of the [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph and assigning weights to the contributions of their 2nd-degree neighbors. This way of computing the scores creates the independence between the authority and hub scores, which are assigned to the vertices depending on the side of the graph they belong (left:hub / right:aut).
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>salsaRank</code> - (out argument) vertex property holding the normalized authority/hub ranking score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; salsa = analyst.salsa(graph, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="salsaAsync-oracle.pgx.api.BipartiteGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>salsaAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;salsaAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph)</pre>
<div class="block"><p>SALSA computes ranking scores. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific matter, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. SALSA is an algorithm that computes authorities and hubs ranking scores for the vertices using the network created by the edges of the [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph and assigning weights to the contributions of their 2nd-degree neighbors. This way of computing the scores creates the independence between the authority and hub scores, which are assigned to the vertices depending on the side of the graph they belong (left:hub / right:aut).
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.salsaAsync(graph);
 promise.thenCompose(salsa -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="salsaAsync-oracle.pgx.api.BipartiteGraph-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>salsaAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;salsaAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                      double&nbsp;maxDiff,
                                                                      int&nbsp;maxIter)</pre>
<div class="block"><p>SALSA computes ranking scores. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific matter, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. SALSA is an algorithm that computes authorities and hubs ranking scores for the vertices using the network created by the edges of the [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph and assigning weights to the contributions of their 2nd-degree neighbors. This way of computing the scores creates the independence between the authority and hub scores, which are assigned to the vertices depending on the side of the graph they belong (left:hub / right:aut).
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.salsaAsync(graph, 0.001, 100);
 promise.thenCompose(salsa -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="salsaAsync-oracle.pgx.api.BipartiteGraph-double-int-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>salsaAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;salsaAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                      double&nbsp;maxDiff,
                                                                      int&nbsp;maxIter,
                                                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</pre>
<div class="block"><p>SALSA computes ranking scores. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific matter, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. SALSA is an algorithm that computes authorities and hubs ranking scores for the vertices using the network created by the edges of the [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph and assigning weights to the contributions of their 2nd-degree neighbors. This way of computing the scores creates the independence between the authority and hub scores, which are assigned to the vertices depending on the side of the graph they belong (left:hub / right:aut).
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>maxDiff</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed.</dd>
<dd><code>salsaRank</code> - (out argument) vertex property holding the normalized authority/hub ranking score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(Property.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.salsaAsync(graph, 0.001, 100, rank);
 promise.thenCompose(salsa -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="salsaAsync-oracle.pgx.api.BipartiteGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>salsaAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;salsaAsync(<a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api">BipartiteGraph</a>&nbsp;graph,
                                                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;salsaRank)</pre>
<div class="block"><p>SALSA computes ranking scores. It assesses the quality of information and references in linked structures
</p>
      <h2>Definition</h2>
      <p>The idea of hubs and authorites comes from the web pages: a hub is regarded as a page that is not authoritative in a specific matter, but it has instead links to authority pages, which are regarded as meaningful sources for a particular topic by many hubs. Thus a good hub will point to many authorities, while a good authority will be pointed by many hubs. SALSA is an algorithm that computes authorities and hubs ranking scores for the vertices using the network created by the edges of the [bipartite](prog-guides/mutation-subgraph/subgraph.html#create-a-bipartite-subgraph-based-on-a-vertex-list) graph and assigning weights to the contributions of their 2nd-degree neighbors. This way of computing the scores creates the independence between the authority and hub scores, which are assigned to the vertices depending on the side of the graph they belong (left:hub / right:aut).
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>SALSA was designed to rate web pages given the links existing between them. It uses the authority of a page (vertex) to asses the quality of the information it has, while the hub score do so for the quality of the links to other pages (vertices).</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Bipartite graph.</dd>
<dd><code>salsaRank</code> - (out argument) vertex property holding the normalized authority/hub ranking score for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the normalized authority/hub ranking score for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(Property.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.salsaAsync(graph, rank);
 promise.thenCompose(salsa -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + salsa.getName() + " MATCH (x) ORDER BY x." + salsa.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="sccKosaraju-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sccKosaraju</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;sccKosaraju(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                               throws java.util.concurrent.ExecutionException,
                                      java.lang.InterruptedException</pre>
<div class="block"><p>Kosaraju finds strongly connected components in a graph
</p>
      <h2>Definition</h2>
      <p>Kosaraju's algorithm works on directed graphs for finding strongly connected components (SCC). A SCC is a maximal subset of vertices of the graph with the particular characteristic that every vertex in the SCC can be reachable from any other other vertex in the SCC.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS and BFS features.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It can be used for clustering and, in social networks, to spot out groups of people (commmunities), since people in groups tend to have a high density of links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the components found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; scc = analyst.sccKosaraju(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + scc.getPropertyName() + " MATCH (x) ORDER BY x." + scc.getPropertyName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="sccKosaraju-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sccKosaraju</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;sccKosaraju(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)
                               throws java.util.concurrent.ExecutionException,
                                      java.lang.InterruptedException</pre>
<div class="block"><p>Kosaraju finds strongly connected components in a graph
</p>
      <h2>Definition</h2>
      <p>Kosaraju's algorithm works on directed graphs for finding strongly connected components (SCC). A SCC is a maximal subset of vertices of the graph with the particular characteristic that every vertex in the SCC can be reachable from any other other vertex in the SCC.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS and BFS features.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It can be used for clustering and, in social networks, to spot out groups of people (commmunities), since people in groups tend to have a high density of links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partitionDistribution</code> - vertex property holding the label of the SCC assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the components found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Long&gt; pd = graph.createVertexProperty(PropertyType.LONG);
 Partition&lt;Integer&gt; scc = analyst.sccKosaraju(graph, pd);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + scc.getPropertyName() + " MATCH (x) ORDER BY x." + scc.getPropertyName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="sccKosarajuAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sccKosarajuAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;sccKosarajuAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Kosaraju finds strongly connected components in a graph
</p>
      <h2>Definition</h2>
      <p>Kosaraju's algorithm works on directed graphs for finding strongly connected components (SCC). A SCC is a maximal subset of vertices of the graph with the particular characteristic that every vertex in the SCC can be reachable from any other other vertex in the SCC.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS and BFS features.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It can be used for clustering and, in social networks, to spot out groups of people (commmunities), since people in groups tend to have a high density of links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the components found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.sccKosarajuAsync(graph);
 promise.thenCompose(scc -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + scc.getPropertyName() + " MATCH (x) ORDER BY x." + scc.getPropertyName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="sccKosarajuAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sccKosarajuAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;sccKosarajuAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                      <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</pre>
<div class="block"><p>Kosaraju finds strongly connected components in a graph
</p>
      <h2>Definition</h2>
      <p>Kosaraju's algorithm works on directed graphs for finding strongly connected components (SCC). A SCC is a maximal subset of vertices of the graph with the particular characteristic that every vertex in the SCC can be reachable from any other other vertex in the SCC.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS and BFS features.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It can be used for clustering and, in social networks, to spot out groups of people (commmunities), since people in groups tend to have a high density of links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partitionDistribution</code> - vertex property holding the label of the SCC assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the components found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Long&gt; pd = graph.createVertexProperty(PropertyType.LONG);
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.sccKosarajuAsync(graph, pd);
 promise.thenCompose(scc -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + scc.getPropertyName() + " MATCH (x) ORDER BY x." + scc.getPropertyName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="sccTarjan-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sccTarjan</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;sccTarjan(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                             throws java.util.concurrent.ExecutionException,
                                    java.lang.InterruptedException</pre>
<div class="block"><p>Tarjan finds strongly connected components in a graph
</p>
      <h2>Definition</h2>
      <p>Tarjan's algorithm works on directed graphs for finding strongly connected components (SCC). A SCC is a maximal subset of vertices of the graph with the particular characteristic that every vertex in the SCC can be reachable from any other other vertex in the SCC.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It can be used for clustering and, in social networks, to spot out groups of people (commmunities), since people in groups tend to have a high density of links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the components found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; scc = analyst.sccTarjan(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + scc.getPropertyName() + " MATCH (x) ORDER BY x." + scc.getPropertyName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="sccTarjan-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sccTarjan</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;sccTarjan(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)
                             throws java.util.concurrent.ExecutionException,
                                    java.lang.InterruptedException</pre>
<div class="block"><p>Tarjan finds strongly connected components in a graph
</p>
      <h2>Definition</h2>
      <p>Tarjan's algorithm works on directed graphs for finding strongly connected components (SCC). A SCC is a maximal subset of vertices of the graph with the particular characteristic that every vertex in the SCC can be reachable from any other other vertex in the SCC.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It can be used for clustering and, in social networks, to spot out groups of people (commmunities), since people in groups tend to have a high density of links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partitionDistribution</code> - vertex property holding the label of the SCC assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the components found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Long&gt; pd = graph.createVertexProperty(PropertyType.LONG);
 Partition&lt;Integer&gt; scc = analyst.sccTarjan(graph, pd);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + scc.getPropertyName() + " MATCH (x) ORDER BY x." + scc.getPropertyName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="sccTarjanAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sccTarjanAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;sccTarjanAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Tarjan finds strongly connected components in a graph
</p>
      <h2>Definition</h2>
      <p>Tarjan's algorithm works on directed graphs for finding strongly connected components (SCC). A SCC is a maximal subset of vertices of the graph with the particular characteristic that every vertex in the SCC can be reachable from any other other vertex in the SCC.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It can be used for clustering and, in social networks, to spot out groups of people (commmunities), since people in groups tend to have a high density of links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the components found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.sccTarjanAsync(graph);
 promise.thenCompose(scc -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + scc.getPropertyName() + " MATCH (x) ORDER BY x." + scc.getPropertyName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="sccTarjanAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sccTarjanAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;sccTarjanAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitonDistribution)</pre>
<div class="block"><p>Tarjan finds strongly connected components in a graph
</p>
      <h2>Definition</h2>
      <p>Tarjan's algorithm works on directed graphs for finding strongly connected components (SCC). A SCC is a maximal subset of vertices of the graph with the particular characteristic that every vertex in the SCC can be reachable from any other other vertex in the SCC.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in DFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It can be used for clustering and, in social networks, to spot out groups of people (commmunities), since people in groups tend to have a high density of links between them.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partitonDistribution</code> - vertex property holding the label of the SCC assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the components found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Long&gt; pd = graph.createVertexProperty(PropertyType.LONG);
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.sccTarjanAsync(graph, pd);
 promise.thenCompose(scc -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + scc.getPropertyName() + " MATCH (x) ORDER BY x." + scc.getPropertyName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathBellmanFord-oracle.pgx.api.PgxGraph-java.lang.Object-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a><a name="shortestPathBellmanFord-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathBellmanFord</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathBellmanFord(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                 ID&nbsp;srcId,
                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)
                                          throws java.util.concurrent.ExecutionException,
                                                 java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFord-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-"><code>shortestPathBellmanFord(PgxGraph, PgxVertex, EdgeProperty)</code></a> taking a vertex ID
 instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathBellmanFord-oracle.pgx.api.PgxGraph-java.lang.Object-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a><a name="shortestPathBellmanFord-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathBellmanFord</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathBellmanFord(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                 ID&nbsp;srcId,
                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                          throws java.util.concurrent.ExecutionException,
                                                 java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFord-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-"><code>shortestPathBellmanFord(PgxGraph, PgxVertex, EdgeProperty, VertexProperty,
 VertexProperty, VertexProperty)</code></a> taking a vertex ID
 instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathBellmanFord-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathBellmanFord</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathBellmanFord(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)
                                          throws java.util.concurrent.ExecutionException,
                                                 java.lang.InterruptedException</pre>
<div class="block"><p>Bellman-ford finds multiple shortest paths at the same time
</p>
      <h2>Definition</h2>
      <p>Bellman-Ford algorithm tries to find the shortest path (if there is one) between the given source and destination vertices, while minimizing the distance or cost associated to each edge in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(6 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>root: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex from the graph for the path.</dd>
<dd><code>cost</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 AllPaths&lt;Integer&gt; paths = analyst.shortestPathBellmanFord(graph, src, cost);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathBellmanFord-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathBellmanFord</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathBellmanFord(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                          throws java.util.concurrent.ExecutionException,
                                                 java.lang.InterruptedException</pre>
<div class="block"><p>Bellman-ford finds multiple shortest paths at the same time
</p>
      <h2>Definition</h2>
      <p>Bellman-Ford algorithm tries to find the shortest path (if there is one) between the given source and destination vertices, while minimizing the distance or cost associated to each edge in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(6 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>root: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex from the graph for the path.</dd>
<dd><code>cost</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>distance</code> - (out argument)
    vertex property holding the distance to the source vertex for each vertex in the graph.</dd>
<dd><code>parent</code> - (out argument)
    vertex property holding the parent vertex of the each vertex in the shortest path.</dd>
<dd><code>parentEdge</code> - (out argument)
    vertex property holding the edge ID linking the current vertex in the path with the previous vertex in the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; distance = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 AllPaths&lt;Integer&gt; paths = analyst.shortestPathBellmanFord(graph, src, cost, distance, parent, parentEdge);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathBellmanFordAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathBellmanFordAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;&nbsp;shortestPathBellmanFordAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</pre>
<div class="block"><p>Bellman-ford finds multiple shortest paths at the same time
</p>
      <h2>Definition</h2>
      <p>Bellman-Ford algorithm tries to find the shortest path (if there is one) between the given source and destination vertices, while minimizing the distance or cost associated to each edge in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(6 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>root: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex from the graph for the path.</dd>
<dd><code>cost</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;AllPaths&lt;Integer&gt;&gt; promise = analyst.shortestPathBellmanFordAsync(graph, src, cost);
 promise.thenAccept(paths -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathBellmanFordAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathBellmanFordAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;&nbsp;shortestPathBellmanFordAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</pre>
<div class="block"><p>Bellman-ford finds multiple shortest paths at the same time
</p>
      <h2>Definition</h2>
      <p>Bellman-Ford algorithm tries to find the shortest path (if there is one) between the given source and destination vertices, while minimizing the distance or cost associated to each edge in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(6 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>root: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex from the graph for the path.</dd>
<dd><code>cost</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>distance</code> - (out argument)
    vertex property holding the distance to the source vertex for each vertex in the graph.</dd>
<dd><code>parent</code> - (out argument)
    vertex property holding the parent vertex of the each vertex in the shortest path.</dd>
<dd><code>parentEdge</code> - (out argument)
    vertex property holding the edge ID linking the current vertex in the path with the previous vertex in the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; distance = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 PgxFuture&lt;AllPaths&lt;Integer&gt;&gt; promise = analyst.shortestPathBellmanFordAsync(
   graph, src, cost, distance, parent, parentEdge);
 promise.thenAccept(paths -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathBellmanFordReverse-oracle.pgx.api.PgxGraph-java.lang.Object-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a><a name="shortestPathBellmanFordReverse-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathBellmanFordReverse</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathBellmanFordReverse(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                        ID&nbsp;srcId,
                                                        <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)
                                                 throws java.util.concurrent.ExecutionException,
                                                        java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFordReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-"><code>shortestPathBellmanFordReverse(PgxGraph, PgxVertex, EdgeProperty)</code></a> taking a
 vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathBellmanFordReverse-oracle.pgx.api.PgxGraph-java.lang.Object-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a><a name="shortestPathBellmanFordReverse-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathBellmanFordReverse</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathBellmanFordReverse(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                        ID&nbsp;srcId,
                                                        <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                                 throws java.util.concurrent.ExecutionException,
                                                        java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathBellmanFordReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-"><code>shortestPathBellmanFordReverse(PgxGraph, PgxVertex, EdgeProperty,
 VertexProperty, VertexProperty, VertexProperty)</code></a> taking a
 vertex ID instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathBellmanFordReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathBellmanFordReverse</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathBellmanFordReverse(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                        <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                        <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)
                                                 throws java.util.concurrent.ExecutionException,
                                                        java.lang.InterruptedException</pre>
<div class="block"><p>Reversed bellman-ford finds multiple shortest paths at the same time
</p>
      <h2>Definition</h2>
      <p>This variant of the Bellman-Ford algorithm tries to find the shortest path (if there is one) between the given source and destination vertices in a reversed fashion using the incoming edges instead of the outgoing, while minimizing the distance or cost associated to each edge in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(6 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>root: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>cost</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 AllPaths&lt;Integer&gt; paths = analyst.shortestPathBellmanFordReverse(graph, src, cost);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathBellmanFordReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathBellmanFordReverse</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathBellmanFordReverse(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                        <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                        <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                                 throws java.util.concurrent.ExecutionException,
                                                        java.lang.InterruptedException</pre>
<div class="block"><p>Reversed bellman-ford finds multiple shortest paths at the same time
</p>
      <h2>Definition</h2>
      <p>This variant of the Bellman-Ford algorithm tries to find the shortest path (if there is one) between the given source and destination vertices in a reversed fashion using the incoming edges instead of the outgoing, while minimizing the distance or cost associated to each edge in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(6 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>root: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>cost</code> - </dd>
<dd><code>distance</code> - (out argument) </dd>
<dd><code>parent</code> - (out argument) </dd>
<dd><code>parentEdge</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; distance = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 AllPaths&lt;Integer&gt; paths = analyst.shortestPathBellmanFordReverse(graph, src, cost, distance, parent, parentEdge);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathBellmanFordReverseAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathBellmanFordReverseAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;&nbsp;shortestPathBellmanFordReverseAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                        <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                        <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</pre>
<div class="block"><p>Reversed bellman-ford finds multiple shortest paths at the same time
</p>
      <h2>Definition</h2>
      <p>This variant of the Bellman-Ford algorithm tries to find the shortest path (if there is one) between the given source and destination vertices in a reversed fashion using the incoming edges instead of the outgoing, while minimizing the distance or cost associated to each edge in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(6 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>root: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>cost</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;AllPaths&lt;Integer&gt;&gt; promise = analyst.shortestPathBellmanFordReverseAsync(graph, src, cost);
 promise.thenAccept(paths -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathBellmanFordReverseAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathBellmanFordReverseAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;&nbsp;shortestPathBellmanFordReverseAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                        <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                        <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                                                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                                        <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</pre>
<div class="block"><p>Reversed bellman-ford finds multiple shortest paths at the same time
</p>
      <h2>Definition</h2>
      <p>This variant of the Bellman-Ford algorithm tries to find the shortest path (if there is one) between the given source and destination vertices in a reversed fashion using the incoming edges instead of the outgoing, while minimizing the distance or cost associated to each edge in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(6 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>root: 0</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>cost</code> - </dd>
<dd><code>distance</code> - (out argument) </dd>
<dd><code>parent</code> - (out argument) </dd>
<dd><code>parentEdge</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; distance = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 PgxFuture&lt;AllPaths&lt;Integer&gt;&gt; promise = analyst.shortestPathBellmanFordReverseAsync(
   graph, src, cost, distance, parent, parentEdge);
 promise.thenAccept(paths -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathDijkstra-oracle.pgx.api.PgxGraph-java.lang.Object-java.lang.Object-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a><a name="shortestPathDijkstra-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathDijkstra</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathDijkstra(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                             ID&nbsp;srcId,
                                             ID&nbsp;dstId,
                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)
                                      throws java.util.concurrent.ExecutionException,
                                             java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-"><code>shortestPathDijkstra(PgxGraph, PgxVertex, PgxVertex, EdgeProperty)</code></a> taking
 vertex IDs instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathDijkstra-oracle.pgx.api.PgxGraph-java.lang.Object-java.lang.Object-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a><a name="shortestPathDijkstra-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathDijkstra</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathDijkstra(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                             ID&nbsp;srcId,
                                             ID&nbsp;dstId,
                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                      throws java.util.concurrent.ExecutionException,
                                             java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-"><code>shortestPathDijkstra(PgxGraph, PgxVertex, PgxVertex, EdgeProperty)</code></a> taking
 vertex IDs instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathDijkstra</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathDijkstra(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)
                                      throws java.util.concurrent.ExecutionException,
                                             java.lang.InterruptedException</pre>
<div class="block"><p>Dijkstra is a fast algorithm for finding a shortest path in a graph
</p>
      <h2>Definition</h2>
      <p>Dijkstra's algorithm tries to find the shortest path (if there is one) between the given source and destination vertices, while minimizing the distance or cost associated to each edge in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex from the graph for the path.</dd>
<dd><code>dst</code> - the destination vertex from the graph for the path.</dd>
<dd><code>cost</code> - edge property holding the (positive) weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxPath&lt;Integer&gt; path = analyst.shortestPathDijkstra(graph, src, dst, cost);
 path.getPathLengthWithCost();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathDijkstra</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathDijkstra(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                      throws java.util.concurrent.ExecutionException,
                                             java.lang.InterruptedException</pre>
<div class="block"><p>Dijkstra is a fast algorithm for finding a shortest path in a graph
</p>
      <h2>Definition</h2>
      <p>Dijkstra's algorithm tries to find the shortest path (if there is one) between the given source and destination vertices, while minimizing the distance or cost associated to each edge in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex from the graph for the path.</dd>
<dd><code>dst</code> - the destination vertex from the graph for the path.</dd>
<dd><code>cost</code> - edge property holding the (positive) weight of each edge in the graph.</dd>
<dd><code>parent</code> - (out argument)
    vertex property holding the parent vertex of the each vertex in the shortest path.</dd>
<dd><code>parentEdge</code> - (out argument)
    vertex property holding the edge ID linking the current vertex in the path with the previous vertex in the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 PgxPath&lt;Integer&gt; path = analyst.shortestPathDijkstra(graph, src, dst, cost, parent, parentEdge);
 path.getPathLengthWithCost();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathDijkstraAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathDijkstraAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;&nbsp;shortestPathDijkstraAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</pre>
<div class="block"><p>Dijkstra is a fast algorithm for finding a shortest path in a graph
</p>
      <h2>Definition</h2>
      <p>Dijkstra's algorithm tries to find the shortest path (if there is one) between the given source and destination vertices, while minimizing the distance or cost associated to each edge in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex from the graph for the path.</dd>
<dd><code>dst</code> - the destination vertex from the graph for the path.</dd>
<dd><code>cost</code> - edge property holding the (positive) weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;PgxPath&lt;Integer&gt;&gt; promise = analyst.shortestPathDijkstraAsync(graph, src, dst, cost);
 promise.thenAccept(path -&gt; {
   path.getPathLengthWithCost();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathDijkstraAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathDijkstraAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;&nbsp;shortestPathDijkstraAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                             <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</pre>
<div class="block"><p>Dijkstra is a fast algorithm for finding a shortest path in a graph
</p>
      <h2>Definition</h2>
      <p>Dijkstra's algorithm tries to find the shortest path (if there is one) between the given source and destination vertices, while minimizing the distance or cost associated to each edge in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>src</code> - the source vertex from the graph for the path.</dd>
<dd><code>dst</code> - the destination vertex from the graph for the path.</dd>
<dd><code>cost</code> - edge property holding the (positive) weight of each edge in the graph.</dd>
<dd><code>parent</code> - (out argument)
    vertex property holding the parent vertex of the each vertex in the shortest path.</dd>
<dd><code>parentEdge</code> - (out argument)
    vertex property holding the edge ID linking the current vertex in the path with the previous vertex in the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 PgxFuture&lt;PgxPath&lt;Integer&gt;&gt; promise = analyst.shortestPathDijkstraAsync(graph, src, dst, cost, parent, parentEdge);
 promise.thenAccept(path -&gt; {
   path.getPathLengthWithCost();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathDijkstraBidirectional-oracle.pgx.api.PgxGraph-java.lang.Object-java.lang.Object-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a><a name="shortestPathDijkstraBidirectional-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathDijkstraBidirectional</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathDijkstraBidirectional(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                          ID&nbsp;srcId,
                                                          ID&nbsp;dstId,
                                                          <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)
                                                   throws java.util.concurrent.ExecutionException,
                                                          java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-"><code>shortestPathDijkstraBidirectional(PgxGraph, PgxVertex, PgxVertex, EdgeProperty)</code></a>
 taking vertex IDs instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathDijkstraBidirectional-oracle.pgx.api.PgxGraph-java.lang.Object-java.lang.Object-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a><a name="shortestPathDijkstraBidirectional-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathDijkstraBidirectional</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathDijkstraBidirectional(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                          ID&nbsp;srcId,
                                                          ID&nbsp;dstId,
                                                          <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                                   throws java.util.concurrent.ExecutionException,
                                                          java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-"><code>shortestPathDijkstraBidirectional(PgxGraph, PgxVertex, PgxVertex, EdgeProperty)</code></a>
 taking vertex IDs instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathDijkstraBidirectional</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathDijkstraBidirectional(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                          <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)
                                                   throws java.util.concurrent.ExecutionException,
                                                          java.lang.InterruptedException</pre>
<div class="block"><p>Bidirectional dijkstra is a fast algorithm for finding a shortest path in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the Dijkstra's algorithm searches for shortest path in two ways, it does a forward search from the source vertex and a backwards one from the destination vertex. If the path between the vertices exists, both searches will meet each other at an intermediate point.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(10 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>dst</code> - </dd>
<dd><code>cost</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxPath&lt;Integer&gt; path = analyst.shortestPathDijkstraBidirectional(graph, src, dst, cost);
 path.getPathLengthWithCost();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathDijkstraBidirectional</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathDijkstraBidirectional(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                          <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                                   throws java.util.concurrent.ExecutionException,
                                                          java.lang.InterruptedException</pre>
<div class="block"><p>Bidirectional dijkstra is a fast algorithm for finding a shortest path in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the Dijkstra's algorithm searches for shortest path in two ways, it does a forward search from the source vertex and a backwards one from the destination vertex. If the path between the vertices exists, both searches will meet each other at an intermediate point.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(10 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>dst</code> - </dd>
<dd><code>cost</code> - </dd>
<dd><code>parent</code> - (out argument) </dd>
<dd><code>parentEdge</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 PgxPath&lt;Integer&gt; path = analyst.shortestPathDijkstraBidirectional(graph, src, dst, cost, parent, parentEdge);
 path.getPathLengthWithCost();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathDijkstraBidirectionalAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathDijkstraBidirectionalAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;&nbsp;shortestPathDijkstraBidirectionalAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                          <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost)</pre>
<div class="block"><p>Bidirectional dijkstra is a fast algorithm for finding a shortest path in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the Dijkstra's algorithm searches for shortest path in two ways, it does a forward search from the source vertex and a backwards one from the destination vertex. If the path between the vertices exists, both searches will meet each other at an intermediate point.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(10 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>dst</code> - </dd>
<dd><code>cost</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;PgxPath&lt;Integer&gt;&gt; promise = analyst.shortestPathDijkstraBidirectionalAsync(graph, src, dst, cost);
 promise.thenAccept(path -&gt; {
   path.getPathLengthWithCost();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathDijkstraBidirectionalAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathDijkstraBidirectionalAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;&nbsp;shortestPathDijkstraBidirectionalAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                          <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                                          java.lang.String&nbsp;parentName,
                                                                          java.lang.String&nbsp;parentEdgeName)</pre>
</li>
</ul>
<a name="shortestPathDijkstraBidirectionalAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathDijkstraBidirectionalAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;&nbsp;shortestPathDijkstraBidirectionalAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                          <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                          <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                                          <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</pre>
<div class="block"><p>Bidirectional dijkstra is a fast algorithm for finding a shortest path in a graph
</p>
      <h2>Definition</h2>
      <p>This variant of the Dijkstra's algorithm searches for shortest path in two ways, it does a forward search from the source vertex and a backwards one from the destination vertex. If the path between the vertices exists, both searches will meet each other at an intermediate point.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(10 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>dst</code> - </dd>
<dd><code>cost</code> - </dd>
<dd><code>parent</code> - (out argument) </dd>
<dd><code>parentEdge</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 PgxFuture&lt;PgxPath&lt;Integer&gt;&gt; promise = analyst.shortestPathDijkstraBidirectionalAsync(
   graph, src, dst, cost, parent, parentEdge);
 promise.thenAccept(path -&gt; {
   path.getPathLengthWithCost();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathFilteredDijkstra-oracle.pgx.api.PgxGraph-java.lang.Object-java.lang.Object-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-">
<!--   -->
</a><a name="shortestPathFilteredDijkstra-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathFilteredDijkstra</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathFilteredDijkstra(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                     ID&nbsp;srcId,
                                                     ID&nbsp;dstId,
                                                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                     <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr)
                                              throws java.util.concurrent.ExecutionException,
                                                     java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-"><code>shortestPathFilteredDijkstra(PgxGraph, PgxVertex, PgxVertex, EdgeProperty, GraphFilter)</code></a> taking vertex IDs
 instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathFilteredDijkstra-oracle.pgx.api.PgxGraph-java.lang.Object-java.lang.Object-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a><a name="shortestPathFilteredDijkstra-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathFilteredDijkstra</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathFilteredDijkstra(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                     ID&nbsp;srcId,
                                                     ID&nbsp;dstId,
                                                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                     <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr,
                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                              throws java.util.concurrent.ExecutionException,
                                                     java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-"><code>shortestPathFilteredDijkstra(PgxGraph, PgxVertex, PgxVertex, EdgeProperty, GraphFilter)</code></a> taking vertex IDs
 instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathFilteredDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathFilteredDijkstra</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathFilteredDijkstra(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                     <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr)
                                              throws java.util.concurrent.ExecutionException,
                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Filtered Dijkstra is a fast algorithm for finding a shortest path while also filtering edges
</p>
      <h2>Definition</h2>
      <p>This variant of the Dijkstra's algorithm tries to find the shortest path while also taking into account a filter expression, which will add restrictions over the potential edges when looking for the shortest path between the source and destination vertices.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>dst</code> - </dd>
<dd><code>cost</code> - </dd>
<dd><code>filterExpr</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 EdgeFilter filter = EdgeFilter.fromExpression("edge.cost &gt; 5");
 PgxPath&lt;Integer&gt; path = analyst.shortestPathFilteredDijkstra(graph, src, dst, cost, filter);
 path.getPathLengthWithCost();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathFilteredDijkstra-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathFilteredDijkstra</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathFilteredDijkstra(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                     <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr,
                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                              throws java.util.concurrent.ExecutionException,
                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Filtered Dijkstra is a fast algorithm for finding a shortest path while also filtering edges
</p>
      <h2>Definition</h2>
      <p>This variant of the Dijkstra's algorithm tries to find the shortest path while also taking into account a filter expression, which will add restrictions over the potential edges when looking for the shortest path between the source and destination vertices.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>dst</code> - </dd>
<dd><code>cost</code> - </dd>
<dd><code>filterExpr</code> - </dd>
<dd><code>parent</code> - (out argument) </dd>
<dd><code>parentEdge</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 EdgeFilter filter = EdgeFilter.fromExpression("edge.cost &gt; 5");
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 PgxPath&lt;Integer&gt; path = analyst.shortestPathFilteredDijkstra(graph, src, dst, cost, filter, parent, parentEdge);
 path.getPathLengthWithCost();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathFilteredDijkstraAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathFilteredDijkstraAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;&nbsp;shortestPathFilteredDijkstraAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                                     <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr)</pre>
<div class="block"><p>Filtered Dijkstra is a fast algorithm for finding a shortest path while also filtering edges
</p>
      <h2>Definition</h2>
      <p>This variant of the Dijkstra's algorithm tries to find the shortest path while also taking into account a filter expression, which will add restrictions over the potential edges when looking for the shortest path between the source and destination vertices.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>dst</code> - </dd>
<dd><code>cost</code> - </dd>
<dd><code>filterExpr</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 EdgeFilter filter = EdgeFilter.fromExpression("edge.cost &gt; 5");
 PgxFuture&lt;PgxPath&lt;Integer&gt;&gt; promise = analyst.shortestPathFilteredDijkstraAsync(graph, src, dst, cost, filter);
 promise.thenAccept(path -&gt; {
   path.getPathLengthWithCost();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathFilteredDijkstraAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathFilteredDijkstraAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;&nbsp;shortestPathFilteredDijkstraAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                     <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                                     <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr,
                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</pre>
<div class="block"><p>Filtered Dijkstra is a fast algorithm for finding a shortest path while also filtering edges
</p>
      <h2>Definition</h2>
      <p>This variant of the Dijkstra's algorithm tries to find the shortest path while also taking into account a filter expression, which will add restrictions over the potential edges when looking for the shortest path between the source and destination vertices.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(4 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>dst</code> - </dd>
<dd><code>cost</code> - </dd>
<dd><code>filterExpr</code> - </dd>
<dd><code>parent</code> - (out argument) </dd>
<dd><code>parentEdge</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 EdgeFilter filter = EdgeFilter.fromExpression("edge.cost &gt; 5");
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 PgxFuture&lt;PgxPath&lt;Integer&gt;&gt; promise = analyst.shortestPathFilteredDijkstraAsync(
   graph, src, dst, cost, filter, parent, parentEdge);
 promise.thenAccept(path -&gt; {
   path.getPathLengthWithCost();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathFilteredDijkstraBidirectional-oracle.pgx.api.PgxGraph-java.lang.Object-java.lang.Object-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-">
<!--   -->
</a><a name="shortestPathFilteredDijkstraBidirectional-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathFilteredDijkstraBidirectional</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathFilteredDijkstraBidirectional(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                  ID&nbsp;srcId,
                                                                  ID&nbsp;dstId,
                                                                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                                  <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-"><code>shortestPathFilteredDijkstraBidirectional(PgxGraph, PgxVertex, PgxVertex, EdgeProperty, GraphFilter)</code></a>
 taking vertex IDs instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathFilteredDijkstraBidirectional-oracle.pgx.api.PgxGraph-java.lang.Object-java.lang.Object-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a><a name="shortestPathFilteredDijkstraBidirectional-oracle.pgx.api.PgxGraph-ID-ID-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathFilteredDijkstraBidirectional</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathFilteredDijkstraBidirectional(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                  ID&nbsp;srcId,
                                                                  ID&nbsp;dstId,
                                                                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                                  <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr,
                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#shortestPathFilteredDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-"><code>shortestPathFilteredDijkstraBidirectional(PgxGraph, PgxVertex, PgxVertex, EdgeProperty, GraphFilter)</code></a>
 taking vertex IDs instead of <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathFilteredDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathFilteredDijkstraBidirectional</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathFilteredDijkstraBidirectional(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                                  <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block"><p>Bidirectional dijkstra is a fast algorithm for finding a shortest path while also filtering edges
</p>
      <h2>Definition</h2>
      <p>This variant of the Dijkstra's algorithm searches for shortest path in two ways, it does a forward search from the source vertex and a backwards one from the destination vertex, while also adding the corresponding restrictions on the edges given by the filter expression. If the path between the vertices exists, both searches will meet each other at an intermediate point.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(10 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>dst</code> - </dd>
<dd><code>cost</code> - </dd>
<dd><code>filterExpr</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 EdgeFilter filter = EdgeFilter.fromExpression("edge.cost &gt; 5");
 PgxPath&lt;Integer&gt; path = analyst.shortestPathFilteredDijkstraBidirectional(graph, src, dst, cost, filter);
 path.getPathLengthWithCost();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathFilteredDijkstraBidirectional-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathFilteredDijkstraBidirectional</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&nbsp;shortestPathFilteredDijkstraBidirectional(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                                  <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr,
                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                                           throws java.util.concurrent.ExecutionException,
                                                                  java.lang.InterruptedException</pre>
<div class="block"><p>Bidirectional dijkstra is a fast algorithm for finding a shortest path while also filtering edges
</p>
      <h2>Definition</h2>
      <p>This variant of the Dijkstra's algorithm searches for shortest path in two ways, it does a forward search from the source vertex and a backwards one from the destination vertex, while also adding the corresponding restrictions on the edges given by the filter expression. If the path between the vertices exists, both searches will meet each other at an intermediate point.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(10 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>dst</code> - </dd>
<dd><code>cost</code> - </dd>
<dd><code>filterExpr</code> - </dd>
<dd><code>parent</code> - (out argument)
    </dd>
<dd><code>parentEdge</code> - (out argument)
    </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 EdgeFilter filter = EdgeFilter.fromExpression("edge.cost &gt; 5");
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 PgxPath&lt;Integer&gt; path = analyst.shortestPathFilteredDijkstraBidirectional(
   graph, src, dst, cost, filter, parent, parentEdge);
 path.getPathLengthWithCost();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathFilteredDijkstraBidirectionalAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathFilteredDijkstraBidirectionalAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;&nbsp;shortestPathFilteredDijkstraBidirectionalAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                                                  <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr)</pre>
<div class="block"><p>Bidirectional dijkstra is a fast algorithm for finding a shortest path while also filtering edges
</p>
      <h2>Definition</h2>
      <p>This variant of the Dijkstra's algorithm searches for shortest path in two ways, it does a forward search from the source vertex and a backwards one from the destination vertex, while also adding the corresponding restrictions on the edges given by the filter expression. If the path between the vertices exists, both searches will meet each other at an intermediate point.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(10 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>dst</code> - </dd>
<dd><code>cost</code> - </dd>
<dd><code>filterExpr</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 EdgeFilter filter = EdgeFilter.fromExpression("edge.cost &gt; 5");
 PgxFuture&lt;PgxPath&lt;Integer&gt;&gt; promise = analyst.shortestPathFilteredDijkstraBidirectionalAsync(
   graph, src, dst, cost, filter);
 promise.thenAccept(path -&gt; {
   path.getPathLengthWithCost();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathFilteredDijkstraBidirectionalAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathFilteredDijkstraBidirectionalAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;&nbsp;shortestPathFilteredDijkstraBidirectionalAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                                                  <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr,
                                                                                  java.lang.String&nbsp;parentName,
                                                                                  java.lang.String&nbsp;parentEdgeName)</pre>
</li>
</ul>
<a name="shortestPathFilteredDijkstraBidirectionalAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.PgxVertex-oracle.pgx.api.EdgeProperty-oracle.pgx.api.filter.GraphFilter-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathFilteredDijkstraBidirectionalAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/PgxPath.html" title="class in oracle.pgx.api">PgxPath</a>&lt;ID&gt;&gt;&nbsp;shortestPathFilteredDijkstraBidirectionalAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                                  <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;dst,
                                                                                  <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;cost,
                                                                                  <a href="../../../oracle/pgx/api/filter/GraphFilter.html" title="class in oracle.pgx.api.filter">GraphFilter</a>&nbsp;filterExpr,
                                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                                                  <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</pre>
<div class="block"><p>Bidirectional dijkstra is a fast algorithm for finding a shortest path while also filtering edges
</p>
      <h2>Definition</h2>
      <p>This variant of the Dijkstra's algorithm searches for shortest path in two ways, it does a forward search from the source vertex and a backwards one from the destination vertex, while also adding the corresponding restrictions on the edges given by the filter expression. If the path between the vertices exists, both searches will meet each other at an intermediate point.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm runs in a sequential way.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E + V log V) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(10 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      <li>src: 0</li>
<li>dst: 1000</li>
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm can be implemented in optimization problems that can be represented with a graph structure.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>dst</code> - </dd>
<dd><code>cost</code> - </dd>
<dd><code>filterExpr</code> - </dd>
<dd><code>parent</code> - (out argument)
    </dd>
<dd><code>parentEdge</code> - (out argument)
    </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>PgxPath holding the information of the shortest path, if it exists.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxVertex&lt;Integer&gt; dst = graph.getVertex(333);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 EdgeFilter filter = EdgeFilter.fromExpression("edge.cost &gt; 5");
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 PgxFuture&lt;PgxPath&lt;Integer&gt;&gt; promise = analyst.shortestPathFilteredDijkstraBidirectionalAsync(
   graph, src, dst, cost, filter, parent, parentEdge);
 promise.thenAccept(path -&gt; {
   path.getPathLengthWithCost();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathHopDist-oracle.pgx.api.PgxGraph-java.lang.Object-">
<!--   -->
</a><a name="shortestPathHopDist-oracle.pgx.api.PgxGraph-ID-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathHopDist</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathHopDist(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                             ID&nbsp;srcId)
                                      throws java.util.concurrent.ExecutionException,
                                             java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDist-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-"><code>shortestPathHopDist(PgxGraph, PgxVertex)</code></a> taking a vertex ID instead of
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathHopDist-oracle.pgx.api.PgxGraph-java.lang.Object-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a><a name="shortestPathHopDist-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathHopDist</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathHopDist(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                             ID&nbsp;srcId,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                      throws java.util.concurrent.ExecutionException,
                                             java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDist-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-"><code>shortestPathHopDist(PgxGraph, PgxVertex, VertexProperty, VertexProperty,
 VertexProperty)</code></a> taking a vertex ID instead of
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathHopDist-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathHopDist</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathHopDist(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src)
                                      throws java.util.concurrent.ExecutionException,
                                             java.lang.InterruptedException</pre>
<div class="block"><p>Hop distance can give a relatively fast insight on the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The Hop distance of two vertices S and V in a graph is the number of edges that are in a shortest path connecting them. This algorithm will return the distance of each vertex with respect to the given source vertex in the input and will also return the parent vertex and linking edge for each vertex. The returned information allows to trace back shortest paths from any reachable vertex to the source vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 AllPaths&lt;Integer&gt; paths = analyst.shortestPathHopDist(graph, src);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathHopDist-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathHopDist</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathHopDist(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                      throws java.util.concurrent.ExecutionException,
                                             java.lang.InterruptedException</pre>
<div class="block"><p>Hop distance can give a relatively fast insight on the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The Hop distance of two vertices S and V in a graph is the number of edges that are in a shortest path connecting them. This algorithm will return the distance of each vertex with respect to the given source vertex in the input and will also return the parent vertex and linking edge for each vertex. The returned information allows to trace back shortest paths from any reachable vertex to the source vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>distance</code> - (out argument) </dd>
<dd><code>parent</code> - (out argument) </dd>
<dd><code>parentEdge</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; distance = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 AllPaths&lt;Integer&gt; paths = analyst.shortestPathHopDist(graph, src, distance, parent, parentEdge);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathHopDistAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathHopDistAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;&nbsp;shortestPathHopDistAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src)</pre>
<div class="block"><p>Hop distance can give a relatively fast insight on the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The Hop distance of two vertices S and V in a graph is the number of edges that are in a shortest path connecting them. This algorithm will return the distance of each vertex with respect to the given source vertex in the input and will also return the parent vertex and linking edge for each vertex. The returned information allows to trace back shortest paths from any reachable vertex to the source vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxFuture&lt;AllPaths&lt;Integer&gt;&gt; promise = analyst.shortestPathHopDistAsync(graph, src);
 promise.thenAccept(paths -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathHopDistAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathHopDistAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;&nbsp;shortestPathHopDistAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                             <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                             <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</pre>
<div class="block"><p>Hop distance can give a relatively fast insight on the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The Hop distance of two vertices S and V in a graph is the number of edges that are in a shortest path connecting them. This algorithm will return the distance of each vertex with respect to the given source vertex in the input and will also return the parent vertex and linking edge for each vertex. The returned information allows to trace back shortest paths from any reachable vertex to the source vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>distance</code> - (out argument) </dd>
<dd><code>parent</code> - (out argument) </dd>
<dd><code>parentEdge</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; distance = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 PgxFuture&lt;AllPaths&lt;Integer&gt;&gt; promise = analyst.shortestPathHopDistAsync(graph, src, distance, parent, parentEdge);
 promise.thenAccept(paths -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathHopDistReverse-oracle.pgx.api.PgxGraph-java.lang.Object-">
<!--   -->
</a><a name="shortestPathHopDistReverse-oracle.pgx.api.PgxGraph-ID-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathHopDistReverse</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathHopDistReverse(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                    ID&nbsp;srcId)
                                             throws java.util.concurrent.ExecutionException,
                                                    java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDistReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-"><code>shortestPathHopDistReverse(PgxGraph, PgxVertex)</code></a> taking a vertex ID instead of
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathHopDistReverse-oracle.pgx.api.PgxGraph-java.lang.Object-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a><a name="shortestPathHopDistReverse-oracle.pgx.api.PgxGraph-ID-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathHopDistReverse</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathHopDistReverse(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                    ID&nbsp;srcId,
                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                             throws java.util.concurrent.ExecutionException,
                                                    java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#shortestPathHopDistReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-"><code>shortestPathHopDistReverse(PgxGraph, PgxVertex, VertexProperty, VertexProperty,
 VertexProperty)</code></a> taking a vertex ID instead of
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathHopDistReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathHopDistReverse</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathHopDistReverse(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src)
                                             throws java.util.concurrent.ExecutionException,
                                                    java.lang.InterruptedException</pre>
<div class="block"><p>Backwards hop distance can give a relatively fast insight on the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The Hop distance of two vertices S and V in a graph is the number of edges that are in a shortest path connecting them. This algorithm will return the distance of each node with respect to the given source node in the input and will also return the parent node and linking edge for each node. The returned information allows to trace back shortest paths from any reachable node to the source node.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 AllPaths&lt;Integer&gt; paths = analyst.shortestPathHopDistReverse(graph, src);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathHopDistReverse-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathHopDistReverse</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&nbsp;shortestPathHopDistReverse(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)
                                             throws java.util.concurrent.ExecutionException,
                                                    java.lang.InterruptedException</pre>
<div class="block"><p>Backwards hop distance can give a relatively fast insight on the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The Hop distance of two vertices S and V in a graph is the number of edges that are in a shortest path connecting them. This algorithm will return the distance of each node with respect to the given source node in the input and will also return the parent node and linking edge for each node. The returned information allows to trace back shortest paths from any reachable node to the source node.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>distance</code> - (out argument) </dd>
<dd><code>parent</code> - (out argument) </dd>
<dd><code>parentEdge</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; distance = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 AllPaths&lt;Integer&gt; paths = analyst.shortestPathHopDistReverse(graph, src, distance, parent, parentEdge);
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="shortestPathHopDistReverseAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathHopDistReverseAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;&nbsp;shortestPathHopDistReverseAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src)</pre>
<div class="block"><p>Backwards hop distance can give a relatively fast insight on the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The Hop distance of two vertices S and V in a graph is the number of edges that are in a shortest path connecting them. This algorithm will return the distance of each node with respect to the given source node in the input and will also return the parent node and linking edge for each node. The returned information allows to trace back shortest paths from any reachable node to the source node.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 PgxFuture&lt;AllPaths&lt;Integer&gt;&gt; promise = analyst.shortestPathHopDistReverseAsync(graph, src);
 promise.thenAccept(paths -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="shortestPathHopDistReverseAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shortestPathHopDistReverseAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api">AllPaths</a>&lt;ID&gt;&gt;&nbsp;shortestPathHopDistReverseAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                    <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;src,
                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;distance,
                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&gt;&nbsp;parent,
                                                                    <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,<a href="../../../oracle/pgx/api/PgxEdge.html" title="class in oracle.pgx.api">PgxEdge</a>&gt;&nbsp;parentEdge)</pre>
<div class="block"><p>Backwards hop distance can give a relatively fast insight on the distances in a graph
</p>
      <h2>Definition</h2>
      <p>The Hop distance of two vertices S and V in a graph is the number of edges that are in a shortest path connecting them. This algorithm will return the distance of each node with respect to the given source node in the input and will also return the parent node and linking edge for each node. The returned information allows to trace back shortest paths from any reachable node to the source node.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses the built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful when looking for distances in a graph.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - </dd>
<dd><code>src</code> - </dd>
<dd><code>distance</code> - (out argument) </dd>
<dd><code>parent</code> - (out argument) </dd>
<dd><code>parentEdge</code> - (out argument) </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>AllPaths holding the information of the possible shortest paths from the source node.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; src = graph.getVertex(128);
 VertexProperty&lt;Integer, Double&gt; distance = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, PgxVertex&lt;Integer&gt;&gt; parent = graph.createVertexProperty(PropertyType.VERTEX);
 VertexProperty&lt;Integer, PgxEdge&gt; parentEdge = graph.createVertexProperty(PropertyType.EDGE);
 PgxFuture&lt;AllPaths&lt;Integer&gt;&gt; promise = analyst.shortestPathHopDistReverseAsync(
   graph, src, distance, parent, parentEdge);
 promise.thenAccept(paths -&gt; {
   ...;
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="supervisedGraphWiseModelBuilder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>supervisedGraphWiseModelBuilder</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/mllib/SupervisedGraphWiseModelBuilder.html" title="class in oracle.pgx.api.mllib">SupervisedGraphWiseModelBuilder</a>&nbsp;supervisedGraphWiseModelBuilder()</pre>
<div class="block">Return a SupervisedGraphWise model builder that can be used to set the configuration of the model and then create
 it.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the builder</dd>
</dl>
</li>
</ul>
<a name="topologicalSchedule-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>topologicalSchedule</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;topologicalSchedule(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;source)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Topological schedule gives an order of visit for the reachable vertices from the source
</p>
      <h2>Definition</h2>
      <p>Topological schedule sets an order over the vertices in a graph based on the proximity these have to the vertices from the given source. The algorithm does a BFS travesarl for each vertex from the source set in order to assign the correct scheduling order to all the reachable, even if the graph is undirected or has cycles. The vertices that are not reachable will be assigned a value of -1.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(k * (V + E)) with V = number of vertices, E = number of edges, k = size of the source set</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful for tasks involving serialization and dependencies.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>source</code> - set of vertices to be used as the starting points for the scheduling order.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the scheduled order of each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Integer&gt; topoSched = analyst.topologicalSchedule(graph, source);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + topoSched.getName() + " WHERE (x) ORDER BY x." + topoSched.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="topologicalSchedule-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>topologicalSchedule</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;topologicalSchedule(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;source,
                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;topoSched)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>Topological sort gives an order of visit for vertices in directed acyclic graphs
</p>
      <h2>Definition</h2>
      <p>Topological sort tries to set an order over the vertices in a graph using the direction of the edges. A directed graph has a topological order if and only if it has no cycles, i.e. it is a directed acyclic graph. The algorithm visits the vertices in a DFS-like fashion to set up their order. The order of the vertices is returned as a vertex property, and the values will be set to -1 if there is a cycle in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm is sequential due the ordering constraint.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful for tasks involving serialization and dependencies.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>source</code> - set of vertices to be used as the starting points for the scheduling order.</dd>
<dd><code>topoSched</code> - (out argument)
    vertex property holding the scheduled order of each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the scheduled order of each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Integer&gt; prop = graph.createVertexProperty(PropertyType.INTEGER);
 VertexProperty&lt;Integer, Integer&gt; topoSched = analyst.topologicalSchedule(graph, source, prop);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + topoSched.getName() + " WHERE (x) ORDER BY x." + topoSched.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="topologicalScheduleAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>topologicalScheduleAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;topologicalScheduleAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;source)</pre>
<div class="block"><p>Topological schedule gives an order of visit for the reachable vertices from the source
</p>
      <h2>Definition</h2>
      <p>Topological schedule sets an order over the vertices in a graph based on the proximity these have to the vertices from the given source. The algorithm does a BFS travesarl for each vertex from the source set in order to assign the correct scheduling order to all the reachable, even if the graph is undirected or has cycles. The vertices that are not reachable will be assigned a value of -1.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(k * (V + E)) with V = number of vertices, E = number of edges, k = size of the source set</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful for tasks involving serialization and dependencies.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>source</code> - set of vertices to be used as the starting points for the scheduling order.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the scheduled order of each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; source = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 PgxFuture&lt;VertexProperty&lt;Integer, Integer&gt;&gt; promise = analyst.topologicalScheduleAsync(graph, source);
 promise.thenCompose(topoSched -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + topoSched.getName() + " WHERE (x) ORDER BY x." + topoSched.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="topologicalScheduleAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexSet-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>topologicalScheduleAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;topologicalScheduleAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/VertexSet.html" title="class in oracle.pgx.api">VertexSet</a>&lt;ID&gt;&nbsp;source,
                                                                                     <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;topoSched)</pre>
<div class="block"><p>Topological schedule gives an order of visit for the reachable vertices from the source
</p>
      <h2>Definition</h2>
      <p>Topological schedule sets an order over the vertices in a graph based on the proximity these have to the vertices from the given source. The algorithm does a BFS travesarl for each vertex from the source set in order to assign the correct scheduling order to all the reachable, even if the graph is undirected or has cycles. The vertices that are not reachable will be assigned a value of -1.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a built-in BFS feature.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(k * (V + E)) with V = number of vertices, E = number of edges, k = size of the source set</code></li>
        <li>Space: <code>O(V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful for tasks involving serialization and dependencies.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>source</code> - set of vertices to be used as the starting points for the scheduling order.</dd>
<dd><code>topoSched</code> - (out argument)
    vertex property holding the scheduled order of each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the scheduled order of each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSet&lt;Integer&gt; source = graph.getVertices(VertexFilter.fromExpression("vertex.prop1 &lt; 10"));
 VertexProperty&lt;Integer, Integer&gt; topoSched = graph.createVertexProperty(PropertyType.INTEGER);
 PgxFuture&lt;VertexProperty&lt;Integer, Integer&gt;&gt; promise = analyst.topologicalScheduleAsync(graph, source, topoSched);
 promise.thenCompose(topoSched -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + topoSched.getName() + " WHERE (x) ORDER BY x." + topoSched.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="topologicalSort-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>topologicalSort</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;topologicalSort(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                          throws java.util.concurrent.ExecutionException,
                                                                 java.lang.InterruptedException</pre>
<div class="block"><p>Topological sort gives an order of visit for vertices in directed acyclic graphs
</p>
      <h2>Definition</h2>
      <p>Topological sort tries to set an order over the vertices in a graph using the direction of the edges. A directed graph has a topological order if and only if it has no cycles, i.e. it is a directed acyclic graph. The algorithm visits the vertices in a DFS-like fashion to set up their order. The order of the vertices is returned as a vertex property, and the values will be set to -1 if there is a cycle in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm is sequential due the ordering constraint.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful for tasks involving serialization and dependencies.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the topological order of each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Integer&gt; topoSort = analyst.topologicalSort(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + topoSort.getName() + " WHERE (x) ORDER BY x." + topoSort.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="topologicalSort-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>topologicalSort</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;topologicalSort(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;topoSort)
                                                          throws java.util.concurrent.ExecutionException,
                                                                 java.lang.InterruptedException</pre>
<div class="block"><p>Topological sort gives an order of visit for vertices in directed acyclic graphs
</p>
      <h2>Definition</h2>
      <p>Topological sort tries to set an order over the vertices in a graph using the direction of the edges. A directed graph has a topological order if and only if it has no cycles, i.e. it is a directed acyclic graph. The algorithm visits the vertices in a DFS-like fashion to set up their order. The order of the vertices is returned as a vertex property, and the values will be set to -1 if there is a cycle in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm is sequential due the ordering constraint.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful for tasks involving serialization and dependencies.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>topoSort</code> - (out argument) vertex property holding the topological order of each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the topological order of each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Integer&gt; prop = graph.createVertexProperty(PropertyType.INTEGER);
 VertexProperty&lt;Integer, Integer&gt; topoSort = analyst.topologicalSort(graph, prop);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + topoSort.getName() + " WHERE (x) ORDER BY x." + topoSort.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="topologicalSortAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>topologicalSortAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;topologicalSortAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Topological sort gives an order of visit for vertices in directed acyclic graphs
</p>
      <h2>Definition</h2>
      <p>Topological sort tries to set an order over the vertices in a graph using the direction of the edges. A directed graph has a topological order if and only if it has no cycles, i.e. it is a directed acyclic graph. The algorithm visits the vertices in a DFS-like fashion to set up their order. The order of the vertices is returned as a vertex property, and the values will be set to -1 if there is a cycle in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm is sequential due the ordering constraint.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful for tasks involving serialization and dependencies.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the topological order of each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Integer&gt;&gt; promise = analyst.topologicalSortAsync(graph);
 promise.thenCompose(topoSort -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + topoSort.getName() + " WHERE (x) ORDER BY x." + topoSort.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="topologicalSortAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>topologicalSortAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&gt;&nbsp;topologicalSortAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Integer&gt;&nbsp;topoSort)</pre>
<div class="block"><p>Topological sort gives an order of visit for vertices in directed acyclic graphs
</p>
      <h2>Definition</h2>
      <p>Topological sort tries to set an order over the vertices in a graph using the direction of the edges. A directed graph has a topological order if and only if it has no cycles, i.e. it is a directed acyclic graph. The algorithm visits the vertices in a DFS-like fashion to set up their order. The order of the vertices is returned as a vertex property, and the values will be set to -1 if there is a cycle in the graph.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm is sequential due the ordering constraint.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V + E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>This algorithm computes a basic structural graph property that is useful for tasks involving serialization and dependencies.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>topoSort</code> - (out argument) vertex property holding the topological order of each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the topological order of each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Integer&gt; topoSort = graph.createVertexProperty(PropertyType.INTEGER);
 PgxFuture&lt;VertexProperty&lt;Integer, Integer&gt;&gt; promise = analyst.topologicalSortAsync(graph, topoSort);
 promise.thenCompose(topoSort -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + topoSort.getName() + " WHERE (x) ORDER BY x." + topoSort.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="toString--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a name="unsupervisedGraphWiseModelBuilder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unsupervisedGraphWiseModelBuilder</h4>
<pre>public&nbsp;<a href="../../../oracle/pgx/api/mllib/UnsupervisedGraphWiseModelBuilder.html" title="class in oracle.pgx.api.mllib">UnsupervisedGraphWiseModelBuilder</a>&nbsp;unsupervisedGraphWiseModelBuilder()</pre>
<div class="block">Return a UnsupervisedGraphWise model builder that can be used to set the configuration of the model and then create
 it.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the builder</dd>
</dl>
</li>
</ul>
<a name="vertexBetweennessCentrality-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vertexBetweennessCentrality</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;vertexBetweennessCentrality(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                                                                     throws java.util.concurrent.ExecutionException,
                                                                            java.lang.InterruptedException</pre>
<div class="block"><p>Betweenness centrality measures the centrality of the vertices to identify important vertices for the flow of information
</p>
      <h2>Definition</h2>
      <p>The Betweenness Centrality of a vertex V in a graph is the sum of the fraction of shortests paths that pass through V from all the possible shortest paths connecting every possible pair of vertices S, T in the graph, such that V is different from S and T. Because of its definition, the algorithm is meant for connected graphs.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from betweenness centrality can be used to identify vertices in a graph that are vital for the flow of information within it, making it a good option for applications in social networks and problems modelling flows of any kind.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the betweenness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; betweenness = analyst.vertexBetweennessCentrality(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + betweenness.getName() + " MATCH (x) ORDER BY x." + betweenness.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="vertexBetweennessCentrality-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vertexBetweennessCentrality</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;vertexBetweennessCentrality(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;bc)
                                                                     throws java.util.concurrent.ExecutionException,
                                                                            java.lang.InterruptedException</pre>
<div class="block"><p>Betweenness centrality measures the centrality of the vertices to identify important vertices for the flow of information
</p>
      <h2>Definition</h2>
      <p>The Betweenness Centrality of a vertex V in a graph is the sum of the fraction of shortests paths that pass through V from all the possible shortest paths connecting every possible pair of vertices S, T in the graph, such that V is different from S and T. Because of its definition, the algorithm is meant for connected graphs.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from betweenness centrality can be used to identify vertices in a graph that are vital for the flow of information within it, making it a good option for applications in social networks and problems modelling flows of any kind.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>bc</code> - (out argument)
    vertex property holding the betweenness centrality value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the betweenness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; bc = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; betweenness = analyst.vertexBetweennessCentrality(graph, bc);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + betweenness.getName() + " MATCH (x) ORDER BY x." + betweenness.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="vertexBetweennessCentralityAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vertexBetweennessCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;vertexBetweennessCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Betweenness centrality measures the centrality of the vertices to identify important vertices for the flow of information
</p>
      <h2>Definition</h2>
      <p>The Betweenness Centrality of a vertex V in a graph is the sum of the fraction of shortests paths that pass through V from all the possible shortest paths connecting every possible pair of vertices S, T in the graph, such that V is different from S and T. Because of its definition, the algorithm is meant for connected graphs.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from betweenness centrality can be used to identify vertices in a graph that are vital for the flow of information within it, making it a good option for applications in social networks and problems modelling flows of any kind.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the betweenness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.vertexBetweennessCentralityAsync(graph);
 promise.thenCompose(betweenness -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + betweenness.getName() + " MATCH (x) ORDER BY x." + betweenness.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="vertexBetweennessCentralityAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vertexBetweennessCentralityAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;vertexBetweennessCentralityAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                            <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;bc)</pre>
<div class="block"><p>Betweenness centrality measures the centrality of the vertices to identify important vertices for the flow of information
</p>
      <h2>Definition</h2>
      <p>The Betweenness Centrality of a vertex V in a graph is the sum of the fraction of shortests paths that pass through V from all the possible shortest paths connecting every possible pair of vertices S, T in the graph, such that V is different from S and T. Because of its definition, the algorithm is meant for connected graphs.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses a parallel BFS method called Multi-Source BFS (MS-BSF) for a faster and more efficient search of the shortests paths. It is an expensive algorithm to run on large graphs.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(V * E) with V = number of vertices, E = number of edges</code></li>
        <li>Space: <code>O(3 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>The coefficient from betweenness centrality can be used to identify vertices in a graph that are vital for the flow of information within it, making it a good option for applications in social networks and problems modelling flows of any kind.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>bc</code> - (out argument)
    vertex property holding the betweenness centrality value for each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the betweenness centrality value for each vertex.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; bc = graph.createVertexProperty(PropertyType.DOUBLE);
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.vertexBetweennessCentralityAsync(graph, bc);
 promise.thenCompose(betweenness -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + betweenness.getName() + " MATCH (x) ORDER BY x." + betweenness.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="wcc-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>wcc</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;wcc(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)
                       throws java.util.concurrent.ExecutionException,
                              java.lang.InterruptedException</pre>
<div class="block"><p>Identifying weakly connected components can be useful for clustering graph data
</p>
      <h2>Definition</h2>
      <p>This algorithm finds weakly connected components (WCC) in a directed graph. A WCC is a maximal subset of vertices of the graph with the particular characteristic that for every pair of vertices U and V in the WCC there must be a path connecting U to V, ignoring the direction of edges. It is a non-deterministic algorithm because of its parallelized implementation.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * d) with d = diameter of the graph</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It can be used for clustering and analysis in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the components found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 Partition&lt;Integer&gt; wcc = analyst.wcc(graph);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + wcc.getPropertyName() + " MATCH (x) ORDER BY x." + wcc.getPropertyName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)">Connectivity "("graph theory")"</a></dd>
</dl>
</li>
</ul>
<a name="wcc-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>wcc</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&nbsp;wcc(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)
                       throws java.util.concurrent.ExecutionException,
                              java.lang.InterruptedException</pre>
<div class="block"><p>Identifying weakly connected components can be useful for clustering graph data
</p>
      <h2>Definition</h2>
      <p>This algorithm finds weakly connected components (WCC) in a directed graph. A WCC is a maximal subset of vertices of the graph with the particular characteristic that for every pair of vertices U and V in the WCC there must be a path connecting U to V, ignoring the direction of edges. It is a non-deterministic algorithm because of its parallelized implementation.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * d) with d = diameter of the graph</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It can be used for clustering and analysis in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partitionDistribution</code> - vertex property holding the label of the WCC assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the components found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Long&gt; pd = graph.createVertexProperty(PropertyType.LONG);
 Partition&lt;Integer&gt; wcc = analyst.wcc(graph, pd);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + wcc.getPropertyName() + " MATCH (x) ORDER BY x." + wcc.getPropertyName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)">Connectivity "("graph theory")"</a></dd>
</dl>
</li>
</ul>
<a name="wccAsync-oracle.pgx.api.PgxGraph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>wccAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;wccAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph)</pre>
<div class="block"><p>Identifying weakly connected components can be useful for clustering graph data
</p>
      <h2>Definition</h2>
      <p>This algorithm finds weakly connected components (WCC) in a directed graph. A WCC is a maximal subset of vertices of the graph with the particular characteristic that for every pair of vertices U and V in the WCC there must be a path connecting U to V, ignoring the direction of edges. It is a non-deterministic algorithm because of its parallelized implementation.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * d) with d = diameter of the graph</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It can be used for clustering and analysis in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the components found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.wccAsync(graph);
 promise.thenCompose(wcc -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + wcc.getPropertyName() + " MATCH (x) ORDER BY x." + wcc.getPropertyName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)">Connectivity "("graph theory")"</a></dd>
</dl>
</li>
</ul>
<a name="wccAsync-oracle.pgx.api.PgxGraph-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>wccAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;wccAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                              java.lang.String&nbsp;partitonDistributionName)</pre>
</li>
</ul>
<a name="wccAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>wccAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/Partition.html" title="class in oracle.pgx.api">Partition</a>&lt;ID&gt;&gt;&nbsp;wccAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                              <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Long&gt;&nbsp;partitionDistribution)</pre>
<div class="block"><p>Identifying weakly connected components can be useful for clustering graph data
</p>
      <h2>Definition</h2>
      <p>This algorithm finds weakly connected components (WCC) in a directed graph. A WCC is a maximal subset of vertices of the graph with the particular characteristic that for every pair of vertices U and V in the WCC there must be a path connecting U to V, ignoring the direction of edges. It is a non-deterministic algorithm because of its parallelized implementation.
</p>
      <h2>Implementation Details</h2>
      <p>This algorithm is designed to run in parallel given its high degree of parallelization.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * d) with d = diameter of the graph</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It can be used for clustering and analysis in social networks.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>partitionDistribution</code> - vertex property holding the label of the WCC assigned to each vertex.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Partition holding the node collections corresponding to the components found by the algorithm.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Long&gt; pd = graph.createVertexProperty(PropertyType.LONG);
 PgxFuture&lt;Partition&lt;Integer&gt;&gt; promise = analyst.wccAsync(graph, pd);
 promise.thenCompose(wcc -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + wcc.getPropertyName() + " MATCH (x) ORDER BY x." + wcc.getPropertyName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)">Connectivity "("graph theory")"</a></dd>
</dl>
</li>
</ul>
<a name="weightedPagerank-oracle.pgx.api.PgxGraph-boolean-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;weightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                 boolean&nbsp;norm,
                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                                          throws java.util.concurrent.ExecutionException,
                                                                 java.lang.InterruptedException</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.weightedPagerank(graph, false, cost);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="weightedPagerank-oracle.pgx.api.PgxGraph-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;weightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                 boolean&nbsp;norm,
                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                          throws java.util.concurrent.ExecutionException,
                                                                 java.lang.InterruptedException</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.weightedPagerank(graph, false, cost, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="weightedPagerank-oracle.pgx.api.PgxGraph-double-double-int-boolean-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;weightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                 double&nbsp;e,
                                                                 double&nbsp;d,
                                                                 int&nbsp;max,
                                                                 boolean&nbsp;norm,
                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                                          throws java.util.concurrent.ExecutionException,
                                                                 java.lang.InterruptedException</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.weightedPagerank(graph, 0.001, 0.85, 100, false, cost);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="weightedPagerank-oracle.pgx.api.PgxGraph-double-double-int-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;weightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                 double&nbsp;e,
                                                                 double&nbsp;d,
                                                                 int&nbsp;max,
                                                                 boolean&nbsp;norm,
                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                          throws java.util.concurrent.ExecutionException,
                                                                 java.lang.InterruptedException</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.weightedPagerank(graph, 0.001, 0.85, 100, false, cost, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="weightedPagerank-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;weightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                 double&nbsp;e,
                                                                 double&nbsp;d,
                                                                 int&nbsp;max,
                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                                          throws java.util.concurrent.ExecutionException,
                                                                 java.lang.InterruptedException</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.weightedPagerank(graph, 0.001, 0.85, 100, cost);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="weightedPagerank-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;weightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                 double&nbsp;e,
                                                                 double&nbsp;d,
                                                                 int&nbsp;max,
                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                          throws java.util.concurrent.ExecutionException,
                                                                 java.lang.InterruptedException</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.weightedPagerank(graph, 0.001, 0.85, 100, cost, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="weightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;weightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)
                                                          throws java.util.concurrent.ExecutionException,
                                                                 java.lang.InterruptedException</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.weightedPagerank(graph, cost);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="weightedPagerank-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerank</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;weightedPagerank(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)
                                                          throws java.util.concurrent.ExecutionException,
                                                                 java.lang.InterruptedException</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 VertexProperty&lt;Integer, Double&gt; pagerank = analyst.weightedPagerank(graph, cost, rank);
 PgqlResultSet rs = graph.queryPgql(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC");
 rs.print();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="weightedPagerankAsync-oracle.pgx.api.PgxGraph-boolean-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;weightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                 boolean&nbsp;norm,
                                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.weightedPagerankAsync(graph, false, cost);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="weightedPagerankAsync-oracle.pgx.api.PgxGraph-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;weightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                 boolean&nbsp;norm,
                                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.weightedPagerankAsync(graph, false, cost, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="weightedPagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-boolean-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;weightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                 double&nbsp;e,
                                                                                 double&nbsp;d,
                                                                                 int&nbsp;max,
                                                                                 boolean&nbsp;norm,
                                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.weightedPagerankAsync(
   graph, 0.001, 0.85, 100, false, cost);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="weightedPagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-boolean-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;weightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                 double&nbsp;e,
                                                                                 double&nbsp;d,
                                                                                 int&nbsp;max,
                                                                                 boolean&nbsp;norm,
                                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>norm</code> - boolean flag to determine whether the algorithm will take into account dangling vertices for the ranking scores.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.weightedPagerankAsync(
   graph, 0.001, 0.85, 100, false, cost, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="weightedPagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;weightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                 double&nbsp;e,
                                                                                 double&nbsp;d,
                                                                                 int&nbsp;max,
                                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.weightedPagerankAsync(graph, 0.001, 0.85, 100, cost);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="weightedPagerankAsync-oracle.pgx.api.PgxGraph-double-double-int-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;weightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                 double&nbsp;e,
                                                                                 double&nbsp;d,
                                                                                 int&nbsp;max,
                                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>e</code> - maximum tolerated error value. The algorithm will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>d</code> - damping factor.</dd>
<dd><code>max</code> - maximum number of iterations that will be performed.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.weightedPagerankAsync(
   graph, 0.001, 0.85, 100, cost, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="weightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;weightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight)</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.weightedPagerankAsync(graph, cost);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="weightedPagerankAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.EdgeProperty-oracle.pgx.api.VertexProperty-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedPagerankAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&gt;&nbsp;weightedPagerankAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                 <a href="../../../oracle/pgx/api/EdgeProperty.html" title="class in oracle.pgx.api">EdgeProperty</a>&lt;java.lang.Double&gt;&nbsp;weight,
                                                                                 <a href="../../../oracle/pgx/api/VertexProperty.html" title="class in oracle.pgx.api">VertexProperty</a>&lt;ID,java.lang.Double&gt;&nbsp;rank)</pre>
<div class="block"><p>PageRank on weighted edges. It compares and spots out important vertices in a graph
</p>
      <h2>Definition</h2>
      <p>The Weighted PageRank works like the original PageRank algorithm, except that it allows for a weight value assigned to each edge. This weight determines the fraction of the PageRank score that will flow from the source vertex through the current edge to its destination vertex.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. The PageRank values of all the vertices in the graph are computed, hence updated, at each iteration step.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * k) with E = number of edges, k <= maximum number of iterations</code></li>
        <li>Space: <code>O(2 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>It extends the scope of the PageRank applications by allowing edges with non-uniform weights, which can reflect better the structures underlying in graphs.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>weight</code> - edge property holding the weight of each edge in the graph.</dd>
<dd><code>rank</code> - (out argument) vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vertex property holding the (normalized) PageRank value for each vertex (a value between 0 and 1).

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexProperty&lt;Integer, Double&gt; rank = graph.createVertexProperty(PropertyType.DOUBLE);
 EdgeProperty&lt;Double&gt; cost = graph.getEdgeProperty("cost");
 PgxFuture&lt;VertexProperty&lt;Integer, Double&gt;&gt; promise = analyst.weightedPagerankAsync(graph, cost, rank);
 promise.thenCompose(pagerank -&gt; graph.queryPgqlAsync(
   "SELECT x, x." + pagerank.getName() + " MATCH (x) ORDER BY x." + pagerank.getName() + " DESC"))
   .thenAccept(PgqlResultSet::print);
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="whomToFollow-oracle.pgx.api.PgxGraph-java.lang.Object-int-">
<!--   -->
</a><a name="whomToFollow-oracle.pgx.api.PgxGraph-ID-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollow</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&nbsp;whomToFollow(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     ID&nbsp;vertexId,
                                                                     int&nbsp;topK)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-"><code>whomToFollow(PgxGraph, PgxVertex, int)</code></a> taking a vertex ID instead of a
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="whomToFollow-oracle.pgx.api.PgxGraph-java.lang.Object-int-int-">
<!--   -->
</a><a name="whomToFollow-oracle.pgx.api.PgxGraph-ID-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollow</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&nbsp;whomToFollow(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     ID&nbsp;vertexId,
                                                                     int&nbsp;topK,
                                                                     int&nbsp;sizeCircleOfTrust)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around <a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-"><code>whomToFollow(PgxGraph, PgxVertex, int, int)</code></a> taking a vertex ID instead of a
 <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="whomToFollow-oracle.pgx.api.PgxGraph-java.lang.Object-int-int-int-java.math.BigDecimal-java.math.BigDecimal-int-java.math.BigDecimal-">
<!--   -->
</a><a name="whomToFollow-oracle.pgx.api.PgxGraph-ID-int-int-int-java.math.BigDecimal-java.math.BigDecimal-int-java.math.BigDecimal-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollow</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&nbsp;whomToFollow(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     ID&nbsp;vertexId,
                                                                     int&nbsp;topK,
                                                                     int&nbsp;sizeCircleOfTrust,
                                                                     int&nbsp;maxIter,
                                                                     java.math.BigDecimal&nbsp;tol,
                                                                     java.math.BigDecimal&nbsp;dampingFactor,
                                                                     int&nbsp;salsaMaxIter,
                                                                     java.math.BigDecimal&nbsp;salsaTol)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-int-java.math.BigDecimal-java.math.BigDecimal-int-java.math.BigDecimal-"><code>whomToFollow(PgxGraph, PgxVertex, int, int, int, BigDecimal, BigDecimal, int, BigDecimal)</code></a>
 taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="whomToFollow-oracle.pgx.api.PgxGraph-java.lang.Object-int-int-int-java.math.BigDecimal-java.math.BigDecimal-int-java.math.BigDecimal-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">
<!--   -->
</a><a name="whomToFollow-oracle.pgx.api.PgxGraph-ID-int-int-int-java.math.BigDecimal-java.math.BigDecimal-int-java.math.BigDecimal-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollow</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&nbsp;whomToFollow(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     ID&nbsp;vertexId,
                                                                     int&nbsp;topK,
                                                                     int&nbsp;sizeCircleOfTrust,
                                                                     int&nbsp;maxIter,
                                                                     java.math.BigDecimal&nbsp;tol,
                                                                     java.math.BigDecimal&nbsp;dampingFactor,
                                                                     int&nbsp;salsaMaxIter,
                                                                     java.math.BigDecimal&nbsp;salsaTol,
                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block">Convenience wrapper around
 <a href="../../../oracle/pgx/api/Analyst.html#whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-int-java.math.BigDecimal-java.math.BigDecimal-int-java.math.BigDecimal-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-"><code>whomToFollow(PgxGraph, PgxVertex, int, int, int, BigDecimal, BigDecimal, int, BigDecimal, VertexSequence,
 VertexSequence)</code></a>
 taking a vertex ID instead of a <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api"><code>PgxVertex</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollow</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&nbsp;whomToFollow(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt; wtf = analyst.whomToFollow(graph, vertex);
 wtf.getFirst();
 wtf.getSecond();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollow</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&nbsp;whomToFollow(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                                                                     int&nbsp;topK)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dd><code>topK</code> - the maximum number of recommendations that will be returned. This number should be smaller than the size of the circle of trust.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt; wtf = analyst.whomToFollow(graph, vertex, 100);
 wtf.getFirst();
 wtf.getSecond();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollow</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&nbsp;whomToFollow(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                                                                     int&nbsp;topK,
                                                                     int&nbsp;sizeCircleOfTrust)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dd><code>topK</code> - the maximum number of recommendations that will be returned. This number should be smaller than the size of the circle of trust.</dd>
<dd><code>sizeCircleOfTrust</code> - the maximum size of the circle of trust.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt; wtf = analyst.whomToFollow(graph, vertex, 100, 500);
 wtf.getFirst();
 wtf.getSecond();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-int-double-double-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollow</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&nbsp;whomToFollow(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                                                                     int&nbsp;topK,
                                                                     int&nbsp;sizeCircleOfTrust,
                                                                     int&nbsp;maxIter,
                                                                     double&nbsp;tol,
                                                                     double&nbsp;dampingFactor,
                                                                     int&nbsp;salsaMaxIter,
                                                                     double&nbsp;salsaTol)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dd><code>topK</code> - the maximum number of recommendations that will be returned. This number should be smaller than the size of the circle of trust.</dd>
<dd><code>sizeCircleOfTrust</code> - the maximum size of the circle of trust.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed for the Pagerank stage.</dd>
<dd><code>tol</code> - maximum tolerated error value for the Pagerank stage. The stage will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>dampingFactor</code> - damping factor for the Pagerank stage.</dd>
<dd><code>salsaMaxIter</code> - maximum number of iterations that will be performed for the SALSA stage.</dd>
<dd><code>salsaTol</code> - maximum tolerated error value for the SALSA stage. The stage will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>hubs</code> - (out argument) vertex sequence holding the top rated hub vertices (similar users) for the recommendations.</dd>
<dd><code>authorities</code> - (out argument) vertex sequence holding the top rated authority vertices (users to follow) for the recommendations.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt; wtf =
   analyst.whomToFollow(graph, vertex, 100, 500, 100, 0.001, 0.85, 100, 0.001);
 wtf.getFirst();
 wtf.getSecond();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-int-double-double-int-double-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollow</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&nbsp;whomToFollow(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                                                                     int&nbsp;topK,
                                                                     int&nbsp;sizeCircleOfTrust,
                                                                     int&nbsp;maxIter,
                                                                     double&nbsp;tol,
                                                                     double&nbsp;dampingFactor,
                                                                     int&nbsp;salsaMaxIter,
                                                                     double&nbsp;salsaTol,
                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dd><code>topK</code> - the maximum number of recommendations that will be returned. This number should be smaller than the size of the circle of trust.</dd>
<dd><code>sizeCircleOfTrust</code> - the maximum size of the circle of trust.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed for the Pagerank stage.</dd>
<dd><code>tol</code> - maximum tolerated error value for the Pagerank stage. The stage will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>dampingFactor</code> - damping factor for the Pagerank stage.</dd>
<dd><code>salsaMaxIter</code> - maximum number of iterations that will be performed for the SALSA stage.</dd>
<dd><code>salsaTol</code> - maximum tolerated error value for the SALSA stage. The stage will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>hubs</code> - (out argument) vertex sequence holding the top rated hub vertices (similar users) for the recommendations.</dd>
<dd><code>authorities</code> - (out argument) vertex sequence holding the top rated authority vertices (users to follow) for the recommendations.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSequence&lt;Integer&gt; hubs = graph.createVertexSequence();
 VertexSequence&lt;Integer&gt; auth = graph.createVertexSequence();
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt; wtf =
   analyst.whomToFollow(graph, vertex, 100, 500, 100, 0.001, 0.85, 100, 0.001, hubs, auth);
 wtf.getFirst();
 wtf.getSecond();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollow</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&nbsp;whomToFollow(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                                                                     int&nbsp;topK,
                                                                     int&nbsp;sizeCircleOfTrust,
                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dd><code>topK</code> - the maximum number of recommendations that will be returned. This number should be smaller than the size of the circle of trust.</dd>
<dd><code>sizeCircleOfTrust</code> - the maximum size of the circle of trust.</dd>
<dd><code>hubs</code> - (out argument) vertex sequence holding the top rated hub vertices (similar users) for the recommendations.</dd>
<dd><code>authorities</code> - (out argument) vertex sequence holding the top rated authority vertices (users to follow) for the recommendations.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSequence&lt;Integer&gt; hubs = graph.createVertexSequence();
 VertexSequence&lt;Integer&gt; auth = graph.createVertexSequence();
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt; wtf =
   analyst.whomToFollow(graph, vertex, 100, 500, hubs, auth);
 wtf.getFirst();
 wtf.getSecond();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollow</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&nbsp;whomToFollow(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                                                                     int&nbsp;topK,
                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dd><code>topK</code> - the maximum number of recommendations that will be returned. This number should be smaller than the size of the circle of trust.</dd>
<dd><code>hubs</code> - (out argument) vertex sequence holding the top rated hub vertices (similar users) for the recommendations.</dd>
<dd><code>authorities</code> - (out argument) vertex sequence holding the top rated authority vertices (users to follow) for the recommendations.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSequence&lt;Integer&gt; hubs = graph.createVertexSequence();
 VertexSequence&lt;Integer&gt; auth = graph.createVertexSequence();
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt; wtf = analyst.whomToFollow(graph, vertex, 100, hubs, auth);
 wtf.getFirst();
 wtf.getSecond();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="whomToFollow-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollow</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&nbsp;whomToFollow(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)
                                                              throws java.util.concurrent.ExecutionException,
                                                                     java.lang.InterruptedException</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dd><code>hubs</code> - (out argument) vertex sequence holding the top rated hub vertices (similar users) for the recommendations.</dd>
<dd><code>authorities</code> - (out argument) vertex sequence holding the top rated authority vertices (users to follow) for the recommendations.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 VertexSequence&lt;Integer&gt; hubs = graph.createVertexSequence();
 VertexSequence&lt;Integer&gt; auth = graph.createVertexSequence();
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt; wtf = analyst.whomToFollow(graph, vertex, hubs, auth);
 wtf.getFirst();
 wtf.getSecond();
 </code>
 </pre></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.lang.InterruptedException</code></dd>
</dl>
</li>
</ul>
<a name="whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollowAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;&nbsp;whomToFollowAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex)</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxFuture&lt;Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt;&gt; promise = analyst.whomToFollowAsync(
   graph, vertex);
 promise.thenAccept(wtf -&gt; {
   wtf.getFirst();
   wtf.getSecond();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollowAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;&nbsp;whomToFollowAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                                                                                     int&nbsp;topK)</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dd><code>topK</code> - the maximum number of recommendations that will be returned. This number should be smaller than the size of the circle of trust.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxFuture&lt;Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt;&gt; promise = analyst.whomToFollowAsync(
   graph, vertex, 100);
 promise.thenAccept(wtf -&gt; {
   wtf.getFirst();
   wtf.getSecond();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollowAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;&nbsp;whomToFollowAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                                                                                     int&nbsp;topK,
                                                                                     int&nbsp;sizeCircleOfTrust)</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dd><code>topK</code> - the maximum number of recommendations that will be returned. This number should be smaller than the size of the circle of trust.</dd>
<dd><code>sizeCircleOfTrust</code> - the maximum size of the circle of trust.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxFuture&lt;Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt;&gt; promise = analyst.whomToFollowAsync(
   graph, vertex, 100, 500);
 promise.thenAccept(wtf -&gt; {
   wtf.getFirst();
   wtf.getSecond();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-int-double-double-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollowAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;&nbsp;whomToFollowAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                                                                                     int&nbsp;topK,
                                                                                     int&nbsp;sizeCircleOfTrust,
                                                                                     int&nbsp;maxIter,
                                                                                     double&nbsp;tol,
                                                                                     double&nbsp;dampingFactor,
                                                                                     int&nbsp;salsaMaxIter,
                                                                                     double&nbsp;salsaTol)</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dd><code>topK</code> - the maximum number of recommendations that will be returned. This number should be smaller than the size of the circle of trust.</dd>
<dd><code>sizeCircleOfTrust</code> - the maximum size of the circle of trust.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed for the Pagerank stage.</dd>
<dd><code>tol</code> - maximum tolerated error value for the Pagerank stage. The stage will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>dampingFactor</code> - damping factor for the Pagerank stage.</dd>
<dd><code>salsaMaxIter</code> - maximum number of iterations that will be performed for the SALSA stage.</dd>
<dd><code>salsaTol</code> - maximum tolerated error value for the SALSA stage. The stage will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 PgxFuture&lt;Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt;&gt; promise = analyst.whomToFollowAsync(
   graph, vertex, 100, 500, 100, 0.001, 0.85, 100, 0.001);
 promise.thenAccept(wtf -&gt; {
   wtf.getFirst();
   wtf.getSecond();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-int-double-double-int-double-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollowAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;&nbsp;whomToFollowAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                                                                                     int&nbsp;topK,
                                                                                     int&nbsp;sizeCircleOfTrust,
                                                                                     int&nbsp;maxIter,
                                                                                     double&nbsp;tol,
                                                                                     double&nbsp;dampingFactor,
                                                                                     int&nbsp;salsaMaxIter,
                                                                                     double&nbsp;salsaTol,
                                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
                                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dd><code>topK</code> - the maximum number of recommendations that will be returned. This number should be smaller than the size of the circle of trust.</dd>
<dd><code>sizeCircleOfTrust</code> - the maximum size of the circle of trust.</dd>
<dd><code>maxIter</code> - maximum number of iterations that will be performed for the Pagerank stage.</dd>
<dd><code>tol</code> - maximum tolerated error value for the Pagerank stage. The stage will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>dampingFactor</code> - damping factor for the Pagerank stage.</dd>
<dd><code>salsaMaxIter</code> - maximum number of iterations that will be performed for the SALSA stage.</dd>
<dd><code>salsaTol</code> - maximum tolerated error value for the SALSA stage. The stage will stop once the sum of the error values of all vertices becomes smaller than this value.</dd>
<dd><code>hubs</code> - (out argument) vertex sequence holding the top rated hub vertices (similar users) for the recommendations.</dd>
<dd><code>authorities</code> - (out argument) vertex sequence holding the top rated authority vertices (users to follow) for the recommendations.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexSequence&lt;Integer&gt; hubs = graph.createVertexSequence();
 VertexSequence&lt;Integer&gt; authorities = graph.createVertexSequence();
 PgxFuture&lt;Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt;&gt; promise = analyst.whomToFollowAsync(
   graph, vertex, 100, 500, 100, 0.001, 0.85, 100, 0.001, hubs, authorities);
 promise.thenAccept(wtf -&gt; {
   wtf.getFirst();
   wtf.getSecond();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-int-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollowAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;&nbsp;whomToFollowAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                                                                                     int&nbsp;topK,
                                                                                     int&nbsp;sizeCircleOfTrust,
                                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
                                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dd><code>topK</code> - the maximum number of recommendations that will be returned. This number should be smaller than the size of the circle of trust.</dd>
<dd><code>sizeCircleOfTrust</code> - the maximum size of the circle of trust.</dd>
<dd><code>hubs</code> - (out argument) vertex sequence holding the top rated hub vertices (similar users) for the recommendations.</dd>
<dd><code>authorities</code> - (out argument) vertex sequence holding the top rated authority vertices (users to follow) for the recommendations.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexSequence&lt;Integer&gt; hubs = graph.createVertexSequence();
 VertexSequence&lt;Integer&gt; authorities = graph.createVertexSequence();
 PgxFuture&lt;Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt;&gt; promise = analyst.whomToFollowAsync(
   graph, vertex, 100, 500, hubs, authorities);
 promise.thenAccept(wtf -&gt; {
   wtf.getFirst();
   wtf.getSecond();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-int-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whomToFollowAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;&nbsp;whomToFollowAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                                                                                     int&nbsp;topK,
                                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
                                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dd><code>topK</code> - the maximum number of recommendations that will be returned. This number should be smaller than the size of the circle of trust.</dd>
<dd><code>hubs</code> - (out argument) vertex sequence holding the top rated hub vertices (similar users) for the recommendations.</dd>
<dd><code>authorities</code> - (out argument) vertex sequence holding the top rated authority vertices (users to follow) for the recommendations.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexSequence&lt;Integer&gt; hubs = graph.createVertexSequence();
 VertexSequence&lt;Integer&gt; authorities = graph.createVertexSequence();
 PgxFuture&lt;Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt;&gt; promise = analyst.whomToFollowAsync(
   graph, vertex, 100, hubs, authorities);
 promise.thenAccept(wtf -&gt; {
   wtf.getFirst();
   wtf.getSecond();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
<a name="whomToFollowAsync-oracle.pgx.api.PgxGraph-oracle.pgx.api.PgxVertex-oracle.pgx.api.VertexSequence-oracle.pgx.api.VertexSequence-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>whomToFollowAsync</h4>
<pre>public&nbsp;&lt;ID&gt;&nbsp;<a href="../../../oracle/pgx/api/PgxFuture.html" title="class in oracle.pgx.api">PgxFuture</a>&lt;<a href="../../../oracle/pgx/common/Pair.html" title="class in oracle.pgx.common">Pair</a>&lt;<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;,<a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&gt;&gt;&nbsp;whomToFollowAsync(<a href="../../../oracle/pgx/api/PgxGraph.html" title="class in oracle.pgx.api">PgxGraph</a>&nbsp;graph,
                                                                                     <a href="../../../oracle/pgx/api/PgxVertex.html" title="class in oracle.pgx.api">PgxVertex</a>&lt;ID&gt;&nbsp;vertex,
                                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;hubs,
                                                                                     <a href="../../../oracle/pgx/api/VertexSequence.html" title="class in oracle.pgx.api">VertexSequence</a>&lt;ID&gt;&nbsp;authorities)</pre>
<div class="block"><p>WTF is a recommendation algorithm. It returns two vertex sequences: one of similar users and a second one with users to follow.
</p>
      <h2>Definition</h2>
      <p>The Whom To Follow algorithm is composed by two main stages: the first one is meant to get the relevant vertices (users) for a given source vertex (particular user), which in this implementation is done with personalized Pagerank for the given source vertex. While the second stage analizes the relationships between the relevant vertices previously found through the edges linking them with their neighbors. This second stage relies on SALSA algorithm and it asigns a ranking score to all the hubs and authority vertices, so the recommendations can come from this assigned values. Whom To Follow takes the concept of authority and hub vertices, and adapts it to users in social networks. The hub vertices become similar users with respect to the given source vertex (also an user), and the authority vertices are translated into users that might be on the interest of the source vertex, i.e. users to follow.
</p>
      <h2>Implementation Details</h2>
      <p>The implementation of this algorithm uses an iterative method. It will converge once it reaches the error tolerance criteria or the maximum number of iterations.
</p>
      <h2>Complexity</h2>
      <ul>
        <li>Time: <code>O(E * (p + s)) with E = number of edges, p <= maximum number of iterations for the Pagerank step, s <= maximum number of iterations for the SALSA step</code></li>
        <li>Space: <code>O(5 * V) with V = number of vertices</code></li>
      </ul>
      <h2>Default Values</h2>
      <ul>
      
      </ul>
      <h2>Applications</h2>
      <ul>
      <li>WTF was designed to find and recommend similar users (hub vertices) and potential users to follow (authority vertices) in social networks with directed edges in their structures.</li>
      </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph.</dd>
<dd><code>vertex</code> - the chosen vertex from the graph for personalization of the recommendations.</dd>
<dd><code>hubs</code> - (out argument) vertex sequence holding the top rated hub vertices (similar users) for the recommendations.</dd>
<dd><code>authorities</code> - (out argument) vertex sequence holding the top rated authority vertices (users to follow) for the recommendations.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Pair holding the node sequences with the hub and authority recommendations.

 <h2>Examples</h2>
 <pre>
 <code>
 PgxGraph graph = ...;
 PgxVertex&lt;Integer&gt; vertex = graph.getVertex(128);
 VertexSequence&lt;Integer&gt; hubs = graph.createVertexSequence();
 VertexSequence&lt;Integer&gt; authorities = graph.createVertexSequence();
 PgxFuture&lt;Pair&lt;VertexSequence&lt;Integer&gt;, VertexSequence&lt;Integer&gt;&gt;&gt; promise = analyst.whomToFollowAsync(
   graph, vertex, hubs, authorities);
 promise.thenAccept(wtf -&gt; {
   wtf.getFirst();
   wtf.getSecond();
 });
 </code>
 </pre></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Analyst.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><b>Oracle&reg; Graph Java API Reference for Property Graph<br/>Release 22.1</b> <br/>F51971-01</div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../oracle/pgx/api/AllPaths.html" title="class in oracle.pgx.api"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../oracle/pgx/api/BipartiteGraph.html" title="class in oracle.pgx.api"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?oracle/pgx/api/Analyst.html" target="_top">Frames</a></li>
<li><a href="Analyst.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small><center>Copyright &#169; 2010, 2022 Oracle and/or its affiliates. All rights reserved.</center></small></p>
</body>
</html>
